###############################################################################
#
# IAR ANSI C/C++ Compiler V8.42.1.233/W32 for ARM         04/Feb/2020  10:25:16
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\mohit\Desktop\Microapps
#        projects\LAB4Task1\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
#    Command line      =
#        -f C:\Users\mohit\AppData\Local\Temp\EW173A.tmp
#        ("C:\Users\mohit\Desktop\Microapps
#        projects\LAB4Task1\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c"
#        -D USE_HAL_DRIVER -D STM32F429xx -lC "C:\Users\mohit\Desktop\Microapps
#        projects\LAB4Task1\EWARM\LAB4Task1\List" -o
#        "C:\Users\mohit\Desktop\Microapps
#        projects\LAB4Task1\EWARM\LAB4Task1\Obj" --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I "C:\Users\mohit\Desktop\Microapps projects\LAB4Task1\EWARM/../Inc\"
#        -I "C:\Users\mohit\Desktop\Microapps
#        projects\LAB4Task1\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\" -I
#        "C:\Users\mohit\Desktop\Microapps
#        projects\LAB4Task1\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\"
#        -I "C:\Users\mohit\Desktop\Microapps
#        projects\LAB4Task1\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\"
#        -I "C:\Users\mohit\Desktop\Microapps
#        projects\LAB4Task1\EWARM/../Drivers/CMSIS/Include\" -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\mohit\Desktop\Microapps
#        projects\LAB4Task1\EWARM\LAB4Task1\List\stm32f4xx_hal_tim.lst
#    Object file       =
#        C:\Users\mohit\Desktop\Microapps
#        projects\LAB4Task1\EWARM\LAB4Task1\Obj\stm32f4xx_hal_tim.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#      __size_limit    =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Users\mohit\Desktop\Microapps projects\LAB4Task1\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Timer (TIM) peripheral:
      8            *           + TIM Time Base Initialization
      9            *           + TIM Time Base Start
     10            *           + TIM Time Base Start Interruption
     11            *           + TIM Time Base Start DMA
     12            *           + TIM Output Compare/PWM Initialization
     13            *           + TIM Output Compare/PWM Channel Configuration
     14            *           + TIM Output Compare/PWM  Start
     15            *           + TIM Output Compare/PWM  Start Interruption
     16            *           + TIM Output Compare/PWM Start DMA
     17            *           + TIM Input Capture Initialization
     18            *           + TIM Input Capture Channel Configuration
     19            *           + TIM Input Capture Start
     20            *           + TIM Input Capture Start Interruption
     21            *           + TIM Input Capture Start DMA
     22            *           + TIM One Pulse Initialization
     23            *           + TIM One Pulse Channel Configuration
     24            *           + TIM One Pulse Start
     25            *           + TIM Encoder Interface Initialization
     26            *           + TIM Encoder Interface Start
     27            *           + TIM Encoder Interface Start Interruption
     28            *           + TIM Encoder Interface Start DMA
     29            *           + Commutation Event configuration with Interruption and DMA
     30            *           + TIM OCRef clear configuration
     31            *           + TIM External Clock configuration
     32            @verbatim
     33            ==============================================================================
     34                                ##### TIMER Generic features #####
     35            ==============================================================================
     36            [..] The Timer features include:
     37                 (#) 16-bit up, down, up/down auto-reload counter.
     38                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the
     39                     counter clock frequency either by any factor between 1 and 65536.
     40                 (#) Up to 4 independent channels for:
     41                     (++) Input Capture
     42                     (++) Output Compare
     43                     (++) PWM generation (Edge and Center-aligned Mode)
     44                     (++) One-pulse mode output
     45                 (#) Synchronization circuit to control the timer with external signals and to interconnect
     46                      several timers together.
     47                 (#) Supports incremental encoder for positioning purposes
     48          
     49                      ##### How to use this driver #####
     50            ==============================================================================
     51              [..]
     52               (#) Initialize the TIM low level resources by implementing the following functions
     53                   depending on the selected feature:
     54                     (++) Time Base : HAL_TIM_Base_MspInit()
     55                     (++) Input Capture : HAL_TIM_IC_MspInit()
     56                     (++) Output Compare : HAL_TIM_OC_MspInit()
     57                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     58                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     59                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     60          
     61               (#) Initialize the TIM low level resources :
     62                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     63                  (##) TIM pins configuration
     64                      (+++) Enable the clock for the TIM GPIOs using the following function:
     65                       __HAL_RCC_GPIOx_CLK_ENABLE();
     66                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     67          
     68               (#) The external Clock can be configured, if needed (the default clock is the
     69                   internal clock from the APBx), using the following function:
     70                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     71                   any start function.
     72          
     73               (#) Configure the TIM in the desired functioning mode using one of the
     74                 Initialization function of this driver:
     75                 (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     76                 (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an
     77                      Output Compare signal.
     78                 (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a
     79                      PWM signal.
     80                 (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an
     81                      external signal.
     82                 (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer
     83                      in One Pulse Mode.
     84                 (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     85          
     86               (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
     87                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     88                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     89                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     90                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     91                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     92                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     93          
     94               (#) The DMA Burst is managed with the two following functions:
     95                   HAL_TIM_DMABurst_WriteStart()
     96                   HAL_TIM_DMABurst_ReadStart()
     97          
     98              *** Callback registration ***
     99            =============================================
    100          
    101            [..]
    102            The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1
    103            allows the user to configure dynamically the driver callbacks.
    104          
    105            [..]
    106            Use Function @ref HAL_TIM_RegisterCallback() to register a callback.
    107            @ref HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,
    108            the Callback ID and a pointer to the user callback function.
    109          
    110            [..]
    111            Use function @ref HAL_TIM_UnRegisterCallback() to reset a callback to the default
    112            weak function.
    113            @ref HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
    114            and the Callback ID.
    115          
    116            [..]
    117            These functions allow to register/unregister following callbacks:
    118              (+) Base_MspInitCallback              : TIM Base Msp Init Callback.
    119              (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.
    120              (+) IC_MspInitCallback                : TIM IC Msp Init Callback.
    121              (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.
    122              (+) OC_MspInitCallback                : TIM OC Msp Init Callback.
    123              (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.
    124              (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.
    125              (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.
    126              (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.
    127              (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.
    128              (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.
    129              (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.
    130              (+) HallSensor_MspInitCallback        : TIM Hall Sensor Msp Init Callback.
    131              (+) HallSensor_MspDeInitCallback      : TIM Hall Sensor Msp DeInit Callback.
    132              (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.
    133              (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.
    134              (+) TriggerCallback                   : TIM Trigger Callback.
    135              (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.
    136              (+) IC_CaptureCallback                : TIM Input Capture Callback.
    137              (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.
    138              (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.
    139              (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.
    140              (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.
    141              (+) ErrorCallback                     : TIM Error Callback.
    142              (+) CommutationCallback               : TIM Commutation Callback.
    143              (+) CommutationHalfCpltCallback       : TIM Commutation half complete Callback.
    144              (+) BreakCallback                     : TIM Break Callback.
    145          
    146            [..]
    147          By default, after the Init and when the state is HAL_TIM_STATE_RESET
    148          all interrupt callbacks are set to the corresponding weak functions:
    149            examples @ref HAL_TIM_TriggerCallback(), @ref HAL_TIM_ErrorCallback().
    150          
    151            [..]
    152            Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
    153            functionalities in the Init / DeInit only when these callbacks are null
    154            (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit
    155              keep and use the user MspInit / MspDeInit callbacks(registered beforehand)
    156          
    157            [..]
    158              Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.
    159              Exception done MspInit / MspDeInit that can be registered / unregistered
    160              in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,
    161              thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.
    162            In that case first register the MspInit/MspDeInit user callbacks
    163                using @ref HAL_TIM_RegisterCallback() before calling DeInit or Init function.
    164          
    165            [..]
    166                When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or
    167                not defined, the callback registration feature is not available and all callbacks
    168                are set to the corresponding weak functions.
    169          
    170            @endverbatim
    171            ******************************************************************************
    172            * @attention
    173            *
    174            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    175            * All rights reserved.</center></h2>
    176            *
    177            * This software component is licensed by ST under BSD 3-Clause license,
    178            * the "License"; You may not use this file except in compliance with the
    179            * License. You may obtain a copy of the License at:
    180            *                        opensource.org/licenses/BSD-3-Clause
    181            *
    182            ******************************************************************************
    183            */
    184          
    185          /* Includes ------------------------------------------------------------------*/
    186          #include "stm32f4xx_hal.h"
    187          
    188          /** @addtogroup STM32F4xx_HAL_Driver
    189            * @{
    190            */
    191          
    192          /** @defgroup TIM TIM
    193            * @brief TIM HAL module driver
    194            * @{
    195            */
    196          
    197          #ifdef HAL_TIM_MODULE_ENABLED
    198          
    199          /* Private typedef -----------------------------------------------------------*/
    200          /* Private define ------------------------------------------------------------*/
    201          /* Private macro -------------------------------------------------------------*/
    202          /* Private variables ---------------------------------------------------------*/
    203          /* Private function prototypes -----------------------------------------------*/
    204          /** @addtogroup TIM_Private_Functions
    205            * @{
    206            */
    207          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    208          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    209          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    210          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    211          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    212                                        uint32_t TIM_ICFilter);
    213          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    214          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    215                                        uint32_t TIM_ICFilter);
    216          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    217                                        uint32_t TIM_ICFilter);
    218          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource);
    219          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    220          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma);
    221          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    222          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma);
    223          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    224                                                            TIM_SlaveConfigTypeDef *sSlaveConfig);
    225          /**
    226            * @}
    227            */
    228          /* Exported functions --------------------------------------------------------*/
    229          
    230          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    231            * @{
    232            */
    233          
    234          /** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions
    235            *  @brief    Time Base functions
    236            *
    237          @verbatim
    238            ==============================================================================
    239                        ##### Time Base functions #####
    240            ==============================================================================
    241            [..]
    242              This section provides functions allowing to:
    243              (+) Initialize and configure the TIM base.
    244              (+) De-initialize the TIM base.
    245              (+) Start the Time Base.
    246              (+) Stop the Time Base.
    247              (+) Start the Time Base and enable interrupt.
    248              (+) Stop the Time Base and disable interrupt.
    249              (+) Start the Time Base and enable DMA transfer.
    250              (+) Stop the Time Base and disable DMA transfer.
    251          
    252          @endverbatim
    253            * @{
    254            */
    255          /**
    256            * @brief  Initializes the TIM Time base Unit according to the specified
    257            *         parameters in the TIM_HandleTypeDef and initialize the associated handle.
    258            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    259            *         requires a timer reset to avoid unexpected direction
    260            *         due to DIR bit readonly in center aligned mode.
    261            *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
    262            * @param  htim TIM Base handle
    263            * @retval HAL status
    264            */
    265          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    266          {
    267            /* Check the TIM handle allocation */
    268            if (htim == NULL)
    269            {
    270              return HAL_ERROR;
    271            }
    272          
    273            /* Check the parameters */
    274            assert_param(IS_TIM_INSTANCE(htim->Instance));
    275            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    276            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    277            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    278          
    279            if (htim->State == HAL_TIM_STATE_RESET)
    280            {
    281              /* Allocate lock resource and initialize it */
    282              htim->Lock = HAL_UNLOCKED;
    283          
    284          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    285              /* Reset interrupt callbacks to legacy weak callbacks */
    286              TIM_ResetCallback(htim);
    287          
    288              if (htim->Base_MspInitCallback == NULL)
    289              {
    290                htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
    291              }
    292              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    293              htim->Base_MspInitCallback(htim);
    294          #else
    295              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    296              HAL_TIM_Base_MspInit(htim);
    297          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    298            }
    299          
    300            /* Set the TIM state */
    301            htim->State = HAL_TIM_STATE_BUSY;
    302          
    303            /* Set the Time Base configuration */
    304            TIM_Base_SetConfig(htim->Instance, &htim->Init);
    305          
    306            /* Initialize the TIM state*/
    307            htim->State = HAL_TIM_STATE_READY;
    308          
    309            return HAL_OK;
    310          }
    311          
    312          /**
    313            * @brief  DeInitializes the TIM Base peripheral
    314            * @param  htim TIM Base handle
    315            * @retval HAL status
    316            */
    317          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    318          {
    319            /* Check the parameters */
    320            assert_param(IS_TIM_INSTANCE(htim->Instance));
    321          
    322            htim->State = HAL_TIM_STATE_BUSY;
    323          
    324            /* Disable the TIM Peripheral Clock */
    325            __HAL_TIM_DISABLE(htim);
    326          
    327          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    328            if (htim->Base_MspDeInitCallback == NULL)
    329            {
    330              htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
    331            }
    332            /* DeInit the low level hardware */
    333            htim->Base_MspDeInitCallback(htim);
    334          #else
    335            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    336            HAL_TIM_Base_MspDeInit(htim);
    337          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    338          
    339            /* Change TIM state */
    340            htim->State = HAL_TIM_STATE_RESET;
    341          
    342            /* Release Lock */
    343            __HAL_UNLOCK(htim);
    344          
    345            return HAL_OK;
    346          }
    347          
    348          /**
    349            * @brief  Initializes the TIM Base MSP.
    350            * @param  htim TIM Base handle
    351            * @retval None
    352            */
    353          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    354          {
    355            /* Prevent unused argument(s) compilation warning */
    356            UNUSED(htim);
    357          
    358            /* NOTE : This function should not be modified, when the callback is needed,
    359                      the HAL_TIM_Base_MspInit could be implemented in the user file
    360             */
    361          }
    362          
    363          /**
    364            * @brief  DeInitializes TIM Base MSP.
    365            * @param  htim TIM Base handle
    366            * @retval None
    367            */
    368          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    369          {
    370            /* Prevent unused argument(s) compilation warning */
    371            UNUSED(htim);
    372          
    373            /* NOTE : This function should not be modified, when the callback is needed,
    374                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    375             */
    376          }
    377          
    378          
    379          /**
    380            * @brief  Starts the TIM Base generation.
    381            * @param  htim TIM Base handle
    382            * @retval HAL status
    383            */
    384          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    385          {
    386            uint32_t tmpsmcr;
    387          
    388            /* Check the parameters */
    389            assert_param(IS_TIM_INSTANCE(htim->Instance));
    390          
    391            /* Set the TIM state */
    392            htim->State = HAL_TIM_STATE_BUSY;
    393          
    394            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    395            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    396            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    397            {
    398              __HAL_TIM_ENABLE(htim);
    399            }
    400          
    401            /* Change the TIM state*/
    402            htim->State = HAL_TIM_STATE_READY;
    403          
    404            /* Return function status */
    405            return HAL_OK;
    406          }
    407          
    408          /**
    409            * @brief  Stops the TIM Base generation.
    410            * @param  htim TIM Base handle
    411            * @retval HAL status
    412            */
    413          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    414          {
    415            /* Check the parameters */
    416            assert_param(IS_TIM_INSTANCE(htim->Instance));
    417          
    418            /* Set the TIM state */
    419            htim->State = HAL_TIM_STATE_BUSY;
    420          
    421            /* Disable the Peripheral */
    422            __HAL_TIM_DISABLE(htim);
    423          
    424            /* Change the TIM state*/
    425            htim->State = HAL_TIM_STATE_READY;
    426          
    427            /* Return function status */
    428            return HAL_OK;
    429          }
    430          
    431          /**
    432            * @brief  Starts the TIM Base generation in interrupt mode.
    433            * @param  htim TIM Base handle
    434            * @retval HAL status
    435            */
    436          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    437          {
    438            uint32_t tmpsmcr;
    439          
    440            /* Check the parameters */
    441            assert_param(IS_TIM_INSTANCE(htim->Instance));
    442          
    443            /* Enable the TIM Update interrupt */
    444            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
    445          
    446            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    447            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    448            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    449            {
    450              __HAL_TIM_ENABLE(htim);
    451            }
    452          
    453            /* Return function status */
    454            return HAL_OK;
    455          }
    456          
    457          /**
    458            * @brief  Stops the TIM Base generation in interrupt mode.
    459            * @param  htim TIM Base handle
    460            * @retval HAL status
    461            */
    462          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    463          {
    464            /* Check the parameters */
    465            assert_param(IS_TIM_INSTANCE(htim->Instance));
    466            /* Disable the TIM Update interrupt */
    467            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
    468          
    469            /* Disable the Peripheral */
    470            __HAL_TIM_DISABLE(htim);
    471          
    472            /* Return function status */
    473            return HAL_OK;
    474          }
    475          
    476          /**
    477            * @brief  Starts the TIM Base generation in DMA mode.
    478            * @param  htim TIM Base handle
    479            * @param  pData The source Buffer address.
    480            * @param  Length The length of data to be transferred from memory to peripheral.
    481            * @retval HAL status
    482            */
    483          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    484          {
    485            uint32_t tmpsmcr;
    486          
    487            /* Check the parameters */
    488            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    489          
    490            if (htim->State == HAL_TIM_STATE_BUSY)
    491            {
    492              return HAL_BUSY;
    493            }
    494            else if (htim->State == HAL_TIM_STATE_READY)
    495            {
    496              if ((pData == NULL) && (Length > 0U))
    497              {
    498                return HAL_ERROR;
    499              }
    500              else
    501              {
    502                htim->State = HAL_TIM_STATE_BUSY;
    503              }
    504            }
    505            else
    506            {
    507              /* nothing to do */
    508            }
    509          
    510            /* Set the DMA Period elapsed callbacks */
    511            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
    512            htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
    513          
    514            /* Set the DMA error callback */
    515            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
    516          
    517            /* Enable the DMA stream */
    518            if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length) != HAL_OK)
    519            {
    520              return HAL_ERROR;
    521            }
    522          
    523            /* Enable the TIM Update DMA request */
    524            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
    525          
    526            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    527            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    528            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    529            {
    530              __HAL_TIM_ENABLE(htim);
    531            }
    532          
    533            /* Return function status */
    534            return HAL_OK;
    535          }
    536          
    537          /**
    538            * @brief  Stops the TIM Base generation in DMA mode.
    539            * @param  htim TIM Base handle
    540            * @retval HAL status
    541            */
    542          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    543          {
    544            /* Check the parameters */
    545            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    546          
    547            /* Disable the TIM Update DMA request */
    548            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
    549          
    550            (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
    551          
    552            /* Disable the Peripheral */
    553            __HAL_TIM_DISABLE(htim);
    554          
    555            /* Change the htim state */
    556            htim->State = HAL_TIM_STATE_READY;
    557          
    558            /* Return function status */
    559            return HAL_OK;
    560          }
    561          
    562          /**
    563            * @}
    564            */
    565          
    566          /** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions
    567            *  @brief    TIM Output Compare functions
    568            *
    569          @verbatim
    570            ==============================================================================
    571                            ##### TIM Output Compare functions #####
    572            ==============================================================================
    573            [..]
    574              This section provides functions allowing to:
    575              (+) Initialize and configure the TIM Output Compare.
    576              (+) De-initialize the TIM Output Compare.
    577              (+) Start the TIM Output Compare.
    578              (+) Stop the TIM Output Compare.
    579              (+) Start the TIM Output Compare and enable interrupt.
    580              (+) Stop the TIM Output Compare and disable interrupt.
    581              (+) Start the TIM Output Compare and enable DMA transfer.
    582              (+) Stop the TIM Output Compare and disable DMA transfer.
    583          
    584          @endverbatim
    585            * @{
    586            */
    587          /**
    588            * @brief  Initializes the TIM Output Compare according to the specified
    589            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
    590            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    591            *         requires a timer reset to avoid unexpected direction
    592            *         due to DIR bit readonly in center aligned mode.
    593            *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
    594            * @param  htim TIM Output Compare handle
    595            * @retval HAL status
    596            */
    597          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
    598          {
    599            /* Check the TIM handle allocation */
    600            if (htim == NULL)
    601            {
    602              return HAL_ERROR;
    603            }
    604          
    605            /* Check the parameters */
    606            assert_param(IS_TIM_INSTANCE(htim->Instance));
    607            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    608            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    609            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    610          
    611            if (htim->State == HAL_TIM_STATE_RESET)
    612            {
    613              /* Allocate lock resource and initialize it */
    614              htim->Lock = HAL_UNLOCKED;
    615          
    616          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    617              /* Reset interrupt callbacks to legacy weak callbacks */
    618              TIM_ResetCallback(htim);
    619          
    620              if (htim->OC_MspInitCallback == NULL)
    621              {
    622                htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;
    623              }
    624              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    625              htim->OC_MspInitCallback(htim);
    626          #else
    627              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    628              HAL_TIM_OC_MspInit(htim);
    629          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    630            }
    631          
    632            /* Set the TIM state */
    633            htim->State = HAL_TIM_STATE_BUSY;
    634          
    635            /* Init the base time for the Output Compare */
    636            TIM_Base_SetConfig(htim->Instance,  &htim->Init);
    637          
    638            /* Initialize the TIM state*/
    639            htim->State = HAL_TIM_STATE_READY;
    640          
    641            return HAL_OK;
    642          }
    643          
    644          /**
    645            * @brief  DeInitializes the TIM peripheral
    646            * @param  htim TIM Output Compare handle
    647            * @retval HAL status
    648            */
    649          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    650          {
    651            /* Check the parameters */
    652            assert_param(IS_TIM_INSTANCE(htim->Instance));
    653          
    654            htim->State = HAL_TIM_STATE_BUSY;
    655          
    656            /* Disable the TIM Peripheral Clock */
    657            __HAL_TIM_DISABLE(htim);
    658          
    659          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    660            if (htim->OC_MspDeInitCallback == NULL)
    661            {
    662              htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
    663            }
    664            /* DeInit the low level hardware */
    665            htim->OC_MspDeInitCallback(htim);
    666          #else
    667            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    668            HAL_TIM_OC_MspDeInit(htim);
    669          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    670          
    671            /* Change TIM state */
    672            htim->State = HAL_TIM_STATE_RESET;
    673          
    674            /* Release Lock */
    675            __HAL_UNLOCK(htim);
    676          
    677            return HAL_OK;
    678          }
    679          
    680          /**
    681            * @brief  Initializes the TIM Output Compare MSP.
    682            * @param  htim TIM Output Compare handle
    683            * @retval None
    684            */
    685          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    686          {
    687            /* Prevent unused argument(s) compilation warning */
    688            UNUSED(htim);
    689          
    690            /* NOTE : This function should not be modified, when the callback is needed,
    691                      the HAL_TIM_OC_MspInit could be implemented in the user file
    692             */
    693          }
    694          
    695          /**
    696            * @brief  DeInitializes TIM Output Compare MSP.
    697            * @param  htim TIM Output Compare handle
    698            * @retval None
    699            */
    700          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    701          {
    702            /* Prevent unused argument(s) compilation warning */
    703            UNUSED(htim);
    704          
    705            /* NOTE : This function should not be modified, when the callback is needed,
    706                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    707             */
    708          }
    709          
    710          /**
    711            * @brief  Starts the TIM Output Compare signal generation.
    712            * @param  htim TIM Output Compare handle
    713            * @param  Channel TIM Channel to be enabled
    714            *          This parameter can be one of the following values:
    715            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    716            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    717            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    718            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    719            * @retval HAL status
    720            */
    721          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    722          {
    723            uint32_t tmpsmcr;
    724          
    725            /* Check the parameters */
    726            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    727          
    728            /* Enable the Output compare channel */
    729            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    730          
    731            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    732            {
    733              /* Enable the main output */
    734              __HAL_TIM_MOE_ENABLE(htim);
    735            }
    736          
    737            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    738            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    739            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    740            {
    741              __HAL_TIM_ENABLE(htim);
    742            }
    743          
    744            /* Return function status */
    745            return HAL_OK;
    746          }
    747          
    748          /**
    749            * @brief  Stops the TIM Output Compare signal generation.
    750            * @param  htim TIM Output Compare handle
    751            * @param  Channel TIM Channel to be disabled
    752            *          This parameter can be one of the following values:
    753            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    754            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    755            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    756            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    757            * @retval HAL status
    758            */
    759          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    760          {
    761            /* Check the parameters */
    762            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    763          
    764            /* Disable the Output compare channel */
    765            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    766          
    767            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    768            {
    769              /* Disable the Main Output */
    770              __HAL_TIM_MOE_DISABLE(htim);
    771            }
    772          
    773            /* Disable the Peripheral */
    774            __HAL_TIM_DISABLE(htim);
    775          
    776            /* Return function status */
    777            return HAL_OK;
    778          }
    779          
    780          /**
    781            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    782            * @param  htim TIM Output Compare handle
    783            * @param  Channel TIM Channel to be enabled
    784            *          This parameter can be one of the following values:
    785            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    786            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    787            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    788            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    789            * @retval HAL status
    790            */
    791          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    792          {
    793            uint32_t tmpsmcr;
    794          
    795            /* Check the parameters */
    796            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    797          
    798            switch (Channel)
    799            {
    800              case TIM_CHANNEL_1:
    801              {
    802                /* Enable the TIM Capture/Compare 1 interrupt */
    803                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
    804                break;
    805              }
    806          
    807              case TIM_CHANNEL_2:
    808              {
    809                /* Enable the TIM Capture/Compare 2 interrupt */
    810                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
    811                break;
    812              }
    813          
    814              case TIM_CHANNEL_3:
    815              {
    816                /* Enable the TIM Capture/Compare 3 interrupt */
    817                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
    818                break;
    819              }
    820          
    821              case TIM_CHANNEL_4:
    822              {
    823                /* Enable the TIM Capture/Compare 4 interrupt */
    824                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
    825                break;
    826              }
    827          
    828              default:
    829                break;
    830            }
    831          
    832            /* Enable the Output compare channel */
    833            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    834          
    835            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    836            {
    837              /* Enable the main output */
    838              __HAL_TIM_MOE_ENABLE(htim);
    839            }
    840          
    841            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    842            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    843            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    844            {
    845              __HAL_TIM_ENABLE(htim);
    846            }
    847          
    848            /* Return function status */
    849            return HAL_OK;
    850          }
    851          
    852          /**
    853            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    854            * @param  htim TIM Output Compare handle
    855            * @param  Channel TIM Channel to be disabled
    856            *          This parameter can be one of the following values:
    857            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    858            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    859            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    860            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    861            * @retval HAL status
    862            */
    863          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    864          {
    865            /* Check the parameters */
    866            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    867          
    868            switch (Channel)
    869            {
    870              case TIM_CHANNEL_1:
    871              {
    872                /* Disable the TIM Capture/Compare 1 interrupt */
    873                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
    874                break;
    875              }
    876          
    877              case TIM_CHANNEL_2:
    878              {
    879                /* Disable the TIM Capture/Compare 2 interrupt */
    880                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
    881                break;
    882              }
    883          
    884              case TIM_CHANNEL_3:
    885              {
    886                /* Disable the TIM Capture/Compare 3 interrupt */
    887                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
    888                break;
    889              }
    890          
    891              case TIM_CHANNEL_4:
    892              {
    893                /* Disable the TIM Capture/Compare 4 interrupt */
    894                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
    895                break;
    896              }
    897          
    898              default:
    899                break;
    900            }
    901          
    902            /* Disable the Output compare channel */
    903            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    904          
    905            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    906            {
    907              /* Disable the Main Output */
    908              __HAL_TIM_MOE_DISABLE(htim);
    909            }
    910          
    911            /* Disable the Peripheral */
    912            __HAL_TIM_DISABLE(htim);
    913          
    914            /* Return function status */
    915            return HAL_OK;
    916          }
    917          
    918          /**
    919            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    920            * @param  htim TIM Output Compare handle
    921            * @param  Channel TIM Channel to be enabled
    922            *          This parameter can be one of the following values:
    923            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    924            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    925            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    926            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    927            * @param  pData The source Buffer address.
    928            * @param  Length The length of data to be transferred from memory to TIM peripheral
    929            * @retval HAL status
    930            */
    931          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    932          {
    933            uint32_t tmpsmcr;
    934          
    935            /* Check the parameters */
    936            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    937          
    938            if (htim->State == HAL_TIM_STATE_BUSY)
    939            {
    940              return HAL_BUSY;
    941            }
    942            else if (htim->State == HAL_TIM_STATE_READY)
    943            {
    944              if ((pData == NULL) && (Length > 0U))
    945              {
    946                return HAL_ERROR;
    947              }
    948              else
    949              {
    950                htim->State = HAL_TIM_STATE_BUSY;
    951              }
    952            }
    953            else
    954            {
    955              /* nothing to do */
    956            }
    957          
    958            switch (Channel)
    959            {
    960              case TIM_CHANNEL_1:
    961              {
    962                /* Set the DMA compare callbacks */
    963                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
    964                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    965          
    966                /* Set the DMA error callback */
    967                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
    968          
    969                /* Enable the DMA stream */
    970                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
    971                {
    972                  return HAL_ERROR;
    973                }
    974          
    975                /* Enable the TIM Capture/Compare 1 DMA request */
    976                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
    977                break;
    978              }
    979          
    980              case TIM_CHANNEL_2:
    981              {
    982                /* Set the DMA compare callbacks */
    983                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
    984                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    985          
    986                /* Set the DMA error callback */
    987                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
    988          
    989                /* Enable the DMA stream */
    990                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
    991                {
    992                  return HAL_ERROR;
    993                }
    994          
    995                /* Enable the TIM Capture/Compare 2 DMA request */
    996                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
    997                break;
    998              }
    999          
   1000              case TIM_CHANNEL_3:
   1001              {
   1002                /* Set the DMA compare callbacks */
   1003                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1004                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1005          
   1006                /* Set the DMA error callback */
   1007                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1008          
   1009                /* Enable the DMA stream */
   1010                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   1011                {
   1012                  return HAL_ERROR;
   1013                }
   1014                /* Enable the TIM Capture/Compare 3 DMA request */
   1015                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1016                break;
   1017              }
   1018          
   1019              case TIM_CHANNEL_4:
   1020              {
   1021                /* Set the DMA compare callbacks */
   1022                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1023                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1024          
   1025                /* Set the DMA error callback */
   1026                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1027          
   1028                /* Enable the DMA stream */
   1029                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   1030                {
   1031                  return HAL_ERROR;
   1032                }
   1033                /* Enable the TIM Capture/Compare 4 DMA request */
   1034                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1035                break;
   1036              }
   1037          
   1038              default:
   1039                break;
   1040            }
   1041          
   1042            /* Enable the Output compare channel */
   1043            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1044          
   1045            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1046            {
   1047              /* Enable the main output */
   1048              __HAL_TIM_MOE_ENABLE(htim);
   1049            }
   1050          
   1051            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1052            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1053            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1054            {
   1055              __HAL_TIM_ENABLE(htim);
   1056            }
   1057          
   1058            /* Return function status */
   1059            return HAL_OK;
   1060          }
   1061          
   1062          /**
   1063            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
   1064            * @param  htim TIM Output Compare handle
   1065            * @param  Channel TIM Channel to be disabled
   1066            *          This parameter can be one of the following values:
   1067            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1068            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1069            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1070            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1071            * @retval HAL status
   1072            */
   1073          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1074          {
   1075            /* Check the parameters */
   1076            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1077          
   1078            switch (Channel)
   1079            {
   1080              case TIM_CHANNEL_1:
   1081              {
   1082                /* Disable the TIM Capture/Compare 1 DMA request */
   1083                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1084                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   1085                break;
   1086              }
   1087          
   1088              case TIM_CHANNEL_2:
   1089              {
   1090                /* Disable the TIM Capture/Compare 2 DMA request */
   1091                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1092                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   1093                break;
   1094              }
   1095          
   1096              case TIM_CHANNEL_3:
   1097              {
   1098                /* Disable the TIM Capture/Compare 3 DMA request */
   1099                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1100                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   1101                break;
   1102              }
   1103          
   1104              case TIM_CHANNEL_4:
   1105              {
   1106                /* Disable the TIM Capture/Compare 4 interrupt */
   1107                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1108                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   1109                break;
   1110              }
   1111          
   1112              default:
   1113                break;
   1114            }
   1115          
   1116            /* Disable the Output compare channel */
   1117            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1118          
   1119            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1120            {
   1121              /* Disable the Main Output */
   1122              __HAL_TIM_MOE_DISABLE(htim);
   1123            }
   1124          
   1125            /* Disable the Peripheral */
   1126            __HAL_TIM_DISABLE(htim);
   1127          
   1128            /* Change the htim state */
   1129            htim->State = HAL_TIM_STATE_READY;
   1130          
   1131            /* Return function status */
   1132            return HAL_OK;
   1133          }
   1134          
   1135          /**
   1136            * @}
   1137            */
   1138          
   1139          /** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions
   1140            *  @brief    TIM PWM functions
   1141            *
   1142          @verbatim
   1143            ==============================================================================
   1144                                    ##### TIM PWM functions #####
   1145            ==============================================================================
   1146            [..]
   1147              This section provides functions allowing to:
   1148              (+) Initialize and configure the TIM PWM.
   1149              (+) De-initialize the TIM PWM.
   1150              (+) Start the TIM PWM.
   1151              (+) Stop the TIM PWM.
   1152              (+) Start the TIM PWM and enable interrupt.
   1153              (+) Stop the TIM PWM and disable interrupt.
   1154              (+) Start the TIM PWM and enable DMA transfer.
   1155              (+) Stop the TIM PWM and disable DMA transfer.
   1156          
   1157          @endverbatim
   1158            * @{
   1159            */
   1160          /**
   1161            * @brief  Initializes the TIM PWM Time Base according to the specified
   1162            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1163            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1164            *         requires a timer reset to avoid unexpected direction
   1165            *         due to DIR bit readonly in center aligned mode.
   1166            *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
   1167            * @param  htim TIM PWM handle
   1168            * @retval HAL status
   1169            */
   1170          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
   1171          {
   1172            /* Check the TIM handle allocation */
   1173            if (htim == NULL)
   1174            {
   1175              return HAL_ERROR;
   1176            }
   1177          
   1178            /* Check the parameters */
   1179            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1180            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1181            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1182            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1183          
   1184            if (htim->State == HAL_TIM_STATE_RESET)
   1185            {
   1186              /* Allocate lock resource and initialize it */
   1187              htim->Lock = HAL_UNLOCKED;
   1188          
   1189          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1190              /* Reset interrupt callbacks to legacy weak callbacks */
   1191              TIM_ResetCallback(htim);
   1192          
   1193              if (htim->PWM_MspInitCallback == NULL)
   1194              {
   1195                htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
   1196              }
   1197              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1198              htim->PWM_MspInitCallback(htim);
   1199          #else
   1200              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1201              HAL_TIM_PWM_MspInit(htim);
   1202          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1203            }
   1204          
   1205            /* Set the TIM state */
   1206            htim->State = HAL_TIM_STATE_BUSY;
   1207          
   1208            /* Init the base time for the PWM */
   1209            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   1210          
   1211            /* Initialize the TIM state*/
   1212            htim->State = HAL_TIM_STATE_READY;
   1213          
   1214            return HAL_OK;
   1215          }
   1216          
   1217          /**
   1218            * @brief  DeInitializes the TIM peripheral
   1219            * @param  htim TIM PWM handle
   1220            * @retval HAL status
   1221            */
   1222          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1223          {
   1224            /* Check the parameters */
   1225            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1226          
   1227            htim->State = HAL_TIM_STATE_BUSY;
   1228          
   1229            /* Disable the TIM Peripheral Clock */
   1230            __HAL_TIM_DISABLE(htim);
   1231          
   1232          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1233            if (htim->PWM_MspDeInitCallback == NULL)
   1234            {
   1235              htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
   1236            }
   1237            /* DeInit the low level hardware */
   1238            htim->PWM_MspDeInitCallback(htim);
   1239          #else
   1240            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1241            HAL_TIM_PWM_MspDeInit(htim);
   1242          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1243          
   1244            /* Change TIM state */
   1245            htim->State = HAL_TIM_STATE_RESET;
   1246          
   1247            /* Release Lock */
   1248            __HAL_UNLOCK(htim);
   1249          
   1250            return HAL_OK;
   1251          }
   1252          
   1253          /**
   1254            * @brief  Initializes the TIM PWM MSP.
   1255            * @param  htim TIM PWM handle
   1256            * @retval None
   1257            */
   1258          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1259          {
   1260            /* Prevent unused argument(s) compilation warning */
   1261            UNUSED(htim);
   1262          
   1263            /* NOTE : This function should not be modified, when the callback is needed,
   1264                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1265             */
   1266          }
   1267          
   1268          /**
   1269            * @brief  DeInitializes TIM PWM MSP.
   1270            * @param  htim TIM PWM handle
   1271            * @retval None
   1272            */
   1273          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1274          {
   1275            /* Prevent unused argument(s) compilation warning */
   1276            UNUSED(htim);
   1277          
   1278            /* NOTE : This function should not be modified, when the callback is needed,
   1279                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1280             */
   1281          }
   1282          
   1283          /**
   1284            * @brief  Starts the PWM signal generation.
   1285            * @param  htim TIM handle
   1286            * @param  Channel TIM Channels to be enabled
   1287            *          This parameter can be one of the following values:
   1288            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1289            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1290            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1291            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1292            * @retval HAL status
   1293            */
   1294          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1295          {
   1296            uint32_t tmpsmcr;
   1297          
   1298            /* Check the parameters */
   1299            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1300          
   1301            /* Enable the Capture compare channel */
   1302            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1303          
   1304            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1305            {
   1306              /* Enable the main output */
   1307              __HAL_TIM_MOE_ENABLE(htim);
   1308            }
   1309          
   1310            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1311            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1312            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1313            {
   1314              __HAL_TIM_ENABLE(htim);
   1315            }
   1316          
   1317            /* Return function status */
   1318            return HAL_OK;
   1319          }
   1320          
   1321          /**
   1322            * @brief  Stops the PWM signal generation.
   1323            * @param  htim TIM PWM handle
   1324            * @param  Channel TIM Channels to be disabled
   1325            *          This parameter can be one of the following values:
   1326            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1327            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1328            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1329            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1330            * @retval HAL status
   1331            */
   1332          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1333          {
   1334            /* Check the parameters */
   1335            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1336          
   1337            /* Disable the Capture compare channel */
   1338            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1339          
   1340            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1341            {
   1342              /* Disable the Main Output */
   1343              __HAL_TIM_MOE_DISABLE(htim);
   1344            }
   1345          
   1346            /* Disable the Peripheral */
   1347            __HAL_TIM_DISABLE(htim);
   1348          
   1349            /* Change the htim state */
   1350            htim->State = HAL_TIM_STATE_READY;
   1351          
   1352            /* Return function status */
   1353            return HAL_OK;
   1354          }
   1355          
   1356          /**
   1357            * @brief  Starts the PWM signal generation in interrupt mode.
   1358            * @param  htim TIM PWM handle
   1359            * @param  Channel TIM Channel to be enabled
   1360            *          This parameter can be one of the following values:
   1361            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1362            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1363            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1364            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1365            * @retval HAL status
   1366            */
   1367          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1368          {
   1369            uint32_t tmpsmcr;
   1370            /* Check the parameters */
   1371            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1372          
   1373            switch (Channel)
   1374            {
   1375              case TIM_CHANNEL_1:
   1376              {
   1377                /* Enable the TIM Capture/Compare 1 interrupt */
   1378                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1379                break;
   1380              }
   1381          
   1382              case TIM_CHANNEL_2:
   1383              {
   1384                /* Enable the TIM Capture/Compare 2 interrupt */
   1385                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1386                break;
   1387              }
   1388          
   1389              case TIM_CHANNEL_3:
   1390              {
   1391                /* Enable the TIM Capture/Compare 3 interrupt */
   1392                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1393                break;
   1394              }
   1395          
   1396              case TIM_CHANNEL_4:
   1397              {
   1398                /* Enable the TIM Capture/Compare 4 interrupt */
   1399                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1400                break;
   1401              }
   1402          
   1403              default:
   1404                break;
   1405            }
   1406          
   1407            /* Enable the Capture compare channel */
   1408            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1409          
   1410            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1411            {
   1412              /* Enable the main output */
   1413              __HAL_TIM_MOE_ENABLE(htim);
   1414            }
   1415          
   1416            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1417            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1418            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1419            {
   1420              __HAL_TIM_ENABLE(htim);
   1421            }
   1422          
   1423            /* Return function status */
   1424            return HAL_OK;
   1425          }
   1426          
   1427          /**
   1428            * @brief  Stops the PWM signal generation in interrupt mode.
   1429            * @param  htim TIM PWM handle
   1430            * @param  Channel TIM Channels to be disabled
   1431            *          This parameter can be one of the following values:
   1432            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1433            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1434            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1435            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1436            * @retval HAL status
   1437            */
   1438          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1439          {
   1440            /* Check the parameters */
   1441            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1442          
   1443            switch (Channel)
   1444            {
   1445              case TIM_CHANNEL_1:
   1446              {
   1447                /* Disable the TIM Capture/Compare 1 interrupt */
   1448                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1449                break;
   1450              }
   1451          
   1452              case TIM_CHANNEL_2:
   1453              {
   1454                /* Disable the TIM Capture/Compare 2 interrupt */
   1455                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1456                break;
   1457              }
   1458          
   1459              case TIM_CHANNEL_3:
   1460              {
   1461                /* Disable the TIM Capture/Compare 3 interrupt */
   1462                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1463                break;
   1464              }
   1465          
   1466              case TIM_CHANNEL_4:
   1467              {
   1468                /* Disable the TIM Capture/Compare 4 interrupt */
   1469                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1470                break;
   1471              }
   1472          
   1473              default:
   1474                break;
   1475            }
   1476          
   1477            /* Disable the Capture compare channel */
   1478            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1479          
   1480            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1481            {
   1482              /* Disable the Main Output */
   1483              __HAL_TIM_MOE_DISABLE(htim);
   1484            }
   1485          
   1486            /* Disable the Peripheral */
   1487            __HAL_TIM_DISABLE(htim);
   1488          
   1489            /* Return function status */
   1490            return HAL_OK;
   1491          }
   1492          
   1493          /**
   1494            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1495            * @param  htim TIM PWM handle
   1496            * @param  Channel TIM Channels to be enabled
   1497            *          This parameter can be one of the following values:
   1498            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1499            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1500            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1501            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1502            * @param  pData The source Buffer address.
   1503            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1504            * @retval HAL status
   1505            */
   1506          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1507          {
   1508            uint32_t tmpsmcr;
   1509          
   1510            /* Check the parameters */
   1511            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1512          
   1513            if (htim->State == HAL_TIM_STATE_BUSY)
   1514            {
   1515              return HAL_BUSY;
   1516            }
   1517            else if (htim->State == HAL_TIM_STATE_READY)
   1518            {
   1519              if ((pData == NULL) && (Length > 0U))
   1520              {
   1521                return HAL_ERROR;
   1522              }
   1523              else
   1524              {
   1525                htim->State = HAL_TIM_STATE_BUSY;
   1526              }
   1527            }
   1528            else
   1529            {
   1530              /* nothing to do */
   1531            }
   1532          
   1533            switch (Channel)
   1534            {
   1535              case TIM_CHANNEL_1:
   1536              {
   1537                /* Set the DMA compare callbacks */
   1538                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1539                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1540          
   1541                /* Set the DMA error callback */
   1542                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   1543          
   1544                /* Enable the DMA stream */
   1545                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   1546                {
   1547                  return HAL_ERROR;
   1548                }
   1549          
   1550                /* Enable the TIM Capture/Compare 1 DMA request */
   1551                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1552                break;
   1553              }
   1554          
   1555              case TIM_CHANNEL_2:
   1556              {
   1557                /* Set the DMA compare callbacks */
   1558                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1559                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1560          
   1561                /* Set the DMA error callback */
   1562                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   1563          
   1564                /* Enable the DMA stream */
   1565                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   1566                {
   1567                  return HAL_ERROR;
   1568                }
   1569                /* Enable the TIM Capture/Compare 2 DMA request */
   1570                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1571                break;
   1572              }
   1573          
   1574              case TIM_CHANNEL_3:
   1575              {
   1576                /* Set the DMA compare callbacks */
   1577                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1578                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1579          
   1580                /* Set the DMA error callback */
   1581                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1582          
   1583                /* Enable the DMA stream */
   1584                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   1585                {
   1586                  return HAL_ERROR;
   1587                }
   1588                /* Enable the TIM Output Capture/Compare 3 request */
   1589                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1590                break;
   1591              }
   1592          
   1593              case TIM_CHANNEL_4:
   1594              {
   1595                /* Set the DMA compare callbacks */
   1596                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1597                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1598          
   1599                /* Set the DMA error callback */
   1600                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1601          
   1602                /* Enable the DMA stream */
   1603                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   1604                {
   1605                  return HAL_ERROR;
   1606                }
   1607                /* Enable the TIM Capture/Compare 4 DMA request */
   1608                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1609                break;
   1610              }
   1611          
   1612              default:
   1613                break;
   1614            }
   1615          
   1616            /* Enable the Capture compare channel */
   1617            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1618          
   1619            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1620            {
   1621              /* Enable the main output */
   1622              __HAL_TIM_MOE_ENABLE(htim);
   1623            }
   1624          
   1625            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1626            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1627            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1628            {
   1629              __HAL_TIM_ENABLE(htim);
   1630            }
   1631          
   1632            /* Return function status */
   1633            return HAL_OK;
   1634          }
   1635          
   1636          /**
   1637            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1638            * @param  htim TIM PWM handle
   1639            * @param  Channel TIM Channels to be disabled
   1640            *          This parameter can be one of the following values:
   1641            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1642            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1643            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1644            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1645            * @retval HAL status
   1646            */
   1647          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1648          {
   1649            /* Check the parameters */
   1650            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1651          
   1652            switch (Channel)
   1653            {
   1654              case TIM_CHANNEL_1:
   1655              {
   1656                /* Disable the TIM Capture/Compare 1 DMA request */
   1657                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1658                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   1659                break;
   1660              }
   1661          
   1662              case TIM_CHANNEL_2:
   1663              {
   1664                /* Disable the TIM Capture/Compare 2 DMA request */
   1665                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1666                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   1667                break;
   1668              }
   1669          
   1670              case TIM_CHANNEL_3:
   1671              {
   1672                /* Disable the TIM Capture/Compare 3 DMA request */
   1673                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1674                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   1675                break;
   1676              }
   1677          
   1678              case TIM_CHANNEL_4:
   1679              {
   1680                /* Disable the TIM Capture/Compare 4 interrupt */
   1681                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1682                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   1683                break;
   1684              }
   1685          
   1686              default:
   1687                break;
   1688            }
   1689          
   1690            /* Disable the Capture compare channel */
   1691            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1692          
   1693            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1694            {
   1695              /* Disable the Main Output */
   1696              __HAL_TIM_MOE_DISABLE(htim);
   1697            }
   1698          
   1699            /* Disable the Peripheral */
   1700            __HAL_TIM_DISABLE(htim);
   1701          
   1702            /* Change the htim state */
   1703            htim->State = HAL_TIM_STATE_READY;
   1704          
   1705            /* Return function status */
   1706            return HAL_OK;
   1707          }
   1708          
   1709          /**
   1710            * @}
   1711            */
   1712          
   1713          /** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions
   1714            *  @brief    TIM Input Capture functions
   1715            *
   1716          @verbatim
   1717            ==============================================================================
   1718                        ##### TIM Input Capture functions #####
   1719            ==============================================================================
   1720           [..]
   1721             This section provides functions allowing to:
   1722             (+) Initialize and configure the TIM Input Capture.
   1723             (+) De-initialize the TIM Input Capture.
   1724             (+) Start the TIM Input Capture.
   1725             (+) Stop the TIM Input Capture.
   1726             (+) Start the TIM Input Capture and enable interrupt.
   1727             (+) Stop the TIM Input Capture and disable interrupt.
   1728             (+) Start the TIM Input Capture and enable DMA transfer.
   1729             (+) Stop the TIM Input Capture and disable DMA transfer.
   1730          
   1731          @endverbatim
   1732            * @{
   1733            */
   1734          /**
   1735            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1736            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1737            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1738            *         requires a timer reset to avoid unexpected direction
   1739            *         due to DIR bit readonly in center aligned mode.
   1740            *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
   1741            * @param  htim TIM Input Capture handle
   1742            * @retval HAL status
   1743            */
   1744          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1745          {
   1746            /* Check the TIM handle allocation */
   1747            if (htim == NULL)
   1748            {
   1749              return HAL_ERROR;
   1750            }
   1751          
   1752            /* Check the parameters */
   1753            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1754            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1755            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1756            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1757          
   1758            if (htim->State == HAL_TIM_STATE_RESET)
   1759            {
   1760              /* Allocate lock resource and initialize it */
   1761              htim->Lock = HAL_UNLOCKED;
   1762          
   1763          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1764              /* Reset interrupt callbacks to legacy weak callbacks */
   1765              TIM_ResetCallback(htim);
   1766          
   1767              if (htim->IC_MspInitCallback == NULL)
   1768              {
   1769                htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
   1770              }
   1771              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1772              htim->IC_MspInitCallback(htim);
   1773          #else
   1774              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1775              HAL_TIM_IC_MspInit(htim);
   1776          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1777            }
   1778          
   1779            /* Set the TIM state */
   1780            htim->State = HAL_TIM_STATE_BUSY;
   1781          
   1782            /* Init the base time for the input capture */
   1783            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   1784          
   1785            /* Initialize the TIM state*/
   1786            htim->State = HAL_TIM_STATE_READY;
   1787          
   1788            return HAL_OK;
   1789          }
   1790          
   1791          /**
   1792            * @brief  DeInitializes the TIM peripheral
   1793            * @param  htim TIM Input Capture handle
   1794            * @retval HAL status
   1795            */
   1796          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1797          {
   1798            /* Check the parameters */
   1799            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1800          
   1801            htim->State = HAL_TIM_STATE_BUSY;
   1802          
   1803            /* Disable the TIM Peripheral Clock */
   1804            __HAL_TIM_DISABLE(htim);
   1805          
   1806          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1807            if (htim->IC_MspDeInitCallback == NULL)
   1808            {
   1809              htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
   1810            }
   1811            /* DeInit the low level hardware */
   1812            htim->IC_MspDeInitCallback(htim);
   1813          #else
   1814            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1815            HAL_TIM_IC_MspDeInit(htim);
   1816          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1817          
   1818            /* Change TIM state */
   1819            htim->State = HAL_TIM_STATE_RESET;
   1820          
   1821            /* Release Lock */
   1822            __HAL_UNLOCK(htim);
   1823          
   1824            return HAL_OK;
   1825          }
   1826          
   1827          /**
   1828            * @brief  Initializes the TIM Input Capture MSP.
   1829            * @param  htim TIM Input Capture handle
   1830            * @retval None
   1831            */
   1832          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1833          {
   1834            /* Prevent unused argument(s) compilation warning */
   1835            UNUSED(htim);
   1836          
   1837            /* NOTE : This function should not be modified, when the callback is needed,
   1838                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1839             */
   1840          }
   1841          
   1842          /**
   1843            * @brief  DeInitializes TIM Input Capture MSP.
   1844            * @param  htim TIM handle
   1845            * @retval None
   1846            */
   1847          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1848          {
   1849            /* Prevent unused argument(s) compilation warning */
   1850            UNUSED(htim);
   1851          
   1852            /* NOTE : This function should not be modified, when the callback is needed,
   1853                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1854             */
   1855          }
   1856          
   1857          /**
   1858            * @brief  Starts the TIM Input Capture measurement.
   1859            * @param  htim TIM Input Capture handle
   1860            * @param  Channel TIM Channels to be enabled
   1861            *          This parameter can be one of the following values:
   1862            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1863            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1864            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1865            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1866            * @retval HAL status
   1867            */
   1868          HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1869          {
   1870            uint32_t tmpsmcr;
   1871          
   1872            /* Check the parameters */
   1873            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1874          
   1875            /* Enable the Input Capture channel */
   1876            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1877          
   1878            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1879            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1880            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1881            {
   1882              __HAL_TIM_ENABLE(htim);
   1883            }
   1884          
   1885            /* Return function status */
   1886            return HAL_OK;
   1887          }
   1888          
   1889          /**
   1890            * @brief  Stops the TIM Input Capture measurement.
   1891            * @param  htim TIM Input Capture handle
   1892            * @param  Channel TIM Channels to be disabled
   1893            *          This parameter can be one of the following values:
   1894            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1895            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1896            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1897            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1898            * @retval HAL status
   1899            */
   1900          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1901          {
   1902            /* Check the parameters */
   1903            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1904          
   1905            /* Disable the Input Capture channel */
   1906            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1907          
   1908            /* Disable the Peripheral */
   1909            __HAL_TIM_DISABLE(htim);
   1910          
   1911            /* Return function status */
   1912            return HAL_OK;
   1913          }
   1914          
   1915          /**
   1916            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1917            * @param  htim TIM Input Capture handle
   1918            * @param  Channel TIM Channels to be enabled
   1919            *          This parameter can be one of the following values:
   1920            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1921            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1922            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1923            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1924            * @retval HAL status
   1925            */
   1926          HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1927          {
   1928            uint32_t tmpsmcr;
   1929          
   1930            /* Check the parameters */
   1931            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1932          
   1933            switch (Channel)
   1934            {
   1935              case TIM_CHANNEL_1:
   1936              {
   1937                /* Enable the TIM Capture/Compare 1 interrupt */
   1938                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1939                break;
   1940              }
   1941          
   1942              case TIM_CHANNEL_2:
   1943              {
   1944                /* Enable the TIM Capture/Compare 2 interrupt */
   1945                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1946                break;
   1947              }
   1948          
   1949              case TIM_CHANNEL_3:
   1950              {
   1951                /* Enable the TIM Capture/Compare 3 interrupt */
   1952                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1953                break;
   1954              }
   1955          
   1956              case TIM_CHANNEL_4:
   1957              {
   1958                /* Enable the TIM Capture/Compare 4 interrupt */
   1959                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1960                break;
   1961              }
   1962          
   1963              default:
   1964                break;
   1965            }
   1966            /* Enable the Input Capture channel */
   1967            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1968          
   1969            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1970            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1971            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1972            {
   1973              __HAL_TIM_ENABLE(htim);
   1974            }
   1975          
   1976            /* Return function status */
   1977            return HAL_OK;
   1978          }
   1979          
   1980          /**
   1981            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1982            * @param  htim TIM Input Capture handle
   1983            * @param  Channel TIM Channels to be disabled
   1984            *          This parameter can be one of the following values:
   1985            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1986            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1987            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1988            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1989            * @retval HAL status
   1990            */
   1991          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1992          {
   1993            /* Check the parameters */
   1994            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1995          
   1996            switch (Channel)
   1997            {
   1998              case TIM_CHANNEL_1:
   1999              {
   2000                /* Disable the TIM Capture/Compare 1 interrupt */
   2001                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2002                break;
   2003              }
   2004          
   2005              case TIM_CHANNEL_2:
   2006              {
   2007                /* Disable the TIM Capture/Compare 2 interrupt */
   2008                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2009                break;
   2010              }
   2011          
   2012              case TIM_CHANNEL_3:
   2013              {
   2014                /* Disable the TIM Capture/Compare 3 interrupt */
   2015                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   2016                break;
   2017              }
   2018          
   2019              case TIM_CHANNEL_4:
   2020              {
   2021                /* Disable the TIM Capture/Compare 4 interrupt */
   2022                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   2023                break;
   2024              }
   2025          
   2026              default:
   2027                break;
   2028            }
   2029          
   2030            /* Disable the Input Capture channel */
   2031            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   2032          
   2033            /* Disable the Peripheral */
   2034            __HAL_TIM_DISABLE(htim);
   2035          
   2036            /* Return function status */
   2037            return HAL_OK;
   2038          }
   2039          
   2040          /**
   2041            * @brief  Starts the TIM Input Capture measurement in DMA mode.
   2042            * @param  htim TIM Input Capture handle
   2043            * @param  Channel TIM Channels to be enabled
   2044            *          This parameter can be one of the following values:
   2045            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2046            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2047            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2048            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2049            * @param  pData The destination Buffer address.
   2050            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2051            * @retval HAL status
   2052            */
   2053          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   2054          {
   2055            uint32_t tmpsmcr;
   2056          
   2057            /* Check the parameters */
   2058            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2059            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2060          
   2061            if (htim->State == HAL_TIM_STATE_BUSY)
   2062            {
   2063              return HAL_BUSY;
   2064            }
   2065            else if (htim->State == HAL_TIM_STATE_READY)
   2066            {
   2067              if ((pData == NULL) && (Length > 0U))
   2068              {
   2069                return HAL_ERROR;
   2070              }
   2071              else
   2072              {
   2073                htim->State = HAL_TIM_STATE_BUSY;
   2074              }
   2075            }
   2076            else
   2077            {
   2078              /* nothing to do */
   2079            }
   2080          
   2081            switch (Channel)
   2082            {
   2083              case TIM_CHANNEL_1:
   2084              {
   2085                /* Set the DMA capture callbacks */
   2086                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   2087                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2088          
   2089                /* Set the DMA error callback */
   2090                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   2091          
   2092                /* Enable the DMA stream */
   2093                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
   2094                {
   2095                  return HAL_ERROR;
   2096                }
   2097                /* Enable the TIM Capture/Compare 1 DMA request */
   2098                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   2099                break;
   2100              }
   2101          
   2102              case TIM_CHANNEL_2:
   2103              {
   2104                /* Set the DMA capture callbacks */
   2105                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   2106                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2107          
   2108                /* Set the DMA error callback */
   2109                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   2110          
   2111                /* Enable the DMA stream */
   2112                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length) != HAL_OK)
   2113                {
   2114                  return HAL_ERROR;
   2115                }
   2116                /* Enable the TIM Capture/Compare 2  DMA request */
   2117                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   2118                break;
   2119              }
   2120          
   2121              case TIM_CHANNEL_3:
   2122              {
   2123                /* Set the DMA capture callbacks */
   2124                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   2125                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2126          
   2127                /* Set the DMA error callback */
   2128                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   2129          
   2130                /* Enable the DMA stream */
   2131                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length) != HAL_OK)
   2132                {
   2133                  return HAL_ERROR;
   2134                }
   2135                /* Enable the TIM Capture/Compare 3  DMA request */
   2136                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   2137                break;
   2138              }
   2139          
   2140              case TIM_CHANNEL_4:
   2141              {
   2142                /* Set the DMA capture callbacks */
   2143                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   2144                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2145          
   2146                /* Set the DMA error callback */
   2147                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   2148          
   2149                /* Enable the DMA stream */
   2150                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length) != HAL_OK)
   2151                {
   2152                  return HAL_ERROR;
   2153                }
   2154                /* Enable the TIM Capture/Compare 4  DMA request */
   2155                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   2156                break;
   2157              }
   2158          
   2159              default:
   2160                break;
   2161            }
   2162          
   2163            /* Enable the Input Capture channel */
   2164            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   2165          
   2166            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   2167            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   2168            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   2169            {
   2170              __HAL_TIM_ENABLE(htim);
   2171            }
   2172          
   2173            /* Return function status */
   2174            return HAL_OK;
   2175          }
   2176          
   2177          /**
   2178            * @brief  Stops the TIM Input Capture measurement in DMA mode.
   2179            * @param  htim TIM Input Capture handle
   2180            * @param  Channel TIM Channels to be disabled
   2181            *          This parameter can be one of the following values:
   2182            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2183            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2184            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2185            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2186            * @retval HAL status
   2187            */
   2188          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2189          {
   2190            /* Check the parameters */
   2191            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2192            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2193          
   2194            switch (Channel)
   2195            {
   2196              case TIM_CHANNEL_1:
   2197              {
   2198                /* Disable the TIM Capture/Compare 1 DMA request */
   2199                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   2200                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   2201                break;
   2202              }
   2203          
   2204              case TIM_CHANNEL_2:
   2205              {
   2206                /* Disable the TIM Capture/Compare 2 DMA request */
   2207                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   2208                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   2209                break;
   2210              }
   2211          
   2212              case TIM_CHANNEL_3:
   2213              {
   2214                /* Disable the TIM Capture/Compare 3  DMA request */
   2215                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   2216                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   2217                break;
   2218              }
   2219          
   2220              case TIM_CHANNEL_4:
   2221              {
   2222                /* Disable the TIM Capture/Compare 4  DMA request */
   2223                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   2224                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   2225                break;
   2226              }
   2227          
   2228              default:
   2229                break;
   2230            }
   2231          
   2232            /* Disable the Input Capture channel */
   2233            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   2234          
   2235            /* Disable the Peripheral */
   2236            __HAL_TIM_DISABLE(htim);
   2237          
   2238            /* Change the htim state */
   2239            htim->State = HAL_TIM_STATE_READY;
   2240          
   2241            /* Return function status */
   2242            return HAL_OK;
   2243          }
   2244          /**
   2245            * @}
   2246            */
   2247          
   2248          /** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions
   2249            *  @brief    TIM One Pulse functions
   2250            *
   2251          @verbatim
   2252            ==============================================================================
   2253                                  ##### TIM One Pulse functions #####
   2254            ==============================================================================
   2255            [..]
   2256              This section provides functions allowing to:
   2257              (+) Initialize and configure the TIM One Pulse.
   2258              (+) De-initialize the TIM One Pulse.
   2259              (+) Start the TIM One Pulse.
   2260              (+) Stop the TIM One Pulse.
   2261              (+) Start the TIM One Pulse and enable interrupt.
   2262              (+) Stop the TIM One Pulse and disable interrupt.
   2263              (+) Start the TIM One Pulse and enable DMA transfer.
   2264              (+) Stop the TIM One Pulse and disable DMA transfer.
   2265          
   2266          @endverbatim
   2267            * @{
   2268            */
   2269          /**
   2270            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   2271            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   2272            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2273            *         requires a timer reset to avoid unexpected direction
   2274            *         due to DIR bit readonly in center aligned mode.
   2275            *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()
   2276            * @param  htim TIM One Pulse handle
   2277            * @param  OnePulseMode Select the One pulse mode.
   2278            *         This parameter can be one of the following values:
   2279            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   2280            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   2281            * @retval HAL status
   2282            */
   2283          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   2284          {
   2285            /* Check the TIM handle allocation */
   2286            if (htim == NULL)
   2287            {
   2288              return HAL_ERROR;
   2289            }
   2290          
   2291            /* Check the parameters */
   2292            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2293            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2294            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2295            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   2296            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2297          
   2298            if (htim->State == HAL_TIM_STATE_RESET)
   2299            {
   2300              /* Allocate lock resource and initialize it */
   2301              htim->Lock = HAL_UNLOCKED;
   2302          
   2303          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2304              /* Reset interrupt callbacks to legacy weak callbacks */
   2305              TIM_ResetCallback(htim);
   2306          
   2307              if (htim->OnePulse_MspInitCallback == NULL)
   2308              {
   2309                htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;
   2310              }
   2311              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2312              htim->OnePulse_MspInitCallback(htim);
   2313          #else
   2314              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2315              HAL_TIM_OnePulse_MspInit(htim);
   2316          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2317            }
   2318          
   2319            /* Set the TIM state */
   2320            htim->State = HAL_TIM_STATE_BUSY;
   2321          
   2322            /* Configure the Time base in the One Pulse Mode */
   2323            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   2324          
   2325            /* Reset the OPM Bit */
   2326            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   2327          
   2328            /* Configure the OPM Mode */
   2329            htim->Instance->CR1 |= OnePulseMode;
   2330          
   2331            /* Initialize the TIM state*/
   2332            htim->State = HAL_TIM_STATE_READY;
   2333          
   2334            return HAL_OK;
   2335          }
   2336          
   2337          /**
   2338            * @brief  DeInitializes the TIM One Pulse
   2339            * @param  htim TIM One Pulse handle
   2340            * @retval HAL status
   2341            */
   2342          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2343          {
   2344            /* Check the parameters */
   2345            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2346          
   2347            htim->State = HAL_TIM_STATE_BUSY;
   2348          
   2349            /* Disable the TIM Peripheral Clock */
   2350            __HAL_TIM_DISABLE(htim);
   2351          
   2352          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2353            if (htim->OnePulse_MspDeInitCallback == NULL)
   2354            {
   2355              htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
   2356            }
   2357            /* DeInit the low level hardware */
   2358            htim->OnePulse_MspDeInitCallback(htim);
   2359          #else
   2360            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2361            HAL_TIM_OnePulse_MspDeInit(htim);
   2362          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2363          
   2364            /* Change TIM state */
   2365            htim->State = HAL_TIM_STATE_RESET;
   2366          
   2367            /* Release Lock */
   2368            __HAL_UNLOCK(htim);
   2369          
   2370            return HAL_OK;
   2371          }
   2372          
   2373          /**
   2374            * @brief  Initializes the TIM One Pulse MSP.
   2375            * @param  htim TIM One Pulse handle
   2376            * @retval None
   2377            */
   2378          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2379          {
   2380            /* Prevent unused argument(s) compilation warning */
   2381            UNUSED(htim);
   2382          
   2383            /* NOTE : This function should not be modified, when the callback is needed,
   2384                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2385             */
   2386          }
   2387          
   2388          /**
   2389            * @brief  DeInitializes TIM One Pulse MSP.
   2390            * @param  htim TIM One Pulse handle
   2391            * @retval None
   2392            */
   2393          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2394          {
   2395            /* Prevent unused argument(s) compilation warning */
   2396            UNUSED(htim);
   2397          
   2398            /* NOTE : This function should not be modified, when the callback is needed,
   2399                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2400             */
   2401          }
   2402          
   2403          /**
   2404            * @brief  Starts the TIM One Pulse signal generation.
   2405            * @param  htim TIM One Pulse handle
   2406            * @param  OutputChannel TIM Channels to be enabled
   2407            *          This parameter can be one of the following values:
   2408            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2409            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2410            * @retval HAL status
   2411            */
   2412          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2413          {
   2414            /* Prevent unused argument(s) compilation warning */
   2415            UNUSED(OutputChannel);
   2416          
   2417            /* Enable the Capture compare and the Input Capture channels
   2418              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2419              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2420              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2421              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2422          
   2423              No need to enable the counter, it's enabled automatically by hardware
   2424              (the counter starts in response to a stimulus and generate a pulse */
   2425          
   2426            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2427            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2428          
   2429            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2430            {
   2431              /* Enable the main output */
   2432              __HAL_TIM_MOE_ENABLE(htim);
   2433            }
   2434          
   2435            /* Return function status */
   2436            return HAL_OK;
   2437          }
   2438          
   2439          /**
   2440            * @brief  Stops the TIM One Pulse signal generation.
   2441            * @param  htim TIM One Pulse handle
   2442            * @param  OutputChannel TIM Channels to be disable
   2443            *          This parameter can be one of the following values:
   2444            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2445            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2446            * @retval HAL status
   2447            */
   2448          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2449          {
   2450            /* Prevent unused argument(s) compilation warning */
   2451            UNUSED(OutputChannel);
   2452          
   2453            /* Disable the Capture compare and the Input Capture channels
   2454            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2455            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2456            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2457            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2458          
   2459            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2460            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2461          
   2462            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2463            {
   2464              /* Disable the Main Output */
   2465              __HAL_TIM_MOE_DISABLE(htim);
   2466            }
   2467          
   2468            /* Disable the Peripheral */
   2469            __HAL_TIM_DISABLE(htim);
   2470          
   2471            /* Return function status */
   2472            return HAL_OK;
   2473          }
   2474          
   2475          /**
   2476            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2477            * @param  htim TIM One Pulse handle
   2478            * @param  OutputChannel TIM Channels to be enabled
   2479            *          This parameter can be one of the following values:
   2480            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2481            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2482            * @retval HAL status
   2483            */
   2484          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2485          {
   2486            /* Prevent unused argument(s) compilation warning */
   2487            UNUSED(OutputChannel);
   2488          
   2489            /* Enable the Capture compare and the Input Capture channels
   2490              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2491              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2492              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2493              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2494          
   2495              No need to enable the counter, it's enabled automatically by hardware
   2496              (the counter starts in response to a stimulus and generate a pulse */
   2497          
   2498            /* Enable the TIM Capture/Compare 1 interrupt */
   2499            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2500          
   2501            /* Enable the TIM Capture/Compare 2 interrupt */
   2502            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2503          
   2504            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2505            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2506          
   2507            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2508            {
   2509              /* Enable the main output */
   2510              __HAL_TIM_MOE_ENABLE(htim);
   2511            }
   2512          
   2513            /* Return function status */
   2514            return HAL_OK;
   2515          }
   2516          
   2517          /**
   2518            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2519            * @param  htim TIM One Pulse handle
   2520            * @param  OutputChannel TIM Channels to be enabled
   2521            *          This parameter can be one of the following values:
   2522            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2523            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2524            * @retval HAL status
   2525            */
   2526          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2527          {
   2528            /* Prevent unused argument(s) compilation warning */
   2529            UNUSED(OutputChannel);
   2530          
   2531            /* Disable the TIM Capture/Compare 1 interrupt */
   2532            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2533          
   2534            /* Disable the TIM Capture/Compare 2 interrupt */
   2535            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2536          
   2537            /* Disable the Capture compare and the Input Capture channels
   2538            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2539            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2540            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2541            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2542            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2543            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2544          
   2545            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2546            {
   2547              /* Disable the Main Output */
   2548              __HAL_TIM_MOE_DISABLE(htim);
   2549            }
   2550          
   2551            /* Disable the Peripheral */
   2552            __HAL_TIM_DISABLE(htim);
   2553          
   2554            /* Return function status */
   2555            return HAL_OK;
   2556          }
   2557          
   2558          /**
   2559            * @}
   2560            */
   2561          
   2562          /** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions
   2563            *  @brief    TIM Encoder functions
   2564            *
   2565          @verbatim
   2566            ==============================================================================
   2567                                    ##### TIM Encoder functions #####
   2568            ==============================================================================
   2569            [..]
   2570              This section provides functions allowing to:
   2571              (+) Initialize and configure the TIM Encoder.
   2572              (+) De-initialize the TIM Encoder.
   2573              (+) Start the TIM Encoder.
   2574              (+) Stop the TIM Encoder.
   2575              (+) Start the TIM Encoder and enable interrupt.
   2576              (+) Stop the TIM Encoder and disable interrupt.
   2577              (+) Start the TIM Encoder and enable DMA transfer.
   2578              (+) Stop the TIM Encoder and disable DMA transfer.
   2579          
   2580          @endverbatim
   2581            * @{
   2582            */
   2583          /**
   2584            * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.
   2585            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2586            *         requires a timer reset to avoid unexpected direction
   2587            *         due to DIR bit readonly in center aligned mode.
   2588            *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
   2589            * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together
   2590            *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource
   2591            *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa
   2592            * @param  htim TIM Encoder Interface handle
   2593            * @param  sConfig TIM Encoder Interface configuration structure
   2594            * @retval HAL status
   2595            */
   2596          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)
   2597          {
   2598            uint32_t tmpsmcr;
   2599            uint32_t tmpccmr1;
   2600            uint32_t tmpccer;
   2601          
   2602            /* Check the TIM handle allocation */
   2603            if (htim == NULL)
   2604            {
   2605              return HAL_ERROR;
   2606            }
   2607          
   2608            /* Check the parameters */
   2609            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2610            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2611            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2612            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2613            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2614            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2615            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2616            assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC1Polarity));
   2617            assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC2Polarity));
   2618            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2619            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2620            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2621            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2622          
   2623            if (htim->State == HAL_TIM_STATE_RESET)
   2624            {
   2625              /* Allocate lock resource and initialize it */
   2626              htim->Lock = HAL_UNLOCKED;
   2627          
   2628          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2629              /* Reset interrupt callbacks to legacy weak callbacks */
   2630              TIM_ResetCallback(htim);
   2631          
   2632              if (htim->Encoder_MspInitCallback == NULL)
   2633              {
   2634                htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
   2635              }
   2636              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2637              htim->Encoder_MspInitCallback(htim);
   2638          #else
   2639              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2640              HAL_TIM_Encoder_MspInit(htim);
   2641          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2642            }
   2643          
   2644            /* Set the TIM state */
   2645            htim->State = HAL_TIM_STATE_BUSY;
   2646          
   2647            /* Reset the SMS and ECE bits */
   2648            htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
   2649          
   2650            /* Configure the Time base in the Encoder Mode */
   2651            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   2652          
   2653            /* Get the TIMx SMCR register value */
   2654            tmpsmcr = htim->Instance->SMCR;
   2655          
   2656            /* Get the TIMx CCMR1 register value */
   2657            tmpccmr1 = htim->Instance->CCMR1;
   2658          
   2659            /* Get the TIMx CCER register value */
   2660            tmpccer = htim->Instance->CCER;
   2661          
   2662            /* Set the encoder Mode */
   2663            tmpsmcr |= sConfig->EncoderMode;
   2664          
   2665            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2666            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   2667            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
   2668          
   2669            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2670            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   2671            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   2672            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
   2673            tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
   2674          
   2675            /* Set the TI1 and the TI2 Polarities */
   2676            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   2677            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   2678            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
   2679          
   2680            /* Write to TIMx SMCR */
   2681            htim->Instance->SMCR = tmpsmcr;
   2682          
   2683            /* Write to TIMx CCMR1 */
   2684            htim->Instance->CCMR1 = tmpccmr1;
   2685          
   2686            /* Write to TIMx CCER */
   2687            htim->Instance->CCER = tmpccer;
   2688          
   2689            /* Initialize the TIM state*/
   2690            htim->State = HAL_TIM_STATE_READY;
   2691          
   2692            return HAL_OK;
   2693          }
   2694          
   2695          
   2696          /**
   2697            * @brief  DeInitializes the TIM Encoder interface
   2698            * @param  htim TIM Encoder Interface handle
   2699            * @retval HAL status
   2700            */
   2701          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2702          {
   2703            /* Check the parameters */
   2704            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2705          
   2706            htim->State = HAL_TIM_STATE_BUSY;
   2707          
   2708            /* Disable the TIM Peripheral Clock */
   2709            __HAL_TIM_DISABLE(htim);
   2710          
   2711          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2712            if (htim->Encoder_MspDeInitCallback == NULL)
   2713            {
   2714              htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
   2715            }
   2716            /* DeInit the low level hardware */
   2717            htim->Encoder_MspDeInitCallback(htim);
   2718          #else
   2719            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2720            HAL_TIM_Encoder_MspDeInit(htim);
   2721          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2722          
   2723            /* Change TIM state */
   2724            htim->State = HAL_TIM_STATE_RESET;
   2725          
   2726            /* Release Lock */
   2727            __HAL_UNLOCK(htim);
   2728          
   2729            return HAL_OK;
   2730          }
   2731          
   2732          /**
   2733            * @brief  Initializes the TIM Encoder Interface MSP.
   2734            * @param  htim TIM Encoder Interface handle
   2735            * @retval None
   2736            */
   2737          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2738          {
   2739            /* Prevent unused argument(s) compilation warning */
   2740            UNUSED(htim);
   2741          
   2742            /* NOTE : This function should not be modified, when the callback is needed,
   2743                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2744             */
   2745          }
   2746          
   2747          /**
   2748            * @brief  DeInitializes TIM Encoder Interface MSP.
   2749            * @param  htim TIM Encoder Interface handle
   2750            * @retval None
   2751            */
   2752          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2753          {
   2754            /* Prevent unused argument(s) compilation warning */
   2755            UNUSED(htim);
   2756          
   2757            /* NOTE : This function should not be modified, when the callback is needed,
   2758                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2759             */
   2760          }
   2761          
   2762          /**
   2763            * @brief  Starts the TIM Encoder Interface.
   2764            * @param  htim TIM Encoder Interface handle
   2765            * @param  Channel TIM Channels to be enabled
   2766            *          This parameter can be one of the following values:
   2767            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2768            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2769            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2770            * @retval HAL status
   2771            */
   2772          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2773          {
   2774            /* Check the parameters */
   2775            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2776          
   2777            /* Enable the encoder interface channels */
   2778            switch (Channel)
   2779            {
   2780              case TIM_CHANNEL_1:
   2781              {
   2782                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2783                break;
   2784              }
   2785          
   2786              case TIM_CHANNEL_2:
   2787              {
   2788                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2789                break;
   2790              }
   2791          
   2792              default :
   2793              {
   2794                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2795                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2796                break;
   2797              }
   2798            }
   2799            /* Enable the Peripheral */
   2800            __HAL_TIM_ENABLE(htim);
   2801          
   2802            /* Return function status */
   2803            return HAL_OK;
   2804          }
   2805          
   2806          /**
   2807            * @brief  Stops the TIM Encoder Interface.
   2808            * @param  htim TIM Encoder Interface handle
   2809            * @param  Channel TIM Channels to be disabled
   2810            *          This parameter can be one of the following values:
   2811            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2812            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2813            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2814            * @retval HAL status
   2815            */
   2816          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2817          {
   2818            /* Check the parameters */
   2819            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2820          
   2821            /* Disable the Input Capture channels 1 and 2
   2822              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2823            switch (Channel)
   2824            {
   2825              case TIM_CHANNEL_1:
   2826              {
   2827                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2828                break;
   2829              }
   2830          
   2831              case TIM_CHANNEL_2:
   2832              {
   2833                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2834                break;
   2835              }
   2836          
   2837              default :
   2838              {
   2839                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2840                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2841                break;
   2842              }
   2843            }
   2844          
   2845            /* Disable the Peripheral */
   2846            __HAL_TIM_DISABLE(htim);
   2847          
   2848            /* Return function status */
   2849            return HAL_OK;
   2850          }
   2851          
   2852          /**
   2853            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2854            * @param  htim TIM Encoder Interface handle
   2855            * @param  Channel TIM Channels to be enabled
   2856            *          This parameter can be one of the following values:
   2857            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2858            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2859            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2860            * @retval HAL status
   2861            */
   2862          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2863          {
   2864            /* Check the parameters */
   2865            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2866          
   2867            /* Enable the encoder interface channels */
   2868            /* Enable the capture compare Interrupts 1 and/or 2 */
   2869            switch (Channel)
   2870            {
   2871              case TIM_CHANNEL_1:
   2872              {
   2873                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2874                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2875                break;
   2876              }
   2877          
   2878              case TIM_CHANNEL_2:
   2879              {
   2880                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2881                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2882                break;
   2883              }
   2884          
   2885              default :
   2886              {
   2887                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2888                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2889                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2890                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2891                break;
   2892              }
   2893            }
   2894          
   2895            /* Enable the Peripheral */
   2896            __HAL_TIM_ENABLE(htim);
   2897          
   2898            /* Return function status */
   2899            return HAL_OK;
   2900          }
   2901          
   2902          /**
   2903            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2904            * @param  htim TIM Encoder Interface handle
   2905            * @param  Channel TIM Channels to be disabled
   2906            *          This parameter can be one of the following values:
   2907            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2908            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2909            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2910            * @retval HAL status
   2911            */
   2912          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2913          {
   2914            /* Check the parameters */
   2915            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2916          
   2917            /* Disable the Input Capture channels 1 and 2
   2918              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2919            if (Channel == TIM_CHANNEL_1)
   2920            {
   2921              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2922          
   2923              /* Disable the capture compare Interrupts 1 */
   2924              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2925            }
   2926            else if (Channel == TIM_CHANNEL_2)
   2927            {
   2928              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2929          
   2930              /* Disable the capture compare Interrupts 2 */
   2931              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2932            }
   2933            else
   2934            {
   2935              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2936              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2937          
   2938              /* Disable the capture compare Interrupts 1 and 2 */
   2939              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2940              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2941            }
   2942          
   2943            /* Disable the Peripheral */
   2944            __HAL_TIM_DISABLE(htim);
   2945          
   2946            /* Change the htim state */
   2947            htim->State = HAL_TIM_STATE_READY;
   2948          
   2949            /* Return function status */
   2950            return HAL_OK;
   2951          }
   2952          
   2953          /**
   2954            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2955            * @param  htim TIM Encoder Interface handle
   2956            * @param  Channel TIM Channels to be enabled
   2957            *          This parameter can be one of the following values:
   2958            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2959            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2960            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2961            * @param  pData1 The destination Buffer address for IC1.
   2962            * @param  pData2 The destination Buffer address for IC2.
   2963            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2964            * @retval HAL status
   2965            */
   2966          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,
   2967                                                      uint32_t *pData2, uint16_t Length)
   2968          {
   2969            /* Check the parameters */
   2970            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2971          
   2972            if (htim->State == HAL_TIM_STATE_BUSY)
   2973            {
   2974              return HAL_BUSY;
   2975            }
   2976            else if (htim->State == HAL_TIM_STATE_READY)
   2977            {
   2978              if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
   2979              {
   2980                return HAL_ERROR;
   2981              }
   2982              else
   2983              {
   2984                htim->State = HAL_TIM_STATE_BUSY;
   2985              }
   2986            }
   2987            else
   2988            {
   2989              /* nothing to do */
   2990            }
   2991          
   2992            switch (Channel)
   2993            {
   2994              case TIM_CHANNEL_1:
   2995              {
   2996                /* Set the DMA capture callbacks */
   2997                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   2998                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2999          
   3000                /* Set the DMA error callback */
   3001                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3002          
   3003                /* Enable the DMA stream */
   3004                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   3005                {
   3006                  return HAL_ERROR;
   3007                }
   3008                /* Enable the TIM Input Capture DMA request */
   3009                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   3010          
   3011                /* Enable the Peripheral */
   3012                __HAL_TIM_ENABLE(htim);
   3013          
   3014                /* Enable the Capture compare channel */
   3015                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   3016                break;
   3017              }
   3018          
   3019              case TIM_CHANNEL_2:
   3020              {
   3021                /* Set the DMA capture callbacks */
   3022                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   3023                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3024          
   3025                /* Set the DMA error callback */
   3026                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   3027                /* Enable the DMA stream */
   3028                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   3029                {
   3030                  return HAL_ERROR;
   3031                }
   3032                /* Enable the TIM Input Capture  DMA request */
   3033                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   3034          
   3035                /* Enable the Peripheral */
   3036                __HAL_TIM_ENABLE(htim);
   3037          
   3038                /* Enable the Capture compare channel */
   3039                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   3040                break;
   3041              }
   3042          
   3043              case TIM_CHANNEL_ALL:
   3044              {
   3045                /* Set the DMA capture callbacks */
   3046                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   3047                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3048          
   3049                /* Set the DMA error callback */
   3050                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3051          
   3052                /* Enable the DMA stream */
   3053                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   3054                {
   3055                  return HAL_ERROR;
   3056                }
   3057          
   3058                /* Set the DMA capture callbacks */
   3059                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   3060                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3061          
   3062                /* Set the DMA error callback */
   3063                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3064          
   3065                /* Enable the DMA stream */
   3066                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   3067                {
   3068                  return HAL_ERROR;
   3069                }
   3070                /* Enable the Peripheral */
   3071                __HAL_TIM_ENABLE(htim);
   3072          
   3073                /* Enable the Capture compare channel */
   3074                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   3075                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   3076          
   3077                /* Enable the TIM Input Capture  DMA request */
   3078                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   3079                /* Enable the TIM Input Capture  DMA request */
   3080                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   3081                break;
   3082              }
   3083          
   3084              default:
   3085                break;
   3086            }
   3087            /* Return function status */
   3088            return HAL_OK;
   3089          }
   3090          
   3091          /**
   3092            * @brief  Stops the TIM Encoder Interface in DMA mode.
   3093            * @param  htim TIM Encoder Interface handle
   3094            * @param  Channel TIM Channels to be enabled
   3095            *          This parameter can be one of the following values:
   3096            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3097            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3098            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3099            * @retval HAL status
   3100            */
   3101          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   3102          {
   3103            /* Check the parameters */
   3104            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   3105          
   3106            /* Disable the Input Capture channels 1 and 2
   3107              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   3108            if (Channel == TIM_CHANNEL_1)
   3109            {
   3110              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   3111          
   3112              /* Disable the capture compare DMA Request 1 */
   3113              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   3114              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   3115            }
   3116            else if (Channel == TIM_CHANNEL_2)
   3117            {
   3118              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   3119          
   3120              /* Disable the capture compare DMA Request 2 */
   3121              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   3122              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   3123            }
   3124            else
   3125            {
   3126              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   3127              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   3128          
   3129              /* Disable the capture compare DMA Request 1 and 2 */
   3130              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   3131              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   3132              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   3133              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   3134            }
   3135          
   3136            /* Disable the Peripheral */
   3137            __HAL_TIM_DISABLE(htim);
   3138          
   3139            /* Change the htim state */
   3140            htim->State = HAL_TIM_STATE_READY;
   3141          
   3142            /* Return function status */
   3143            return HAL_OK;
   3144          }
   3145          
   3146          /**
   3147            * @}
   3148            */
   3149          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management
   3150            *  @brief    TIM IRQ handler management
   3151            *
   3152          @verbatim
   3153            ==============================================================================
   3154                                  ##### IRQ handler management #####
   3155            ==============================================================================
   3156            [..]
   3157              This section provides Timer IRQ handler function.
   3158          
   3159          @endverbatim
   3160            * @{
   3161            */
   3162          /**
   3163            * @brief  This function handles TIM interrupts requests.
   3164            * @param  htim TIM  handle
   3165            * @retval None
   3166            */
   3167          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   3168          {
   3169            /* Capture compare 1 event */
   3170            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   3171            {
   3172              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
   3173              {
   3174                {
   3175                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   3176                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   3177          
   3178                  /* Input capture event */
   3179                  if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
   3180                  {
   3181          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3182                    htim->IC_CaptureCallback(htim);
   3183          #else
   3184                    HAL_TIM_IC_CaptureCallback(htim);
   3185          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3186                  }
   3187                  /* Output compare event */
   3188                  else
   3189                  {
   3190          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3191                    htim->OC_DelayElapsedCallback(htim);
   3192                    htim->PWM_PulseFinishedCallback(htim);
   3193          #else
   3194                    HAL_TIM_OC_DelayElapsedCallback(htim);
   3195                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   3196          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3197                  }
   3198                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3199                }
   3200              }
   3201            }
   3202            /* Capture compare 2 event */
   3203            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   3204            {
   3205              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
   3206              {
   3207                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   3208                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   3209                /* Input capture event */
   3210                if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
   3211                {
   3212          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3213                  htim->IC_CaptureCallback(htim);
   3214          #else
   3215                  HAL_TIM_IC_CaptureCallback(htim);
   3216          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3217                }
   3218                /* Output compare event */
   3219                else
   3220                {
   3221          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3222                  htim->OC_DelayElapsedCallback(htim);
   3223                  htim->PWM_PulseFinishedCallback(htim);
   3224          #else
   3225                  HAL_TIM_OC_DelayElapsedCallback(htim);
   3226                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   3227          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3228                }
   3229                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3230              }
   3231            }
   3232            /* Capture compare 3 event */
   3233            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   3234            {
   3235              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
   3236              {
   3237                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   3238                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   3239                /* Input capture event */
   3240                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
   3241                {
   3242          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3243                  htim->IC_CaptureCallback(htim);
   3244          #else
   3245                  HAL_TIM_IC_CaptureCallback(htim);
   3246          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3247                }
   3248                /* Output compare event */
   3249                else
   3250                {
   3251          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3252                  htim->OC_DelayElapsedCallback(htim);
   3253                  htim->PWM_PulseFinishedCallback(htim);
   3254          #else
   3255                  HAL_TIM_OC_DelayElapsedCallback(htim);
   3256                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   3257          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3258                }
   3259                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3260              }
   3261            }
   3262            /* Capture compare 4 event */
   3263            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   3264            {
   3265              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
   3266              {
   3267                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   3268                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   3269                /* Input capture event */
   3270                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
   3271                {
   3272          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3273                  htim->IC_CaptureCallback(htim);
   3274          #else
   3275                  HAL_TIM_IC_CaptureCallback(htim);
   3276          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3277                }
   3278                /* Output compare event */
   3279                else
   3280                {
   3281          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3282                  htim->OC_DelayElapsedCallback(htim);
   3283                  htim->PWM_PulseFinishedCallback(htim);
   3284          #else
   3285                  HAL_TIM_OC_DelayElapsedCallback(htim);
   3286                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   3287          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3288                }
   3289                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3290              }
   3291            }
   3292            /* TIM Update event */
   3293            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   3294            {
   3295              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
   3296              {
   3297                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   3298          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3299                htim->PeriodElapsedCallback(htim);
   3300          #else
   3301                HAL_TIM_PeriodElapsedCallback(htim);
   3302          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3303              }
   3304            }
   3305            /* TIM Break input event */
   3306            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   3307            {
   3308              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
   3309              {
   3310                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   3311          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3312                htim->BreakCallback(htim);
   3313          #else
   3314                HAL_TIMEx_BreakCallback(htim);
   3315          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3316              }
   3317            }
   3318            /* TIM Trigger detection event */
   3319            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   3320            {
   3321              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
   3322              {
   3323                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   3324          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3325                htim->TriggerCallback(htim);
   3326          #else
   3327                HAL_TIM_TriggerCallback(htim);
   3328          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3329              }
   3330            }
   3331            /* TIM commutation event */
   3332            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   3333            {
   3334              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
   3335              {
   3336                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   3337          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3338                htim->CommutationCallback(htim);
   3339          #else
   3340                HAL_TIMEx_CommutCallback(htim);
   3341          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3342              }
   3343            }
   3344          }
   3345          
   3346          /**
   3347            * @}
   3348            */
   3349          
   3350          /** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
   3351            *  @brief    TIM Peripheral Control functions
   3352            *
   3353          @verbatim
   3354            ==============================================================================
   3355                             ##### Peripheral Control functions #####
   3356            ==============================================================================
   3357           [..]
   3358             This section provides functions allowing to:
   3359                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
   3360                (+) Configure External Clock source.
   3361                (+) Configure Complementary channels, break features and dead time.
   3362                (+) Configure Master and the Slave synchronization.
   3363                (+) Configure the DMA Burst Mode.
   3364          
   3365          @endverbatim
   3366            * @{
   3367            */
   3368          
   3369          /**
   3370            * @brief  Initializes the TIM Output Compare Channels according to the specified
   3371            *         parameters in the TIM_OC_InitTypeDef.
   3372            * @param  htim TIM Output Compare handle
   3373            * @param  sConfig TIM Output Compare configuration structure
   3374            * @param  Channel TIM Channels to configure
   3375            *          This parameter can be one of the following values:
   3376            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3377            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3378            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3379            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3380            * @retval HAL status
   3381            */
   3382          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
   3383                                                     TIM_OC_InitTypeDef *sConfig,
   3384                                                     uint32_t Channel)
   3385          {
   3386            /* Check the parameters */
   3387            assert_param(IS_TIM_CHANNELS(Channel));
   3388            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   3389            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3390          
   3391            /* Process Locked */
   3392            __HAL_LOCK(htim);
   3393          
   3394            htim->State = HAL_TIM_STATE_BUSY;
   3395          
   3396            switch (Channel)
   3397            {
   3398              case TIM_CHANNEL_1:
   3399              {
   3400                /* Check the parameters */
   3401                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3402          
   3403                /* Configure the TIM Channel 1 in Output Compare */
   3404                TIM_OC1_SetConfig(htim->Instance, sConfig);
   3405                break;
   3406              }
   3407          
   3408              case TIM_CHANNEL_2:
   3409              {
   3410                /* Check the parameters */
   3411                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3412          
   3413                /* Configure the TIM Channel 2 in Output Compare */
   3414                TIM_OC2_SetConfig(htim->Instance, sConfig);
   3415                break;
   3416              }
   3417          
   3418              case TIM_CHANNEL_3:
   3419              {
   3420                /* Check the parameters */
   3421                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3422          
   3423                /* Configure the TIM Channel 3 in Output Compare */
   3424                TIM_OC3_SetConfig(htim->Instance, sConfig);
   3425                break;
   3426              }
   3427          
   3428              case TIM_CHANNEL_4:
   3429              {
   3430                /* Check the parameters */
   3431                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3432          
   3433                /* Configure the TIM Channel 4 in Output Compare */
   3434                TIM_OC4_SetConfig(htim->Instance, sConfig);
   3435                break;
   3436              }
   3437          
   3438              default:
   3439                break;
   3440            }
   3441          
   3442            htim->State = HAL_TIM_STATE_READY;
   3443          
   3444            __HAL_UNLOCK(htim);
   3445          
   3446            return HAL_OK;
   3447          }
   3448          
   3449          /**
   3450            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3451            *         parameters in the TIM_IC_InitTypeDef.
   3452            * @param  htim TIM IC handle
   3453            * @param  sConfig TIM Input Capture configuration structure
   3454            * @param  Channel TIM Channel to configure
   3455            *          This parameter can be one of the following values:
   3456            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3457            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3458            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3459            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3460            * @retval HAL status
   3461            */
   3462          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel)
   3463          {
   3464            /* Check the parameters */
   3465            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3466            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3467            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3468            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3469            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3470          
   3471            /* Process Locked */
   3472            __HAL_LOCK(htim);
   3473          
   3474            htim->State = HAL_TIM_STATE_BUSY;
   3475          
   3476            if (Channel == TIM_CHANNEL_1)
   3477            {
   3478              /* TI1 Configuration */
   3479              TIM_TI1_SetConfig(htim->Instance,
   3480                                sConfig->ICPolarity,
   3481                                sConfig->ICSelection,
   3482                                sConfig->ICFilter);
   3483          
   3484              /* Reset the IC1PSC Bits */
   3485              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   3486          
   3487              /* Set the IC1PSC value */
   3488              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   3489            }
   3490            else if (Channel == TIM_CHANNEL_2)
   3491            {
   3492              /* TI2 Configuration */
   3493              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3494          
   3495              TIM_TI2_SetConfig(htim->Instance,
   3496                                sConfig->ICPolarity,
   3497                                sConfig->ICSelection,
   3498                                sConfig->ICFilter);
   3499          
   3500              /* Reset the IC2PSC Bits */
   3501              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   3502          
   3503              /* Set the IC2PSC value */
   3504              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
   3505            }
   3506            else if (Channel == TIM_CHANNEL_3)
   3507            {
   3508              /* TI3 Configuration */
   3509              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3510          
   3511              TIM_TI3_SetConfig(htim->Instance,
   3512                                sConfig->ICPolarity,
   3513                                sConfig->ICSelection,
   3514                                sConfig->ICFilter);
   3515          
   3516              /* Reset the IC3PSC Bits */
   3517              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   3518          
   3519              /* Set the IC3PSC value */
   3520              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   3521            }
   3522            else
   3523            {
   3524              /* TI4 Configuration */
   3525              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3526          
   3527              TIM_TI4_SetConfig(htim->Instance,
   3528                                sConfig->ICPolarity,
   3529                                sConfig->ICSelection,
   3530                                sConfig->ICFilter);
   3531          
   3532              /* Reset the IC4PSC Bits */
   3533              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   3534          
   3535              /* Set the IC4PSC value */
   3536              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
   3537            }
   3538          
   3539            htim->State = HAL_TIM_STATE_READY;
   3540          
   3541            __HAL_UNLOCK(htim);
   3542          
   3543            return HAL_OK;
   3544          }
   3545          
   3546          /**
   3547            * @brief  Initializes the TIM PWM  channels according to the specified
   3548            *         parameters in the TIM_OC_InitTypeDef.
   3549            * @param  htim TIM PWM handle
   3550            * @param  sConfig TIM PWM configuration structure
   3551            * @param  Channel TIM Channels to be configured
   3552            *          This parameter can be one of the following values:
   3553            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3554            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3555            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3556            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3557            * @retval HAL status
   3558            */
   3559          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
   3560                                                      TIM_OC_InitTypeDef *sConfig,
   3561                                                      uint32_t Channel)
   3562          {
   3563            /* Check the parameters */
   3564            assert_param(IS_TIM_CHANNELS(Channel));
   3565            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3566            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3567            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   3568          
   3569            /* Process Locked */
   3570            __HAL_LOCK(htim);
   3571          
   3572            htim->State = HAL_TIM_STATE_BUSY;
   3573          
   3574            switch (Channel)
   3575            {
   3576              case TIM_CHANNEL_1:
   3577              {
   3578                /* Check the parameters */
   3579                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3580          
   3581                /* Configure the Channel 1 in PWM mode */
   3582                TIM_OC1_SetConfig(htim->Instance, sConfig);
   3583          
   3584                /* Set the Preload enable bit for channel1 */
   3585                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   3586          
   3587                /* Configure the Output Fast mode */
   3588                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   3589                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   3590                break;
   3591              }
   3592          
   3593              case TIM_CHANNEL_2:
   3594              {
   3595                /* Check the parameters */
   3596                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3597          
   3598                /* Configure the Channel 2 in PWM mode */
   3599                TIM_OC2_SetConfig(htim->Instance, sConfig);
   3600          
   3601                /* Set the Preload enable bit for channel2 */
   3602                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   3603          
   3604                /* Configure the Output Fast mode */
   3605                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   3606                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   3607                break;
   3608              }
   3609          
   3610              case TIM_CHANNEL_3:
   3611              {
   3612                /* Check the parameters */
   3613                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3614          
   3615                /* Configure the Channel 3 in PWM mode */
   3616                TIM_OC3_SetConfig(htim->Instance, sConfig);
   3617          
   3618                /* Set the Preload enable bit for channel3 */
   3619                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   3620          
   3621                /* Configure the Output Fast mode */
   3622                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   3623                htim->Instance->CCMR2 |= sConfig->OCFastMode;
   3624                break;
   3625              }
   3626          
   3627              case TIM_CHANNEL_4:
   3628              {
   3629                /* Check the parameters */
   3630                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3631          
   3632                /* Configure the Channel 4 in PWM mode */
   3633                TIM_OC4_SetConfig(htim->Instance, sConfig);
   3634          
   3635                /* Set the Preload enable bit for channel4 */
   3636                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   3637          
   3638                /* Configure the Output Fast mode */
   3639                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   3640                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
   3641                break;
   3642              }
   3643          
   3644              default:
   3645                break;
   3646            }
   3647          
   3648            htim->State = HAL_TIM_STATE_READY;
   3649          
   3650            __HAL_UNLOCK(htim);
   3651          
   3652            return HAL_OK;
   3653          }
   3654          
   3655          /**
   3656            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3657            *         parameters in the TIM_OnePulse_InitTypeDef.
   3658            * @param  htim TIM One Pulse handle
   3659            * @param  sConfig TIM One Pulse configuration structure
   3660            * @param  OutputChannel TIM output channel to configure
   3661            *          This parameter can be one of the following values:
   3662            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3663            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3664            * @param  InputChannel TIM input Channel to configure
   3665            *          This parameter can be one of the following values:
   3666            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3667            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3668            * @note  To output a waveform with a minimum delay user can enable the fast
   3669            *        mode by calling the @ref __HAL_TIM_ENABLE_OCxFAST macro. Then CCx
   3670            *        output is forced in response to the edge detection on TIx input,
   3671            *        without taking in account the comparison.
   3672            * @retval HAL status
   3673            */
   3674          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig,
   3675                                                           uint32_t OutputChannel,  uint32_t InputChannel)
   3676          {
   3677            TIM_OC_InitTypeDef temp1;
   3678          
   3679            /* Check the parameters */
   3680            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3681            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3682          
   3683            if (OutputChannel != InputChannel)
   3684            {
   3685              /* Process Locked */
   3686              __HAL_LOCK(htim);
   3687          
   3688              htim->State = HAL_TIM_STATE_BUSY;
   3689          
   3690              /* Extract the Output compare configuration from sConfig structure */
   3691              temp1.OCMode = sConfig->OCMode;
   3692              temp1.Pulse = sConfig->Pulse;
   3693              temp1.OCPolarity = sConfig->OCPolarity;
   3694              temp1.OCNPolarity = sConfig->OCNPolarity;
   3695              temp1.OCIdleState = sConfig->OCIdleState;
   3696              temp1.OCNIdleState = sConfig->OCNIdleState;
   3697          
   3698              switch (OutputChannel)
   3699              {
   3700                case TIM_CHANNEL_1:
   3701                {
   3702                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3703          
   3704                  TIM_OC1_SetConfig(htim->Instance, &temp1);
   3705                  break;
   3706                }
   3707                case TIM_CHANNEL_2:
   3708                {
   3709                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3710          
   3711                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   3712                  break;
   3713                }
   3714                default:
   3715                  break;
   3716              }
   3717          
   3718              switch (InputChannel)
   3719              {
   3720                case TIM_CHANNEL_1:
   3721                {
   3722                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3723          
   3724                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3725                                    sConfig->ICSelection, sConfig->ICFilter);
   3726          
   3727                  /* Reset the IC1PSC Bits */
   3728                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   3729          
   3730                  /* Select the Trigger source */
   3731                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3732                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   3733          
   3734                  /* Select the Slave Mode */
   3735                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3736                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3737                  break;
   3738                }
   3739                case TIM_CHANNEL_2:
   3740                {
   3741                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3742          
   3743                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3744                                    sConfig->ICSelection, sConfig->ICFilter);
   3745          
   3746                  /* Reset the IC2PSC Bits */
   3747                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   3748          
   3749                  /* Select the Trigger source */
   3750                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3751                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   3752          
   3753                  /* Select the Slave Mode */
   3754                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3755                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3756                  break;
   3757                }
   3758          
   3759                default:
   3760                  break;
   3761              }
   3762          
   3763              htim->State = HAL_TIM_STATE_READY;
   3764          
   3765              __HAL_UNLOCK(htim);
   3766          
   3767              return HAL_OK;
   3768            }
   3769            else
   3770            {
   3771              return HAL_ERROR;
   3772            }
   3773          }
   3774          
   3775          /**
   3776            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral
   3777            * @param  htim TIM handle
   3778            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write
   3779            *         This parameter can be one of the following values:
   3780            *            @arg TIM_DMABASE_CR1
   3781            *            @arg TIM_DMABASE_CR2
   3782            *            @arg TIM_DMABASE_SMCR
   3783            *            @arg TIM_DMABASE_DIER
   3784            *            @arg TIM_DMABASE_SR
   3785            *            @arg TIM_DMABASE_EGR
   3786            *            @arg TIM_DMABASE_CCMR1
   3787            *            @arg TIM_DMABASE_CCMR2
   3788            *            @arg TIM_DMABASE_CCER
   3789            *            @arg TIM_DMABASE_CNT
   3790            *            @arg TIM_DMABASE_PSC
   3791            *            @arg TIM_DMABASE_ARR
   3792            *            @arg TIM_DMABASE_RCR
   3793            *            @arg TIM_DMABASE_CCR1
   3794            *            @arg TIM_DMABASE_CCR2
   3795            *            @arg TIM_DMABASE_CCR3
   3796            *            @arg TIM_DMABASE_CCR4
   3797            *            @arg TIM_DMABASE_BDTR
   3798            * @param  BurstRequestSrc TIM DMA Request sources
   3799            *         This parameter can be one of the following values:
   3800            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3801            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3802            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3803            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3804            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3805            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3806            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3807            * @param  BurstBuffer The Buffer address.
   3808            * @param  BurstLength DMA Burst length. This parameter can be one value
   3809            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3810            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   3811            * @retval HAL status
   3812            */
   3813          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3814                                                        uint32_t *BurstBuffer, uint32_t  BurstLength)
   3815          {
   3816            /* Check the parameters */
   3817            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3818            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3819            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3820            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3821          
   3822            if (htim->State == HAL_TIM_STATE_BUSY)
   3823            {
   3824              return HAL_BUSY;
   3825            }
   3826            else if (htim->State == HAL_TIM_STATE_READY)
   3827            {
   3828              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   3829              {
   3830                return HAL_ERROR;
   3831              }
   3832              else
   3833              {
   3834                htim->State = HAL_TIM_STATE_BUSY;
   3835              }
   3836            }
   3837            else
   3838            {
   3839              /* nothing to do */
   3840            }
   3841            switch (BurstRequestSrc)
   3842            {
   3843              case TIM_DMA_UPDATE:
   3844              {
   3845                /* Set the DMA Period elapsed callbacks */
   3846                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   3847                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   3848          
   3849                /* Set the DMA error callback */
   3850                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   3851          
   3852                /* Enable the DMA stream */
   3853                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3854                {
   3855                  return HAL_ERROR;
   3856                }
   3857                break;
   3858              }
   3859              case TIM_DMA_CC1:
   3860              {
   3861                /* Set the DMA compare callbacks */
   3862                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3863                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3864          
   3865                /* Set the DMA error callback */
   3866                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3867          
   3868                /* Enable the DMA stream */
   3869                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,
   3870                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3871                {
   3872                  return HAL_ERROR;
   3873                }
   3874                break;
   3875              }
   3876              case TIM_DMA_CC2:
   3877              {
   3878                /* Set the DMA compare callbacks */
   3879                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3880                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3881          
   3882                /* Set the DMA error callback */
   3883                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3884          
   3885                /* Enable the DMA stream */
   3886                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,
   3887                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3888                {
   3889                  return HAL_ERROR;
   3890                }
   3891                break;
   3892              }
   3893              case TIM_DMA_CC3:
   3894              {
   3895                /* Set the DMA compare callbacks */
   3896                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3897                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3898          
   3899                /* Set the DMA error callback */
   3900                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   3901          
   3902                /* Enable the DMA stream */
   3903                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,
   3904                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3905                {
   3906                  return HAL_ERROR;
   3907                }
   3908                break;
   3909              }
   3910              case TIM_DMA_CC4:
   3911              {
   3912                /* Set the DMA compare callbacks */
   3913                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3914                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3915          
   3916                /* Set the DMA error callback */
   3917                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   3918          
   3919                /* Enable the DMA stream */
   3920                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,
   3921                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3922                {
   3923                  return HAL_ERROR;
   3924                }
   3925                break;
   3926              }
   3927              case TIM_DMA_COM:
   3928              {
   3929                /* Set the DMA commutation callbacks */
   3930                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   3931                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   3932          
   3933                /* Set the DMA error callback */
   3934                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   3935          
   3936                /* Enable the DMA stream */
   3937                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,
   3938                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3939                {
   3940                  return HAL_ERROR;
   3941                }
   3942                break;
   3943              }
   3944              case TIM_DMA_TRIGGER:
   3945              {
   3946                /* Set the DMA trigger callbacks */
   3947                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   3948                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   3949          
   3950                /* Set the DMA error callback */
   3951                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   3952          
   3953                /* Enable the DMA stream */
   3954                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
   3955                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3956                {
   3957                  return HAL_ERROR;
   3958                }
   3959                break;
   3960              }
   3961              default:
   3962                break;
   3963            }
   3964            /* configure the DMA Burst Mode */
   3965            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   3966          
   3967            /* Enable the TIM DMA Request */
   3968            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   3969          
   3970            htim->State = HAL_TIM_STATE_READY;
   3971          
   3972            /* Return function status */
   3973            return HAL_OK;
   3974          }
   3975          
   3976          /**
   3977            * @brief  Stops the TIM DMA Burst mode
   3978            * @param  htim TIM handle
   3979            * @param  BurstRequestSrc TIM DMA Request sources to disable
   3980            * @retval HAL status
   3981            */
   3982          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3983          {
   3984            HAL_StatusTypeDef status = HAL_OK;
   3985            /* Check the parameters */
   3986            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3987          
   3988            /* Abort the DMA transfer (at least disable the DMA stream) */
   3989            switch (BurstRequestSrc)
   3990            {
   3991              case TIM_DMA_UPDATE:
   3992              {
   3993                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   3994                break;
   3995              }
   3996              case TIM_DMA_CC1:
   3997              {
   3998                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   3999                break;
   4000              }
   4001              case TIM_DMA_CC2:
   4002              {
   4003                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   4004                break;
   4005              }
   4006              case TIM_DMA_CC3:
   4007              {
   4008                status =  HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   4009                break;
   4010              }
   4011              case TIM_DMA_CC4:
   4012              {
   4013                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   4014                break;
   4015              }
   4016              case TIM_DMA_COM:
   4017              {
   4018                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   4019                break;
   4020              }
   4021              case TIM_DMA_TRIGGER:
   4022              {
   4023                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   4024                break;
   4025              }
   4026              default:
   4027                break;
   4028            }
   4029          
   4030            if (HAL_OK == status)
   4031            {
   4032              /* Disable the TIM Update DMA request */
   4033              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   4034            }
   4035          
   4036            /* Return function status */
   4037            return status;
   4038          }
   4039          
   4040          /**
   4041            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
   4042            * @param  htim TIM handle
   4043            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
   4044            *         This parameter can be one of the following values:
   4045            *            @arg TIM_DMABASE_CR1
   4046            *            @arg TIM_DMABASE_CR2
   4047            *            @arg TIM_DMABASE_SMCR
   4048            *            @arg TIM_DMABASE_DIER
   4049            *            @arg TIM_DMABASE_SR
   4050            *            @arg TIM_DMABASE_EGR
   4051            *            @arg TIM_DMABASE_CCMR1
   4052            *            @arg TIM_DMABASE_CCMR2
   4053            *            @arg TIM_DMABASE_CCER
   4054            *            @arg TIM_DMABASE_CNT
   4055            *            @arg TIM_DMABASE_PSC
   4056            *            @arg TIM_DMABASE_ARR
   4057            *            @arg TIM_DMABASE_RCR
   4058            *            @arg TIM_DMABASE_CCR1
   4059            *            @arg TIM_DMABASE_CCR2
   4060            *            @arg TIM_DMABASE_CCR3
   4061            *            @arg TIM_DMABASE_CCR4
   4062            *            @arg TIM_DMABASE_BDTR
   4063            * @param  BurstRequestSrc TIM DMA Request sources
   4064            *         This parameter can be one of the following values:
   4065            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   4066            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   4067            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   4068            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   4069            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   4070            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   4071            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   4072            * @param  BurstBuffer The Buffer address.
   4073            * @param  BurstLength DMA Burst length. This parameter can be one value
   4074            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   4075            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   4076            * @retval HAL status
   4077            */
   4078          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   4079                                                       uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength)
   4080          {
   4081            /* Check the parameters */
   4082            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   4083            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   4084            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4085            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   4086          
   4087            if (htim->State == HAL_TIM_STATE_BUSY)
   4088            {
   4089              return HAL_BUSY;
   4090            }
   4091            else if (htim->State == HAL_TIM_STATE_READY)
   4092            {
   4093              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   4094              {
   4095                return HAL_ERROR;
   4096              }
   4097              else
   4098              {
   4099                htim->State = HAL_TIM_STATE_BUSY;
   4100              }
   4101            }
   4102            else
   4103            {
   4104              /* nothing to do */
   4105            }
   4106            switch (BurstRequestSrc)
   4107            {
   4108              case TIM_DMA_UPDATE:
   4109              {
   4110                /* Set the DMA Period elapsed callbacks */
   4111                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   4112                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   4113          
   4114                /* Set the DMA error callback */
   4115                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   4116          
   4117                /* Enable the DMA stream */
   4118                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4119                {
   4120                  return HAL_ERROR;
   4121                }
   4122                break;
   4123              }
   4124              case TIM_DMA_CC1:
   4125              {
   4126                /* Set the DMA capture callbacks */
   4127                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   4128                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4129          
   4130                /* Set the DMA error callback */
   4131                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   4132          
   4133                /* Enable the DMA stream */
   4134                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4135                {
   4136                  return HAL_ERROR;
   4137                }
   4138                break;
   4139              }
   4140              case TIM_DMA_CC2:
   4141              {
   4142                /* Set the DMA capture/compare callbacks */
   4143                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   4144                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4145          
   4146                /* Set the DMA error callback */
   4147                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   4148          
   4149                /* Enable the DMA stream */
   4150                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4151                {
   4152                  return HAL_ERROR;
   4153                }
   4154                break;
   4155              }
   4156              case TIM_DMA_CC3:
   4157              {
   4158                /* Set the DMA capture callbacks */
   4159                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   4160                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4161          
   4162                /* Set the DMA error callback */
   4163                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   4164          
   4165                /* Enable the DMA stream */
   4166                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4167                {
   4168                  return HAL_ERROR;
   4169                }
   4170                break;
   4171              }
   4172              case TIM_DMA_CC4:
   4173              {
   4174                /* Set the DMA capture callbacks */
   4175                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   4176                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4177          
   4178                /* Set the DMA error callback */
   4179                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   4180          
   4181                /* Enable the DMA stream */
   4182                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4183                {
   4184                  return HAL_ERROR;
   4185                }
   4186                break;
   4187              }
   4188              case TIM_DMA_COM:
   4189              {
   4190                /* Set the DMA commutation callbacks */
   4191                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   4192                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   4193          
   4194                /* Set the DMA error callback */
   4195                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   4196          
   4197                /* Enable the DMA stream */
   4198                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4199                {
   4200                  return HAL_ERROR;
   4201                }
   4202                break;
   4203              }
   4204              case TIM_DMA_TRIGGER:
   4205              {
   4206                /* Set the DMA trigger callbacks */
   4207                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   4208                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   4209          
   4210                /* Set the DMA error callback */
   4211                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   4212          
   4213                /* Enable the DMA stream */
   4214                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4215                {
   4216                  return HAL_ERROR;
   4217                }
   4218                break;
   4219              }
   4220              default:
   4221                break;
   4222            }
   4223          
   4224            /* configure the DMA Burst Mode */
   4225            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   4226          
   4227            /* Enable the TIM DMA Request */
   4228            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   4229          
   4230            htim->State = HAL_TIM_STATE_READY;
   4231          
   4232            /* Return function status */
   4233            return HAL_OK;
   4234          }
   4235          
   4236          /**
   4237            * @brief  Stop the DMA burst reading
   4238            * @param  htim TIM handle
   4239            * @param  BurstRequestSrc TIM DMA Request sources to disable.
   4240            * @retval HAL status
   4241            */
   4242          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   4243          {
   4244            HAL_StatusTypeDef status = HAL_OK;
   4245            /* Check the parameters */
   4246            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4247          
   4248            /* Abort the DMA transfer (at least disable the DMA stream) */
   4249            switch (BurstRequestSrc)
   4250            {
   4251              case TIM_DMA_UPDATE:
   4252              {
   4253                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   4254                break;
   4255              }
   4256              case TIM_DMA_CC1:
   4257              {
   4258                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   4259                break;
   4260              }
   4261              case TIM_DMA_CC2:
   4262              {
   4263                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   4264                break;
   4265              }
   4266              case TIM_DMA_CC3:
   4267              {
   4268                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   4269                break;
   4270              }
   4271              case TIM_DMA_CC4:
   4272              {
   4273                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   4274                break;
   4275              }
   4276              case TIM_DMA_COM:
   4277              {
   4278                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   4279                break;
   4280              }
   4281              case TIM_DMA_TRIGGER:
   4282              {
   4283                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   4284                break;
   4285              }
   4286              default:
   4287                break;
   4288            }
   4289          
   4290            if (HAL_OK == status)
   4291            {
   4292              /* Disable the TIM Update DMA request */
   4293              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   4294            }
   4295          
   4296            /* Return function status */
   4297            return status;
   4298          }
   4299          
   4300          /**
   4301            * @brief  Generate a software event
   4302            * @param  htim TIM handle
   4303            * @param  EventSource specifies the event source.
   4304            *          This parameter can be one of the following values:
   4305            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   4306            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   4307            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   4308            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   4309            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   4310            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source
   4311            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   4312            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   4313            * @note   Basic timers can only generate an update event.
   4314            * @note   TIM_EVENTSOURCE_COM is relevant only with advanced timer instances.
   4315            * @note   TIM_EVENTSOURCE_BREAK are relevant only for timer instances
   4316            *         supporting a break input.
   4317            * @retval HAL status
   4318            */
   4319          
   4320          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   4321          {
   4322            /* Check the parameters */
   4323            assert_param(IS_TIM_INSTANCE(htim->Instance));
   4324            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   4325          
   4326            /* Process Locked */
   4327            __HAL_LOCK(htim);
   4328          
   4329            /* Change the TIM state */
   4330            htim->State = HAL_TIM_STATE_BUSY;
   4331          
   4332            /* Set the event sources */
   4333            htim->Instance->EGR = EventSource;
   4334          
   4335            /* Change the TIM state */
   4336            htim->State = HAL_TIM_STATE_READY;
   4337          
   4338            __HAL_UNLOCK(htim);
   4339          
   4340            /* Return function status */
   4341            return HAL_OK;
   4342          }
   4343          
   4344          /**
   4345            * @brief  Configures the OCRef clear feature
   4346            * @param  htim TIM handle
   4347            * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that
   4348            *         contains the OCREF clear feature and parameters for the TIM peripheral.
   4349            * @param  Channel specifies the TIM Channel
   4350            *          This parameter can be one of the following values:
   4351            *            @arg TIM_CHANNEL_1: TIM Channel 1
   4352            *            @arg TIM_CHANNEL_2: TIM Channel 2
   4353            *            @arg TIM_CHANNEL_3: TIM Channel 3
   4354            *            @arg TIM_CHANNEL_4: TIM Channel 4
   4355            * @retval HAL status
   4356            */
   4357          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
   4358                                                     TIM_ClearInputConfigTypeDef *sClearInputConfig,
   4359                                                     uint32_t Channel)
   4360          {
   4361            /* Check the parameters */
   4362            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   4363            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   4364          
   4365            /* Process Locked */
   4366            __HAL_LOCK(htim);
   4367          
   4368            htim->State = HAL_TIM_STATE_BUSY;
   4369          
   4370            switch (sClearInputConfig->ClearInputSource)
   4371            {
   4372              case TIM_CLEARINPUTSOURCE_NONE:
   4373              {
   4374                /* Clear the OCREF clear selection bit and the the ETR Bits */
   4375                CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
   4376                break;
   4377              }
   4378          
   4379              case TIM_CLEARINPUTSOURCE_ETR:
   4380              {
   4381                /* Check the parameters */
   4382                assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   4383                assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   4384                assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   4385          
   4386                /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */
   4387                if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
   4388                {
   4389                  htim->State = HAL_TIM_STATE_READY;
   4390                  __HAL_UNLOCK(htim);
   4391                  return HAL_ERROR;
   4392                }
   4393          
   4394                TIM_ETR_SetConfig(htim->Instance,
   4395                                  sClearInputConfig->ClearInputPrescaler,
   4396                                  sClearInputConfig->ClearInputPolarity,
   4397                                  sClearInputConfig->ClearInputFilter);
   4398                break;
   4399              }
   4400          
   4401              default:
   4402                break;
   4403            }
   4404          
   4405            switch (Channel)
   4406            {
   4407              case TIM_CHANNEL_1:
   4408              {
   4409                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   4410                {
   4411                  /* Enable the OCREF clear feature for Channel 1 */
   4412                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   4413                }
   4414                else
   4415                {
   4416                  /* Disable the OCREF clear feature for Channel 1 */
   4417                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   4418                }
   4419                break;
   4420              }
   4421              case TIM_CHANNEL_2:
   4422              {
   4423                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   4424                {
   4425                  /* Enable the OCREF clear feature for Channel 2 */
   4426                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   4427                }
   4428                else
   4429                {
   4430                  /* Disable the OCREF clear feature for Channel 2 */
   4431                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   4432                }
   4433                break;
   4434              }
   4435              case TIM_CHANNEL_3:
   4436              {
   4437                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   4438                {
   4439                  /* Enable the OCREF clear feature for Channel 3 */
   4440                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   4441                }
   4442                else
   4443                {
   4444                  /* Disable the OCREF clear feature for Channel 3 */
   4445                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   4446                }
   4447                break;
   4448              }
   4449              case TIM_CHANNEL_4:
   4450              {
   4451                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   4452                {
   4453                  /* Enable the OCREF clear feature for Channel 4 */
   4454                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   4455                }
   4456                else
   4457                {
   4458                  /* Disable the OCREF clear feature for Channel 4 */
   4459                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   4460                }
   4461                break;
   4462              }
   4463              default:
   4464                break;
   4465            }
   4466          
   4467            htim->State = HAL_TIM_STATE_READY;
   4468          
   4469            __HAL_UNLOCK(htim);
   4470          
   4471            return HAL_OK;
   4472          }
   4473          
   4474          /**
   4475            * @brief   Configures the clock source to be used
   4476            * @param  htim TIM handle
   4477            * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
   4478            *         contains the clock source information for the TIM peripheral.
   4479            * @retval HAL status
   4480            */
   4481          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
   4482          {
   4483            uint32_t tmpsmcr;
   4484          
   4485            /* Process Locked */
   4486            __HAL_LOCK(htim);
   4487          
   4488            htim->State = HAL_TIM_STATE_BUSY;
   4489          
   4490            /* Check the parameters */
   4491            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   4492          
   4493            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   4494            tmpsmcr = htim->Instance->SMCR;
   4495            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   4496            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   4497            htim->Instance->SMCR = tmpsmcr;
   4498          
   4499            switch (sClockSourceConfig->ClockSource)
   4500            {
   4501              case TIM_CLOCKSOURCE_INTERNAL:
   4502              {
   4503                assert_param(IS_TIM_INSTANCE(htim->Instance));
   4504                break;
   4505              }
   4506          
   4507              case TIM_CLOCKSOURCE_ETRMODE1:
   4508              {
   4509                /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
   4510                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   4511          
   4512                /* Check ETR input conditioning related parameters */
   4513                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4514                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4515                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4516          
   4517                /* Configure the ETR Clock source */
   4518                TIM_ETR_SetConfig(htim->Instance,
   4519                                  sClockSourceConfig->ClockPrescaler,
   4520                                  sClockSourceConfig->ClockPolarity,
   4521                                  sClockSourceConfig->ClockFilter);
   4522          
   4523                /* Select the External clock mode1 and the ETRF trigger */
   4524                tmpsmcr = htim->Instance->SMCR;
   4525                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   4526                /* Write to TIMx SMCR */
   4527                htim->Instance->SMCR = tmpsmcr;
   4528                break;
   4529              }
   4530          
   4531              case TIM_CLOCKSOURCE_ETRMODE2:
   4532              {
   4533                /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
   4534                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   4535          
   4536                /* Check ETR input conditioning related parameters */
   4537                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4538                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4539                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4540          
   4541                /* Configure the ETR Clock source */
   4542                TIM_ETR_SetConfig(htim->Instance,
   4543                                  sClockSourceConfig->ClockPrescaler,
   4544                                  sClockSourceConfig->ClockPolarity,
   4545                                  sClockSourceConfig->ClockFilter);
   4546                /* Enable the External clock mode2 */
   4547                htim->Instance->SMCR |= TIM_SMCR_ECE;
   4548                break;
   4549              }
   4550          
   4551              case TIM_CLOCKSOURCE_TI1:
   4552              {
   4553                /* Check whether or not the timer instance supports external clock mode 1 */
   4554                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4555          
   4556                /* Check TI1 input conditioning related parameters */
   4557                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4558                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4559          
   4560                TIM_TI1_ConfigInputStage(htim->Instance,
   4561                                         sClockSourceConfig->ClockPolarity,
   4562                                         sClockSourceConfig->ClockFilter);
   4563                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   4564                break;
   4565              }
   4566          
   4567              case TIM_CLOCKSOURCE_TI2:
   4568              {
   4569                /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
   4570                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4571          
   4572                /* Check TI2 input conditioning related parameters */
   4573                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4574                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4575          
   4576                TIM_TI2_ConfigInputStage(htim->Instance,
   4577                                         sClockSourceConfig->ClockPolarity,
   4578                                         sClockSourceConfig->ClockFilter);
   4579                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   4580                break;
   4581              }
   4582          
   4583              case TIM_CLOCKSOURCE_TI1ED:
   4584              {
   4585                /* Check whether or not the timer instance supports external clock mode 1 */
   4586                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4587          
   4588                /* Check TI1 input conditioning related parameters */
   4589                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4590                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4591          
   4592                TIM_TI1_ConfigInputStage(htim->Instance,
   4593                                         sClockSourceConfig->ClockPolarity,
   4594                                         sClockSourceConfig->ClockFilter);
   4595                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   4596                break;
   4597              }
   4598          
   4599              case TIM_CLOCKSOURCE_ITR0:
   4600              case TIM_CLOCKSOURCE_ITR1:
   4601              case TIM_CLOCKSOURCE_ITR2:
   4602              case TIM_CLOCKSOURCE_ITR3:
   4603              {
   4604                /* Check whether or not the timer instance supports internal trigger input */
   4605                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4606          
   4607                TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
   4608                break;
   4609              }
   4610          
   4611              default:
   4612                break;
   4613            }
   4614            htim->State = HAL_TIM_STATE_READY;
   4615          
   4616            __HAL_UNLOCK(htim);
   4617          
   4618            return HAL_OK;
   4619          }
   4620          
   4621          /**
   4622            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4623            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4624            * @param  htim TIM handle.
   4625            * @param  TI1_Selection Indicate whether or not channel 1 is connected to the
   4626            *         output of a XOR gate.
   4627            *          This parameter can be one of the following values:
   4628            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4629            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4630            *            pins are connected to the TI1 input (XOR combination)
   4631            * @retval HAL status
   4632            */
   4633          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4634          {
   4635            uint32_t tmpcr2;
   4636          
   4637            /* Check the parameters */
   4638            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
   4639            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4640          
   4641            /* Get the TIMx CR2 register value */
   4642            tmpcr2 = htim->Instance->CR2;
   4643          
   4644            /* Reset the TI1 selection */
   4645            tmpcr2 &= ~TIM_CR2_TI1S;
   4646          
   4647            /* Set the TI1 selection */
   4648            tmpcr2 |= TI1_Selection;
   4649          
   4650            /* Write to TIMxCR2 */
   4651            htim->Instance->CR2 = tmpcr2;
   4652          
   4653            return HAL_OK;
   4654          }
   4655          
   4656          /**
   4657            * @brief  Configures the TIM in Slave mode
   4658            * @param  htim TIM handle.
   4659            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4660            *         contains the selected trigger (internal trigger input, filtered
   4661            *         timer input or external trigger input) and the Slave mode
   4662            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4663            * @retval HAL status
   4664            */
   4665          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)
   4666          {
   4667            /* Check the parameters */
   4668            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4669            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4670            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4671          
   4672            __HAL_LOCK(htim);
   4673          
   4674            htim->State = HAL_TIM_STATE_BUSY;
   4675          
   4676            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   4677            {
   4678              htim->State = HAL_TIM_STATE_READY;
   4679              __HAL_UNLOCK(htim);
   4680              return HAL_ERROR;
   4681            }
   4682          
   4683            /* Disable Trigger Interrupt */
   4684            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   4685          
   4686            /* Disable Trigger DMA request */
   4687            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   4688          
   4689            htim->State = HAL_TIM_STATE_READY;
   4690          
   4691            __HAL_UNLOCK(htim);
   4692          
   4693            return HAL_OK;
   4694          }
   4695          
   4696          /**
   4697            * @brief  Configures the TIM in Slave mode in interrupt mode
   4698            * @param  htim TIM handle.
   4699            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4700            *         contains the selected trigger (internal trigger input, filtered
   4701            *         timer input or external trigger input) and the Slave mode
   4702            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4703            * @retval HAL status
   4704            */
   4705          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,
   4706                                                          TIM_SlaveConfigTypeDef *sSlaveConfig)
   4707          {
   4708            /* Check the parameters */
   4709            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4710            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4711            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4712          
   4713            __HAL_LOCK(htim);
   4714          
   4715            htim->State = HAL_TIM_STATE_BUSY;
   4716          
   4717            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   4718            {
   4719              htim->State = HAL_TIM_STATE_READY;
   4720              __HAL_UNLOCK(htim);
   4721              return HAL_ERROR;
   4722            }
   4723          
   4724            /* Enable Trigger Interrupt */
   4725            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   4726          
   4727            /* Disable Trigger DMA request */
   4728            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   4729          
   4730            htim->State = HAL_TIM_STATE_READY;
   4731          
   4732            __HAL_UNLOCK(htim);
   4733          
   4734            return HAL_OK;
   4735          }
   4736          
   4737          /**
   4738            * @brief  Read the captured value from Capture Compare unit
   4739            * @param  htim TIM handle.
   4740            * @param  Channel TIM Channels to be enabled
   4741            *          This parameter can be one of the following values:
   4742            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4743            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4744            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4745            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4746            * @retval Captured value
   4747            */
   4748          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4749          {
   4750            uint32_t tmpreg = 0U;
   4751          
   4752            switch (Channel)
   4753            {
   4754              case TIM_CHANNEL_1:
   4755              {
   4756                /* Check the parameters */
   4757                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4758          
   4759                /* Return the capture 1 value */
   4760                tmpreg =  htim->Instance->CCR1;
   4761          
   4762                break;
   4763              }
   4764              case TIM_CHANNEL_2:
   4765              {
   4766                /* Check the parameters */
   4767                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4768          
   4769                /* Return the capture 2 value */
   4770                tmpreg =   htim->Instance->CCR2;
   4771          
   4772                break;
   4773              }
   4774          
   4775              case TIM_CHANNEL_3:
   4776              {
   4777                /* Check the parameters */
   4778                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4779          
   4780                /* Return the capture 3 value */
   4781                tmpreg =   htim->Instance->CCR3;
   4782          
   4783                break;
   4784              }
   4785          
   4786              case TIM_CHANNEL_4:
   4787              {
   4788                /* Check the parameters */
   4789                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4790          
   4791                /* Return the capture 4 value */
   4792                tmpreg =   htim->Instance->CCR4;
   4793          
   4794                break;
   4795              }
   4796          
   4797              default:
   4798                break;
   4799            }
   4800          
   4801            return tmpreg;
   4802          }
   4803          
   4804          /**
   4805            * @}
   4806            */
   4807          
   4808          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4809            *  @brief    TIM Callbacks functions
   4810            *
   4811          @verbatim
   4812            ==============================================================================
   4813                                  ##### TIM Callbacks functions #####
   4814            ==============================================================================
   4815           [..]
   4816             This section provides TIM callback functions:
   4817             (+) TIM Period elapsed callback
   4818             (+) TIM Output Compare callback
   4819             (+) TIM Input capture callback
   4820             (+) TIM Trigger callback
   4821             (+) TIM Error callback
   4822          
   4823          @endverbatim
   4824            * @{
   4825            */
   4826          
   4827          /**
   4828            * @brief  Period elapsed callback in non-blocking mode
   4829            * @param  htim TIM handle
   4830            * @retval None
   4831            */
   4832          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4833          {
   4834            /* Prevent unused argument(s) compilation warning */
   4835            UNUSED(htim);
   4836          
   4837            /* NOTE : This function should not be modified, when the callback is needed,
   4838                      the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4839             */
   4840          }
   4841          
   4842          /**
   4843            * @brief  Period elapsed half complete callback in non-blocking mode
   4844            * @param  htim TIM handle
   4845            * @retval None
   4846            */
   4847          __weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)
   4848          {
   4849            /* Prevent unused argument(s) compilation warning */
   4850            UNUSED(htim);
   4851          
   4852            /* NOTE : This function should not be modified, when the callback is needed,
   4853                      the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
   4854             */
   4855          }
   4856          
   4857          /**
   4858            * @brief  Output Compare callback in non-blocking mode
   4859            * @param  htim TIM OC handle
   4860            * @retval None
   4861            */
   4862          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4863          {
   4864            /* Prevent unused argument(s) compilation warning */
   4865            UNUSED(htim);
   4866          
   4867            /* NOTE : This function should not be modified, when the callback is needed,
   4868                      the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4869             */
   4870          }
   4871          
   4872          /**
   4873            * @brief  Input Capture callback in non-blocking mode
   4874            * @param  htim TIM IC handle
   4875            * @retval None
   4876            */
   4877          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4878          {
   4879            /* Prevent unused argument(s) compilation warning */
   4880            UNUSED(htim);
   4881          
   4882            /* NOTE : This function should not be modified, when the callback is needed,
   4883                      the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4884             */
   4885          }
   4886          
   4887          /**
   4888            * @brief  Input Capture half complete callback in non-blocking mode
   4889            * @param  htim TIM IC handle
   4890            * @retval None
   4891            */
   4892          __weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)
   4893          {
   4894            /* Prevent unused argument(s) compilation warning */
   4895            UNUSED(htim);
   4896          
   4897            /* NOTE : This function should not be modified, when the callback is needed,
   4898                      the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
   4899             */
   4900          }
   4901          
   4902          /**
   4903            * @brief  PWM Pulse finished callback in non-blocking mode
   4904            * @param  htim TIM handle
   4905            * @retval None
   4906            */
   4907          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4908          {
   4909            /* Prevent unused argument(s) compilation warning */
   4910            UNUSED(htim);
   4911          
   4912            /* NOTE : This function should not be modified, when the callback is needed,
   4913                      the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4914             */
   4915          }
   4916          
   4917          /**
   4918            * @brief  PWM Pulse finished half complete callback in non-blocking mode
   4919            * @param  htim TIM handle
   4920            * @retval None
   4921            */
   4922          __weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)
   4923          {
   4924            /* Prevent unused argument(s) compilation warning */
   4925            UNUSED(htim);
   4926          
   4927            /* NOTE : This function should not be modified, when the callback is needed,
   4928                      the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
   4929             */
   4930          }
   4931          
   4932          /**
   4933            * @brief  Hall Trigger detection callback in non-blocking mode
   4934            * @param  htim TIM handle
   4935            * @retval None
   4936            */
   4937          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4938          {
   4939            /* Prevent unused argument(s) compilation warning */
   4940            UNUSED(htim);
   4941          
   4942            /* NOTE : This function should not be modified, when the callback is needed,
   4943                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4944             */
   4945          }
   4946          
   4947          /**
   4948            * @brief  Hall Trigger detection half complete callback in non-blocking mode
   4949            * @param  htim TIM handle
   4950            * @retval None
   4951            */
   4952          __weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)
   4953          {
   4954            /* Prevent unused argument(s) compilation warning */
   4955            UNUSED(htim);
   4956          
   4957            /* NOTE : This function should not be modified, when the callback is needed,
   4958                      the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
   4959             */
   4960          }
   4961          
   4962          /**
   4963            * @brief  Timer error callback in non-blocking mode
   4964            * @param  htim TIM handle
   4965            * @retval None
   4966            */
   4967          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4968          {
   4969            /* Prevent unused argument(s) compilation warning */
   4970            UNUSED(htim);
   4971          
   4972            /* NOTE : This function should not be modified, when the callback is needed,
   4973                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4974             */
   4975          }
   4976          
   4977          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   4978          /**
   4979            * @brief  Register a User TIM callback to be used instead of the weak predefined callback
   4980            * @param htim tim handle
   4981            * @param CallbackID ID of the callback to be registered
   4982            *        This parameter can be one of the following values:
   4983            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   4984            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   4985            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   4986            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   4987            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   4988            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   4989            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   4990            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   4991            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   4992            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   4993            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   4994            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   4995            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   4996            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   4997            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   4998            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   4999            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   5000            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   5001            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   5002            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   5003            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   5004            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   5005            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   5006            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   5007            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   5008            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   5009            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   5010            *          @param pCallback pointer to the callback function
   5011            *          @retval status
   5012            */
   5013          HAL_StatusTypeDef HAL_TIM_RegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID,
   5014                                                     pTIM_CallbackTypeDef pCallback)
   5015          {
   5016            HAL_StatusTypeDef status = HAL_OK;
   5017          
   5018            if (pCallback == NULL)
   5019            {
   5020              return HAL_ERROR;
   5021            }
   5022            /* Process locked */
   5023            __HAL_LOCK(htim);
   5024          
   5025            if (htim->State == HAL_TIM_STATE_READY)
   5026            {
   5027              switch (CallbackID)
   5028              {
   5029                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5030                  htim->Base_MspInitCallback                 = pCallback;
   5031                  break;
   5032          
   5033                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5034                  htim->Base_MspDeInitCallback               = pCallback;
   5035                  break;
   5036          
   5037                case HAL_TIM_IC_MSPINIT_CB_ID :
   5038                  htim->IC_MspInitCallback                   = pCallback;
   5039                  break;
   5040          
   5041                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5042                  htim->IC_MspDeInitCallback                 = pCallback;
   5043                  break;
   5044          
   5045                case HAL_TIM_OC_MSPINIT_CB_ID :
   5046                  htim->OC_MspInitCallback                   = pCallback;
   5047                  break;
   5048          
   5049                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5050                  htim->OC_MspDeInitCallback                 = pCallback;
   5051                  break;
   5052          
   5053                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5054                  htim->PWM_MspInitCallback                  = pCallback;
   5055                  break;
   5056          
   5057                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5058                  htim->PWM_MspDeInitCallback                = pCallback;
   5059                  break;
   5060          
   5061                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5062                  htim->OnePulse_MspInitCallback             = pCallback;
   5063                  break;
   5064          
   5065                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5066                  htim->OnePulse_MspDeInitCallback           = pCallback;
   5067                  break;
   5068          
   5069                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5070                  htim->Encoder_MspInitCallback              = pCallback;
   5071                  break;
   5072          
   5073                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5074                  htim->Encoder_MspDeInitCallback            = pCallback;
   5075                  break;
   5076          
   5077                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5078                  htim->HallSensor_MspInitCallback           = pCallback;
   5079                  break;
   5080          
   5081                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5082                  htim->HallSensor_MspDeInitCallback         = pCallback;
   5083                  break;
   5084          
   5085                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   5086                  htim->PeriodElapsedCallback                = pCallback;
   5087                  break;
   5088          
   5089                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   5090                  htim->PeriodElapsedHalfCpltCallback        = pCallback;
   5091                  break;
   5092          
   5093                case HAL_TIM_TRIGGER_CB_ID :
   5094                  htim->TriggerCallback                      = pCallback;
   5095                  break;
   5096          
   5097                case HAL_TIM_TRIGGER_HALF_CB_ID :
   5098                  htim->TriggerHalfCpltCallback              = pCallback;
   5099                  break;
   5100          
   5101                case HAL_TIM_IC_CAPTURE_CB_ID :
   5102                  htim->IC_CaptureCallback                   = pCallback;
   5103                  break;
   5104          
   5105                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   5106                  htim->IC_CaptureHalfCpltCallback           = pCallback;
   5107                  break;
   5108          
   5109                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   5110                  htim->OC_DelayElapsedCallback              = pCallback;
   5111                  break;
   5112          
   5113                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   5114                  htim->PWM_PulseFinishedCallback            = pCallback;
   5115                  break;
   5116          
   5117                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   5118                  htim->PWM_PulseFinishedHalfCpltCallback    = pCallback;
   5119                  break;
   5120          
   5121                case HAL_TIM_ERROR_CB_ID :
   5122                  htim->ErrorCallback                        = pCallback;
   5123                  break;
   5124          
   5125                case HAL_TIM_COMMUTATION_CB_ID :
   5126                  htim->CommutationCallback                  = pCallback;
   5127                  break;
   5128          
   5129                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   5130                  htim->CommutationHalfCpltCallback          = pCallback;
   5131                  break;
   5132          
   5133                case HAL_TIM_BREAK_CB_ID :
   5134                  htim->BreakCallback                        = pCallback;
   5135                  break;
   5136          
   5137                default :
   5138                  /* Return error status */
   5139                  status =  HAL_ERROR;
   5140                  break;
   5141              }
   5142            }
   5143            else if (htim->State == HAL_TIM_STATE_RESET)
   5144            {
   5145              switch (CallbackID)
   5146              {
   5147                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5148                  htim->Base_MspInitCallback         = pCallback;
   5149                  break;
   5150          
   5151                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5152                  htim->Base_MspDeInitCallback       = pCallback;
   5153                  break;
   5154          
   5155                case HAL_TIM_IC_MSPINIT_CB_ID :
   5156                  htim->IC_MspInitCallback           = pCallback;
   5157                  break;
   5158          
   5159                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5160                  htim->IC_MspDeInitCallback         = pCallback;
   5161                  break;
   5162          
   5163                case HAL_TIM_OC_MSPINIT_CB_ID :
   5164                  htim->OC_MspInitCallback           = pCallback;
   5165                  break;
   5166          
   5167                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5168                  htim->OC_MspDeInitCallback         = pCallback;
   5169                  break;
   5170          
   5171                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5172                  htim->PWM_MspInitCallback          = pCallback;
   5173                  break;
   5174          
   5175                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5176                  htim->PWM_MspDeInitCallback        = pCallback;
   5177                  break;
   5178          
   5179                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5180                  htim->OnePulse_MspInitCallback     = pCallback;
   5181                  break;
   5182          
   5183                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5184                  htim->OnePulse_MspDeInitCallback   = pCallback;
   5185                  break;
   5186          
   5187                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5188                  htim->Encoder_MspInitCallback      = pCallback;
   5189                  break;
   5190          
   5191                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5192                  htim->Encoder_MspDeInitCallback    = pCallback;
   5193                  break;
   5194          
   5195                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5196                  htim->HallSensor_MspInitCallback   = pCallback;
   5197                  break;
   5198          
   5199                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5200                  htim->HallSensor_MspDeInitCallback = pCallback;
   5201                  break;
   5202          
   5203                default :
   5204                  /* Return error status */
   5205                  status =  HAL_ERROR;
   5206                  break;
   5207              }
   5208            }
   5209            else
   5210            {
   5211              /* Return error status */
   5212              status =  HAL_ERROR;
   5213            }
   5214          
   5215            /* Release Lock */
   5216            __HAL_UNLOCK(htim);
   5217          
   5218            return status;
   5219          }
   5220          
   5221          /**
   5222            * @brief  Unregister a TIM callback
   5223            *         TIM callback is redirected to the weak predefined callback
   5224            * @param htim tim handle
   5225            * @param CallbackID ID of the callback to be unregistered
   5226            *        This parameter can be one of the following values:
   5227            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   5228            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   5229            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   5230            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   5231            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   5232            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   5233            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   5234            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   5235            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   5236            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   5237            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   5238            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   5239            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   5240            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   5241            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   5242            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   5243            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   5244            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   5245            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   5246            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   5247            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   5248            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   5249            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   5250            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   5251            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   5252            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   5253            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   5254            *          @retval status
   5255            */
   5256          HAL_StatusTypeDef HAL_TIM_UnRegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID)
   5257          {
   5258            HAL_StatusTypeDef status = HAL_OK;
   5259          
   5260            /* Process locked */
   5261            __HAL_LOCK(htim);
   5262          
   5263            if (htim->State == HAL_TIM_STATE_READY)
   5264            {
   5265              switch (CallbackID)
   5266              {
   5267                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5268                  htim->Base_MspInitCallback              = HAL_TIM_Base_MspInit;                      /* Legacy weak Base MspInit Callback */
   5269                  break;
   5270          
   5271                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5272                  htim->Base_MspDeInitCallback            = HAL_TIM_Base_MspDeInit;                    /* Legacy weak Base Msp DeInit Callback */
   5273                  break;
   5274          
   5275                case HAL_TIM_IC_MSPINIT_CB_ID :
   5276                  htim->IC_MspInitCallback                = HAL_TIM_IC_MspInit;                        /* Legacy weak IC Msp Init Callback */
   5277                  break;
   5278          
   5279                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5280                  htim->IC_MspDeInitCallback              = HAL_TIM_IC_MspDeInit;                      /* Legacy weak IC Msp DeInit Callback */
   5281                  break;
   5282          
   5283                case HAL_TIM_OC_MSPINIT_CB_ID :
   5284                  htim->OC_MspInitCallback                = HAL_TIM_OC_MspInit;                        /* Legacy weak OC Msp Init Callback */
   5285                  break;
   5286          
   5287                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5288                  htim->OC_MspDeInitCallback              = HAL_TIM_OC_MspDeInit;                      /* Legacy weak OC Msp DeInit Callback */
   5289                  break;
   5290          
   5291                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5292                  htim->PWM_MspInitCallback               = HAL_TIM_PWM_MspInit;                       /* Legacy weak PWM Msp Init Callback */
   5293                  break;
   5294          
   5295                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5296                  htim->PWM_MspDeInitCallback             = HAL_TIM_PWM_MspDeInit;                     /* Legacy weak PWM Msp DeInit Callback */
   5297                  break;
   5298          
   5299                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5300                  htim->OnePulse_MspInitCallback          = HAL_TIM_OnePulse_MspInit;                  /* Legacy weak One Pulse Msp Init Callback */
   5301                  break;
   5302          
   5303                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5304                  htim->OnePulse_MspDeInitCallback        = HAL_TIM_OnePulse_MspDeInit;                /* Legacy weak One Pulse Msp DeInit Callback */
   5305                  break;
   5306          
   5307                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5308                  htim->Encoder_MspInitCallback           = HAL_TIM_Encoder_MspInit;                   /* Legacy weak Encoder Msp Init Callback */
   5309                  break;
   5310          
   5311                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5312                  htim->Encoder_MspDeInitCallback         = HAL_TIM_Encoder_MspDeInit;                 /* Legacy weak Encoder Msp DeInit Callback */
   5313                  break;
   5314          
   5315                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5316                  htim->HallSensor_MspInitCallback        = HAL_TIMEx_HallSensor_MspInit;              /* Legacy weak Hall Sensor Msp Init Callback */
   5317                  break;
   5318          
   5319                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5320                  htim->HallSensor_MspDeInitCallback      = HAL_TIMEx_HallSensor_MspDeInit;            /* Legacy weak Hall Sensor Msp DeInit Callback */
   5321                  break;
   5322          
   5323                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   5324                  htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak Period Elapsed Callback */
   5325                  break;
   5326          
   5327                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   5328                  htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak Period Elapsed half complete Callback */
   5329                  break;
   5330          
   5331                case HAL_TIM_TRIGGER_CB_ID :
   5332                  htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak Trigger Callback */
   5333                  break;
   5334          
   5335                case HAL_TIM_TRIGGER_HALF_CB_ID :
   5336                  htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak Trigger half complete Callback */
   5337                  break;
   5338          
   5339                case HAL_TIM_IC_CAPTURE_CB_ID :
   5340                  htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC Capture Callback */
   5341                  break;
   5342          
   5343                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   5344                  htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC Capture half complete Callback */
   5345                  break;
   5346          
   5347                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   5348                  htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC Delay Elapsed Callback */
   5349                  break;
   5350          
   5351                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   5352                  htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM Pulse Finished Callback */
   5353                  break;
   5354          
   5355                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   5356                  htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM Pulse Finished half complete Callback */
   5357                  break;
   5358          
   5359                case HAL_TIM_ERROR_CB_ID :
   5360                  htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak Error Callback */
   5361                  break;
   5362          
   5363                case HAL_TIM_COMMUTATION_CB_ID :
   5364                  htim->CommutationCallback               = HAL_TIMEx_CommutCallback;                  /* Legacy weak Commutation Callback */
   5365                  break;
   5366          
   5367                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   5368                  htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;          /* Legacy weak Commutation half complete Callback */
   5369                  break;
   5370          
   5371                case HAL_TIM_BREAK_CB_ID :
   5372                  htim->BreakCallback                     = HAL_TIMEx_BreakCallback;                   /* Legacy weak Break Callback */
   5373                  break;
   5374          
   5375                default :
   5376                  /* Return error status */
   5377                  status =  HAL_ERROR;
   5378                  break;
   5379              }
   5380            }
   5381            else if (htim->State == HAL_TIM_STATE_RESET)
   5382            {
   5383              switch (CallbackID)
   5384              {
   5385                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5386                  htim->Base_MspInitCallback         = HAL_TIM_Base_MspInit;              /* Legacy weak Base MspInit Callback */
   5387                  break;
   5388          
   5389                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5390                  htim->Base_MspDeInitCallback       = HAL_TIM_Base_MspDeInit;            /* Legacy weak Base Msp DeInit Callback */
   5391                  break;
   5392          
   5393                case HAL_TIM_IC_MSPINIT_CB_ID :
   5394                  htim->IC_MspInitCallback           = HAL_TIM_IC_MspInit;                /* Legacy weak IC Msp Init Callback */
   5395                  break;
   5396          
   5397                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5398                  htim->IC_MspDeInitCallback         = HAL_TIM_IC_MspDeInit;              /* Legacy weak IC Msp DeInit Callback */
   5399                  break;
   5400          
   5401                case HAL_TIM_OC_MSPINIT_CB_ID :
   5402                  htim->OC_MspInitCallback           = HAL_TIM_OC_MspInit;                /* Legacy weak OC Msp Init Callback */
   5403                  break;
   5404          
   5405                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5406                  htim->OC_MspDeInitCallback         = HAL_TIM_OC_MspDeInit;              /* Legacy weak OC Msp DeInit Callback */
   5407                  break;
   5408          
   5409                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5410                  htim->PWM_MspInitCallback          = HAL_TIM_PWM_MspInit;               /* Legacy weak PWM Msp Init Callback */
   5411                  break;
   5412          
   5413                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5414                  htim->PWM_MspDeInitCallback        = HAL_TIM_PWM_MspDeInit;             /* Legacy weak PWM Msp DeInit Callback */
   5415                  break;
   5416          
   5417                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5418                  htim->OnePulse_MspInitCallback     = HAL_TIM_OnePulse_MspInit;          /* Legacy weak One Pulse Msp Init Callback */
   5419                  break;
   5420          
   5421                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5422                  htim->OnePulse_MspDeInitCallback   = HAL_TIM_OnePulse_MspDeInit;        /* Legacy weak One Pulse Msp DeInit Callback */
   5423                  break;
   5424          
   5425                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5426                  htim->Encoder_MspInitCallback      = HAL_TIM_Encoder_MspInit;           /* Legacy weak Encoder Msp Init Callback */
   5427                  break;
   5428          
   5429                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5430                  htim->Encoder_MspDeInitCallback    = HAL_TIM_Encoder_MspDeInit;         /* Legacy weak Encoder Msp DeInit Callback */
   5431                  break;
   5432          
   5433                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5434                  htim->HallSensor_MspInitCallback   = HAL_TIMEx_HallSensor_MspInit;      /* Legacy weak Hall Sensor Msp Init Callback */
   5435                  break;
   5436          
   5437                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5438                  htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;    /* Legacy weak Hall Sensor Msp DeInit Callback */
   5439                  break;
   5440          
   5441                default :
   5442                  /* Return error status */
   5443                  status =  HAL_ERROR;
   5444                  break;
   5445              }
   5446            }
   5447            else
   5448            {
   5449              /* Return error status */
   5450              status =  HAL_ERROR;
   5451            }
   5452          
   5453            /* Release Lock */
   5454            __HAL_UNLOCK(htim);
   5455          
   5456            return status;
   5457          }
   5458          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5459          
   5460          /**
   5461            * @}
   5462            */
   5463          
   5464          /** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
   5465            *  @brief   TIM Peripheral State functions
   5466            *
   5467          @verbatim
   5468            ==============================================================================
   5469                                  ##### Peripheral State functions #####
   5470            ==============================================================================
   5471              [..]
   5472              This subsection permits to get in run-time the status of the peripheral
   5473              and the data flow.
   5474          
   5475          @endverbatim
   5476            * @{
   5477            */
   5478          
   5479          /**
   5480            * @brief  Return the TIM Base handle state.
   5481            * @param  htim TIM Base handle
   5482            * @retval HAL state
   5483            */
   5484          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   5485          {
   5486            return htim->State;
   5487          }
   5488          
   5489          /**
   5490            * @brief  Return the TIM OC handle state.
   5491            * @param  htim TIM Output Compare handle
   5492            * @retval HAL state
   5493            */
   5494          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   5495          {
   5496            return htim->State;
   5497          }
   5498          
   5499          /**
   5500            * @brief  Return the TIM PWM handle state.
   5501            * @param  htim TIM handle
   5502            * @retval HAL state
   5503            */
   5504          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   5505          {
   5506            return htim->State;
   5507          }
   5508          
   5509          /**
   5510            * @brief  Return the TIM Input Capture handle state.
   5511            * @param  htim TIM IC handle
   5512            * @retval HAL state
   5513            */
   5514          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   5515          {
   5516            return htim->State;
   5517          }
   5518          
   5519          /**
   5520            * @brief  Return the TIM One Pulse Mode handle state.
   5521            * @param  htim TIM OPM handle
   5522            * @retval HAL state
   5523            */
   5524          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   5525          {
   5526            return htim->State;
   5527          }
   5528          
   5529          /**
   5530            * @brief  Return the TIM Encoder Mode handle state.
   5531            * @param  htim TIM Encoder Interface handle
   5532            * @retval HAL state
   5533            */
   5534          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   5535          {
   5536            return htim->State;
   5537          }
   5538          
   5539          /**
   5540            * @}
   5541            */
   5542          
   5543          /**
   5544            * @}
   5545            */
   5546          
   5547          /** @defgroup TIM_Private_Functions TIM Private Functions
   5548            * @{
   5549            */
   5550          
   5551          /**
   5552            * @brief  TIM DMA error callback
   5553            * @param  hdma pointer to DMA handle.
   5554            * @retval None
   5555            */
   5556          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   5557          {
   5558            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5559          
   5560            htim->State = HAL_TIM_STATE_READY;
   5561          
   5562          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5563            htim->ErrorCallback(htim);
   5564          #else
   5565            HAL_TIM_ErrorCallback(htim);
   5566          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5567          }
   5568          
   5569          /**
   5570            * @brief  TIM DMA Delay Pulse complete callback.
   5571            * @param  hdma pointer to DMA handle.
   5572            * @retval None
   5573            */
   5574          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   5575          {
   5576            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5577          
   5578            htim->State = HAL_TIM_STATE_READY;
   5579          
   5580            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   5581            {
   5582              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   5583            }
   5584            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   5585            {
   5586              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   5587            }
   5588            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   5589            {
   5590              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   5591            }
   5592            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   5593            {
   5594              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   5595            }
   5596            else
   5597            {
   5598              /* nothing to do */
   5599            }
   5600          
   5601          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5602            htim->PWM_PulseFinishedCallback(htim);
   5603          #else
   5604            HAL_TIM_PWM_PulseFinishedCallback(htim);
   5605          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5606          
   5607            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   5608          }
   5609          
   5610          /**
   5611            * @brief  TIM DMA Delay Pulse half complete callback.
   5612            * @param  hdma pointer to DMA handle.
   5613            * @retval None
   5614            */
   5615          void TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)
   5616          {
   5617            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5618          
   5619            htim->State = HAL_TIM_STATE_READY;
   5620          
   5621            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   5622            {
   5623              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   5624            }
   5625            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   5626            {
   5627              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   5628            }
   5629            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   5630            {
   5631              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   5632            }
   5633            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   5634            {
   5635              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   5636            }
   5637            else
   5638            {
   5639              /* nothing to do */
   5640            }
   5641          
   5642          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5643            htim->PWM_PulseFinishedHalfCpltCallback(htim);
   5644          #else
   5645            HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
   5646          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5647          
   5648            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   5649          }
   5650          
   5651          /**
   5652            * @brief  TIM DMA Capture complete callback.
   5653            * @param  hdma pointer to DMA handle.
   5654            * @retval None
   5655            */
   5656          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   5657          {
   5658            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5659          
   5660            htim->State = HAL_TIM_STATE_READY;
   5661          
   5662            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   5663            {
   5664              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   5665            }
   5666            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   5667            {
   5668              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   5669            }
   5670            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   5671            {
   5672              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   5673            }
   5674            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   5675            {
   5676              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   5677            }
   5678            else
   5679            {
   5680              /* nothing to do */
   5681            }
   5682          
   5683          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5684            htim->IC_CaptureCallback(htim);
   5685          #else
   5686            HAL_TIM_IC_CaptureCallback(htim);
   5687          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5688          
   5689            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   5690          }
   5691          
   5692          /**
   5693            * @brief  TIM DMA Capture half complete callback.
   5694            * @param  hdma pointer to DMA handle.
   5695            * @retval None
   5696            */
   5697          void TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)
   5698          {
   5699            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5700          
   5701            htim->State = HAL_TIM_STATE_READY;
   5702          
   5703            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   5704            {
   5705              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   5706            }
   5707            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   5708            {
   5709              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   5710            }
   5711            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   5712            {
   5713              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   5714            }
   5715            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   5716            {
   5717              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   5718            }
   5719            else
   5720            {
   5721              /* nothing to do */
   5722            }
   5723          
   5724          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5725            htim->IC_CaptureHalfCpltCallback(htim);
   5726          #else
   5727            HAL_TIM_IC_CaptureHalfCpltCallback(htim);
   5728          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5729          
   5730            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   5731          }
   5732          
   5733          /**
   5734            * @brief  TIM DMA Period Elapse complete callback.
   5735            * @param  hdma pointer to DMA handle.
   5736            * @retval None
   5737            */
   5738          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   5739          {
   5740            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5741          
   5742            htim->State = HAL_TIM_STATE_READY;
   5743          
   5744          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5745            htim->PeriodElapsedCallback(htim);
   5746          #else
   5747            HAL_TIM_PeriodElapsedCallback(htim);
   5748          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5749          }
   5750          
   5751          /**
   5752            * @brief  TIM DMA Period Elapse half complete callback.
   5753            * @param  hdma pointer to DMA handle.
   5754            * @retval None
   5755            */
   5756          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)
   5757          {
   5758            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5759          
   5760            htim->State = HAL_TIM_STATE_READY;
   5761          
   5762          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5763            htim->PeriodElapsedHalfCpltCallback(htim);
   5764          #else
   5765            HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
   5766          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5767          }
   5768          
   5769          /**
   5770            * @brief  TIM DMA Trigger callback.
   5771            * @param  hdma pointer to DMA handle.
   5772            * @retval None
   5773            */
   5774          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   5775          {
   5776            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5777          
   5778            htim->State = HAL_TIM_STATE_READY;
   5779          
   5780          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5781            htim->TriggerCallback(htim);
   5782          #else
   5783            HAL_TIM_TriggerCallback(htim);
   5784          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5785          }
   5786          
   5787          /**
   5788            * @brief  TIM DMA Trigger half complete callback.
   5789            * @param  hdma pointer to DMA handle.
   5790            * @retval None
   5791            */
   5792          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)
   5793          {
   5794            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5795          
   5796            htim->State = HAL_TIM_STATE_READY;
   5797          
   5798          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5799            htim->TriggerHalfCpltCallback(htim);
   5800          #else
   5801            HAL_TIM_TriggerHalfCpltCallback(htim);
   5802          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5803          }
   5804          
   5805          /**
   5806            * @brief  Time Base configuration
   5807            * @param  TIMx TIM peripheral
   5808            * @param  Structure TIM Base configuration structure
   5809            * @retval None
   5810            */
   5811          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   5812          {
   5813            uint32_t tmpcr1;
   5814            tmpcr1 = TIMx->CR1;
   5815          
   5816            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   5817            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   5818            {
   5819              /* Select the Counter Mode */
   5820              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   5821              tmpcr1 |= Structure->CounterMode;
   5822            }
   5823          
   5824            if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   5825            {
   5826              /* Set the clock division */
   5827              tmpcr1 &= ~TIM_CR1_CKD;
   5828              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   5829            }
   5830          
   5831            /* Set the auto-reload preload */
   5832            MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   5833          
   5834            TIMx->CR1 = tmpcr1;
   5835          
   5836            /* Set the Autoreload value */
   5837            TIMx->ARR = (uint32_t)Structure->Period ;
   5838          
   5839            /* Set the Prescaler value */
   5840            TIMx->PSC = Structure->Prescaler;
   5841          
   5842            if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   5843            {
   5844              /* Set the Repetition Counter value */
   5845              TIMx->RCR = Structure->RepetitionCounter;
   5846            }
   5847          
   5848            /* Generate an update event to reload the Prescaler
   5849               and the repetition counter (only for advanced timer) value immediately */
   5850            TIMx->EGR = TIM_EGR_UG;
   5851          }
   5852          
   5853          /**
   5854            * @brief  Timer Output Compare 1 configuration
   5855            * @param  TIMx to select the TIM peripheral
   5856            * @param  OC_Config The ouput configuration structure
   5857            * @retval None
   5858            */
   5859          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   5860          {
   5861            uint32_t tmpccmrx;
   5862            uint32_t tmpccer;
   5863            uint32_t tmpcr2;
   5864          
   5865            /* Disable the Channel 1: Reset the CC1E Bit */
   5866            TIMx->CCER &= ~TIM_CCER_CC1E;
   5867          
   5868            /* Get the TIMx CCER register value */
   5869            tmpccer = TIMx->CCER;
   5870            /* Get the TIMx CR2 register value */
   5871            tmpcr2 =  TIMx->CR2;
   5872          
   5873            /* Get the TIMx CCMR1 register value */
   5874            tmpccmrx = TIMx->CCMR1;
   5875          
   5876            /* Reset the Output Compare Mode Bits */
   5877            tmpccmrx &= ~TIM_CCMR1_OC1M;
   5878            tmpccmrx &= ~TIM_CCMR1_CC1S;
   5879            /* Select the Output Compare Mode */
   5880            tmpccmrx |= OC_Config->OCMode;
   5881          
   5882            /* Reset the Output Polarity level */
   5883            tmpccer &= ~TIM_CCER_CC1P;
   5884            /* Set the Output Compare Polarity */
   5885            tmpccer |= OC_Config->OCPolarity;
   5886          
   5887            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   5888            {
   5889              /* Check parameters */
   5890              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   5891          
   5892              /* Reset the Output N Polarity level */
   5893              tmpccer &= ~TIM_CCER_CC1NP;
   5894              /* Set the Output N Polarity */
   5895              tmpccer |= OC_Config->OCNPolarity;
   5896              /* Reset the Output N State */
   5897              tmpccer &= ~TIM_CCER_CC1NE;
   5898            }
   5899          
   5900            if (IS_TIM_BREAK_INSTANCE(TIMx))
   5901            {
   5902              /* Check parameters */
   5903              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   5904              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   5905          
   5906              /* Reset the Output Compare and Output Compare N IDLE State */
   5907              tmpcr2 &= ~TIM_CR2_OIS1;
   5908              tmpcr2 &= ~TIM_CR2_OIS1N;
   5909              /* Set the Output Idle state */
   5910              tmpcr2 |= OC_Config->OCIdleState;
   5911              /* Set the Output N Idle state */
   5912              tmpcr2 |= OC_Config->OCNIdleState;
   5913            }
   5914          
   5915            /* Write to TIMx CR2 */
   5916            TIMx->CR2 = tmpcr2;
   5917          
   5918            /* Write to TIMx CCMR1 */
   5919            TIMx->CCMR1 = tmpccmrx;
   5920          
   5921            /* Set the Capture Compare Register value */
   5922            TIMx->CCR1 = OC_Config->Pulse;
   5923          
   5924            /* Write to TIMx CCER */
   5925            TIMx->CCER = tmpccer;
   5926          }
   5927          
   5928          /**
   5929            * @brief  Timer Output Compare 2 configuration
   5930            * @param  TIMx to select the TIM peripheral
   5931            * @param  OC_Config The ouput configuration structure
   5932            * @retval None
   5933            */
   5934          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   5935          {
   5936            uint32_t tmpccmrx;
   5937            uint32_t tmpccer;
   5938            uint32_t tmpcr2;
   5939          
   5940            /* Disable the Channel 2: Reset the CC2E Bit */
   5941            TIMx->CCER &= ~TIM_CCER_CC2E;
   5942          
   5943            /* Get the TIMx CCER register value */
   5944            tmpccer = TIMx->CCER;
   5945            /* Get the TIMx CR2 register value */
   5946            tmpcr2 =  TIMx->CR2;
   5947          
   5948            /* Get the TIMx CCMR1 register value */
   5949            tmpccmrx = TIMx->CCMR1;
   5950          
   5951            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   5952            tmpccmrx &= ~TIM_CCMR1_OC2M;
   5953            tmpccmrx &= ~TIM_CCMR1_CC2S;
   5954          
   5955            /* Select the Output Compare Mode */
   5956            tmpccmrx |= (OC_Config->OCMode << 8U);
   5957          
   5958            /* Reset the Output Polarity level */
   5959            tmpccer &= ~TIM_CCER_CC2P;
   5960            /* Set the Output Compare Polarity */
   5961            tmpccer |= (OC_Config->OCPolarity << 4U);
   5962          
   5963            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   5964            {
   5965              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   5966          
   5967              /* Reset the Output N Polarity level */
   5968              tmpccer &= ~TIM_CCER_CC2NP;
   5969              /* Set the Output N Polarity */
   5970              tmpccer |= (OC_Config->OCNPolarity << 4U);
   5971              /* Reset the Output N State */
   5972              tmpccer &= ~TIM_CCER_CC2NE;
   5973          
   5974            }
   5975          
   5976            if (IS_TIM_BREAK_INSTANCE(TIMx))
   5977            {
   5978              /* Check parameters */
   5979              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   5980              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   5981          
   5982              /* Reset the Output Compare and Output Compare N IDLE State */
   5983              tmpcr2 &= ~TIM_CR2_OIS2;
   5984              tmpcr2 &= ~TIM_CR2_OIS2N;
   5985              /* Set the Output Idle state */
   5986              tmpcr2 |= (OC_Config->OCIdleState << 2U);
   5987              /* Set the Output N Idle state */
   5988              tmpcr2 |= (OC_Config->OCNIdleState << 2U);
   5989            }
   5990          
   5991            /* Write to TIMx CR2 */
   5992            TIMx->CR2 = tmpcr2;
   5993          
   5994            /* Write to TIMx CCMR1 */
   5995            TIMx->CCMR1 = tmpccmrx;
   5996          
   5997            /* Set the Capture Compare Register value */
   5998            TIMx->CCR2 = OC_Config->Pulse;
   5999          
   6000            /* Write to TIMx CCER */
   6001            TIMx->CCER = tmpccer;
   6002          }
   6003          
   6004          /**
   6005            * @brief  Timer Output Compare 3 configuration
   6006            * @param  TIMx to select the TIM peripheral
   6007            * @param  OC_Config The ouput configuration structure
   6008            * @retval None
   6009            */
   6010          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6011          {
   6012            uint32_t tmpccmrx;
   6013            uint32_t tmpccer;
   6014            uint32_t tmpcr2;
   6015          
   6016            /* Disable the Channel 3: Reset the CC2E Bit */
   6017            TIMx->CCER &= ~TIM_CCER_CC3E;
   6018          
   6019            /* Get the TIMx CCER register value */
   6020            tmpccer = TIMx->CCER;
   6021            /* Get the TIMx CR2 register value */
   6022            tmpcr2 =  TIMx->CR2;
   6023          
   6024            /* Get the TIMx CCMR2 register value */
   6025            tmpccmrx = TIMx->CCMR2;
   6026          
   6027            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6028            tmpccmrx &= ~TIM_CCMR2_OC3M;
   6029            tmpccmrx &= ~TIM_CCMR2_CC3S;
   6030            /* Select the Output Compare Mode */
   6031            tmpccmrx |= OC_Config->OCMode;
   6032          
   6033            /* Reset the Output Polarity level */
   6034            tmpccer &= ~TIM_CCER_CC3P;
   6035            /* Set the Output Compare Polarity */
   6036            tmpccer |= (OC_Config->OCPolarity << 8U);
   6037          
   6038            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   6039            {
   6040              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   6041          
   6042              /* Reset the Output N Polarity level */
   6043              tmpccer &= ~TIM_CCER_CC3NP;
   6044              /* Set the Output N Polarity */
   6045              tmpccer |= (OC_Config->OCNPolarity << 8U);
   6046              /* Reset the Output N State */
   6047              tmpccer &= ~TIM_CCER_CC3NE;
   6048            }
   6049          
   6050            if (IS_TIM_BREAK_INSTANCE(TIMx))
   6051            {
   6052              /* Check parameters */
   6053              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   6054              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6055          
   6056              /* Reset the Output Compare and Output Compare N IDLE State */
   6057              tmpcr2 &= ~TIM_CR2_OIS3;
   6058              tmpcr2 &= ~TIM_CR2_OIS3N;
   6059              /* Set the Output Idle state */
   6060              tmpcr2 |= (OC_Config->OCIdleState << 4U);
   6061              /* Set the Output N Idle state */
   6062              tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   6063            }
   6064          
   6065            /* Write to TIMx CR2 */
   6066            TIMx->CR2 = tmpcr2;
   6067          
   6068            /* Write to TIMx CCMR2 */
   6069            TIMx->CCMR2 = tmpccmrx;
   6070          
   6071            /* Set the Capture Compare Register value */
   6072            TIMx->CCR3 = OC_Config->Pulse;
   6073          
   6074            /* Write to TIMx CCER */
   6075            TIMx->CCER = tmpccer;
   6076          }
   6077          
   6078          /**
   6079            * @brief  Timer Output Compare 4 configuration
   6080            * @param  TIMx to select the TIM peripheral
   6081            * @param  OC_Config The ouput configuration structure
   6082            * @retval None
   6083            */
   6084          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6085          {
   6086            uint32_t tmpccmrx;
   6087            uint32_t tmpccer;
   6088            uint32_t tmpcr2;
   6089          
   6090            /* Disable the Channel 4: Reset the CC4E Bit */
   6091            TIMx->CCER &= ~TIM_CCER_CC4E;
   6092          
   6093            /* Get the TIMx CCER register value */
   6094            tmpccer = TIMx->CCER;
   6095            /* Get the TIMx CR2 register value */
   6096            tmpcr2 =  TIMx->CR2;
   6097          
   6098            /* Get the TIMx CCMR2 register value */
   6099            tmpccmrx = TIMx->CCMR2;
   6100          
   6101            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6102            tmpccmrx &= ~TIM_CCMR2_OC4M;
   6103            tmpccmrx &= ~TIM_CCMR2_CC4S;
   6104          
   6105            /* Select the Output Compare Mode */
   6106            tmpccmrx |= (OC_Config->OCMode << 8U);
   6107          
   6108            /* Reset the Output Polarity level */
   6109            tmpccer &= ~TIM_CCER_CC4P;
   6110            /* Set the Output Compare Polarity */
   6111            tmpccer |= (OC_Config->OCPolarity << 12U);
   6112          
   6113            if (IS_TIM_BREAK_INSTANCE(TIMx))
   6114            {
   6115              /* Check parameters */
   6116              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6117          
   6118              /* Reset the Output Compare IDLE State */
   6119              tmpcr2 &= ~TIM_CR2_OIS4;
   6120          
   6121              /* Set the Output Idle state */
   6122              tmpcr2 |= (OC_Config->OCIdleState << 6U);
   6123            }
   6124          
   6125            /* Write to TIMx CR2 */
   6126            TIMx->CR2 = tmpcr2;
   6127          
   6128            /* Write to TIMx CCMR2 */
   6129            TIMx->CCMR2 = tmpccmrx;
   6130          
   6131            /* Set the Capture Compare Register value */
   6132            TIMx->CCR4 = OC_Config->Pulse;
   6133          
   6134            /* Write to TIMx CCER */
   6135            TIMx->CCER = tmpccer;
   6136          }
   6137          
   6138          /**
   6139            * @brief  Slave Timer configuration function
   6140            * @param  htim TIM handle
   6141            * @param  sSlaveConfig Slave timer configuration
   6142            * @retval None
   6143            */
   6144          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   6145                                                            TIM_SlaveConfigTypeDef *sSlaveConfig)
   6146          {
   6147            uint32_t tmpsmcr;
   6148            uint32_t tmpccmr1;
   6149            uint32_t tmpccer;
   6150          
   6151            /* Get the TIMx SMCR register value */
   6152            tmpsmcr = htim->Instance->SMCR;
   6153          
   6154            /* Reset the Trigger Selection Bits */
   6155            tmpsmcr &= ~TIM_SMCR_TS;
   6156            /* Set the Input Trigger source */
   6157            tmpsmcr |= sSlaveConfig->InputTrigger;
   6158          
   6159            /* Reset the slave mode Bits */
   6160            tmpsmcr &= ~TIM_SMCR_SMS;
   6161            /* Set the slave mode */
   6162            tmpsmcr |= sSlaveConfig->SlaveMode;
   6163          
   6164            /* Write to TIMx SMCR */
   6165            htim->Instance->SMCR = tmpsmcr;
   6166          
   6167            /* Configure the trigger prescaler, filter, and polarity */
   6168            switch (sSlaveConfig->InputTrigger)
   6169            {
   6170              case TIM_TS_ETRF:
   6171              {
   6172                /* Check the parameters */
   6173                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   6174                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   6175                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6176                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6177                /* Configure the ETR Trigger source */
   6178                TIM_ETR_SetConfig(htim->Instance,
   6179                                  sSlaveConfig->TriggerPrescaler,
   6180                                  sSlaveConfig->TriggerPolarity,
   6181                                  sSlaveConfig->TriggerFilter);
   6182                break;
   6183              }
   6184          
   6185              case TIM_TS_TI1F_ED:
   6186              {
   6187                /* Check the parameters */
   6188                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   6189                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6190          
   6191                if(sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
   6192                {
   6193                  return HAL_ERROR;
   6194                }
   6195          
   6196                /* Disable the Channel 1: Reset the CC1E Bit */
   6197                tmpccer = htim->Instance->CCER;
   6198                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   6199                tmpccmr1 = htim->Instance->CCMR1;
   6200          
   6201                /* Set the filter */
   6202                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   6203                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
   6204          
   6205                /* Write to TIMx CCMR1 and CCER registers */
   6206                htim->Instance->CCMR1 = tmpccmr1;
   6207                htim->Instance->CCER = tmpccer;
   6208                break;
   6209              }
   6210          
   6211              case TIM_TS_TI1FP1:
   6212              {
   6213                /* Check the parameters */
   6214                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   6215                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6216                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6217          
   6218                /* Configure TI1 Filter and Polarity */
   6219                TIM_TI1_ConfigInputStage(htim->Instance,
   6220                                         sSlaveConfig->TriggerPolarity,
   6221                                         sSlaveConfig->TriggerFilter);
   6222                break;
   6223              }
   6224          
   6225              case TIM_TS_TI2FP2:
   6226              {
   6227                /* Check the parameters */
   6228                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   6229                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6230                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6231          
   6232                /* Configure TI2 Filter and Polarity */
   6233                TIM_TI2_ConfigInputStage(htim->Instance,
   6234                                         sSlaveConfig->TriggerPolarity,
   6235                                         sSlaveConfig->TriggerFilter);
   6236                break;
   6237              }
   6238          
   6239              case TIM_TS_ITR0:
   6240              case TIM_TS_ITR1:
   6241              case TIM_TS_ITR2:
   6242              case TIM_TS_ITR3:
   6243              {
   6244                /* Check the parameter */
   6245                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   6246                break;
   6247              }
   6248          
   6249              default:
   6250                break;
   6251            }
   6252            return HAL_OK;
   6253          }
   6254          
   6255          /**
   6256            * @brief  Configure the TI1 as Input.
   6257            * @param  TIMx to select the TIM peripheral.
   6258            * @param  TIM_ICPolarity The Input Polarity.
   6259            *          This parameter can be one of the following values:
   6260            *            @arg TIM_ICPOLARITY_RISING
   6261            *            @arg TIM_ICPOLARITY_FALLING
   6262            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6263            * @param  TIM_ICSelection specifies the input to be used.
   6264            *          This parameter can be one of the following values:
   6265            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.
   6266            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.
   6267            *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.
   6268            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6269            *          This parameter must be a value between 0x00 and 0x0F.
   6270            * @retval None
   6271            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1
   6272            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be
   6273            *        protected against un-initialized filter and polarity values.
   6274            */
   6275          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6276                                 uint32_t TIM_ICFilter)
   6277          {
   6278            uint32_t tmpccmr1;
   6279            uint32_t tmpccer;
   6280          
   6281            /* Disable the Channel 1: Reset the CC1E Bit */
   6282            TIMx->CCER &= ~TIM_CCER_CC1E;
   6283            tmpccmr1 = TIMx->CCMR1;
   6284            tmpccer = TIMx->CCER;
   6285          
   6286            /* Select the Input */
   6287            if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   6288            {
   6289              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   6290              tmpccmr1 |= TIM_ICSelection;
   6291            }
   6292            else
   6293            {
   6294              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   6295            }
   6296          
   6297            /* Set the filter */
   6298            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   6299            tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
   6300          
   6301            /* Select the Polarity and set the CC1E Bit */
   6302            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   6303            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   6304          
   6305            /* Write to TIMx CCMR1 and CCER registers */
   6306            TIMx->CCMR1 = tmpccmr1;
   6307            TIMx->CCER = tmpccer;
   6308          }
   6309          
   6310          /**
   6311            * @brief  Configure the Polarity and Filter for TI1.
   6312            * @param  TIMx to select the TIM peripheral.
   6313            * @param  TIM_ICPolarity The Input Polarity.
   6314            *          This parameter can be one of the following values:
   6315            *            @arg TIM_ICPOLARITY_RISING
   6316            *            @arg TIM_ICPOLARITY_FALLING
   6317            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6318            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6319            *          This parameter must be a value between 0x00 and 0x0F.
   6320            * @retval None
   6321            */
   6322          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   6323          {
   6324            uint32_t tmpccmr1;
   6325            uint32_t tmpccer;
   6326          
   6327            /* Disable the Channel 1: Reset the CC1E Bit */
   6328            tmpccer = TIMx->CCER;
   6329            TIMx->CCER &= ~TIM_CCER_CC1E;
   6330            tmpccmr1 = TIMx->CCMR1;
   6331          
   6332            /* Set the filter */
   6333            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   6334            tmpccmr1 |= (TIM_ICFilter << 4U);
   6335          
   6336            /* Select the Polarity and set the CC1E Bit */
   6337            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   6338            tmpccer |= TIM_ICPolarity;
   6339          
   6340            /* Write to TIMx CCMR1 and CCER registers */
   6341            TIMx->CCMR1 = tmpccmr1;
   6342            TIMx->CCER = tmpccer;
   6343          }
   6344          
   6345          /**
   6346            * @brief  Configure the TI2 as Input.
   6347            * @param  TIMx to select the TIM peripheral
   6348            * @param  TIM_ICPolarity The Input Polarity.
   6349            *          This parameter can be one of the following values:
   6350            *            @arg TIM_ICPOLARITY_RISING
   6351            *            @arg TIM_ICPOLARITY_FALLING
   6352            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6353            * @param  TIM_ICSelection specifies the input to be used.
   6354            *          This parameter can be one of the following values:
   6355            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.
   6356            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
   6357            *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.
   6358            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6359            *          This parameter must be a value between 0x00 and 0x0F.
   6360            * @retval None
   6361            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2
   6362            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
   6363            *        protected against un-initialized filter and polarity values.
   6364            */
   6365          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6366                                        uint32_t TIM_ICFilter)
   6367          {
   6368            uint32_t tmpccmr1;
   6369            uint32_t tmpccer;
   6370          
   6371            /* Disable the Channel 2: Reset the CC2E Bit */
   6372            TIMx->CCER &= ~TIM_CCER_CC2E;
   6373            tmpccmr1 = TIMx->CCMR1;
   6374            tmpccer = TIMx->CCER;
   6375          
   6376            /* Select the Input */
   6377            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   6378            tmpccmr1 |= (TIM_ICSelection << 8U);
   6379          
   6380            /* Set the filter */
   6381            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   6382            tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
   6383          
   6384            /* Select the Polarity and set the CC2E Bit */
   6385            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   6386            tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   6387          
   6388            /* Write to TIMx CCMR1 and CCER registers */
   6389            TIMx->CCMR1 = tmpccmr1 ;
   6390            TIMx->CCER = tmpccer;
   6391          }
   6392          
   6393          /**
   6394            * @brief  Configure the Polarity and Filter for TI2.
   6395            * @param  TIMx to select the TIM peripheral.
   6396            * @param  TIM_ICPolarity The Input Polarity.
   6397            *          This parameter can be one of the following values:
   6398            *            @arg TIM_ICPOLARITY_RISING
   6399            *            @arg TIM_ICPOLARITY_FALLING
   6400            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6401            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6402            *          This parameter must be a value between 0x00 and 0x0F.
   6403            * @retval None
   6404            */
   6405          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   6406          {
   6407            uint32_t tmpccmr1;
   6408            uint32_t tmpccer;
   6409          
   6410            /* Disable the Channel 2: Reset the CC2E Bit */
   6411            TIMx->CCER &= ~TIM_CCER_CC2E;
   6412            tmpccmr1 = TIMx->CCMR1;
   6413            tmpccer = TIMx->CCER;
   6414          
   6415            /* Set the filter */
   6416            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   6417            tmpccmr1 |= (TIM_ICFilter << 12U);
   6418          
   6419            /* Select the Polarity and set the CC2E Bit */
   6420            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   6421            tmpccer |= (TIM_ICPolarity << 4U);
   6422          
   6423            /* Write to TIMx CCMR1 and CCER registers */
   6424            TIMx->CCMR1 = tmpccmr1 ;
   6425            TIMx->CCER = tmpccer;
   6426          }
   6427          
   6428          /**
   6429            * @brief  Configure the TI3 as Input.
   6430            * @param  TIMx to select the TIM peripheral
   6431            * @param  TIM_ICPolarity The Input Polarity.
   6432            *          This parameter can be one of the following values:
   6433            *            @arg TIM_ICPOLARITY_RISING
   6434            *            @arg TIM_ICPOLARITY_FALLING
   6435            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6436            * @param  TIM_ICSelection specifies the input to be used.
   6437            *          This parameter can be one of the following values:
   6438            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.
   6439            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
   6440            *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.
   6441            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6442            *          This parameter must be a value between 0x00 and 0x0F.
   6443            * @retval None
   6444            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4
   6445            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6446            *        protected against un-initialized filter and polarity values.
   6447            */
   6448          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6449                                        uint32_t TIM_ICFilter)
   6450          {
   6451            uint32_t tmpccmr2;
   6452            uint32_t tmpccer;
   6453          
   6454            /* Disable the Channel 3: Reset the CC3E Bit */
   6455            TIMx->CCER &= ~TIM_CCER_CC3E;
   6456            tmpccmr2 = TIMx->CCMR2;
   6457            tmpccer = TIMx->CCER;
   6458          
   6459            /* Select the Input */
   6460            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   6461            tmpccmr2 |= TIM_ICSelection;
   6462          
   6463            /* Set the filter */
   6464            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   6465            tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
   6466          
   6467            /* Select the Polarity and set the CC3E Bit */
   6468            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   6469            tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   6470          
   6471            /* Write to TIMx CCMR2 and CCER registers */
   6472            TIMx->CCMR2 = tmpccmr2;
   6473            TIMx->CCER = tmpccer;
   6474          }
   6475          
   6476          /**
   6477            * @brief  Configure the TI4 as Input.
   6478            * @param  TIMx to select the TIM peripheral
   6479            * @param  TIM_ICPolarity The Input Polarity.
   6480            *          This parameter can be one of the following values:
   6481            *            @arg TIM_ICPOLARITY_RISING
   6482            *            @arg TIM_ICPOLARITY_FALLING
   6483            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6484            * @param  TIM_ICSelection specifies the input to be used.
   6485            *          This parameter can be one of the following values:
   6486            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.
   6487            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
   6488            *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.
   6489            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6490            *          This parameter must be a value between 0x00 and 0x0F.
   6491            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3
   6492            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6493            *        protected against un-initialized filter and polarity values.
   6494            * @retval None
   6495            */
   6496          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6497                                        uint32_t TIM_ICFilter)
   6498          {
   6499            uint32_t tmpccmr2;
   6500            uint32_t tmpccer;
   6501          
   6502            /* Disable the Channel 4: Reset the CC4E Bit */
   6503            TIMx->CCER &= ~TIM_CCER_CC4E;
   6504            tmpccmr2 = TIMx->CCMR2;
   6505            tmpccer = TIMx->CCER;
   6506          
   6507            /* Select the Input */
   6508            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   6509            tmpccmr2 |= (TIM_ICSelection << 8U);
   6510          
   6511            /* Set the filter */
   6512            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   6513            tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
   6514          
   6515            /* Select the Polarity and set the CC4E Bit */
   6516            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   6517            tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   6518          
   6519            /* Write to TIMx CCMR2 and CCER registers */
   6520            TIMx->CCMR2 = tmpccmr2;
   6521            TIMx->CCER = tmpccer ;
   6522          }
   6523          
   6524          /**
   6525            * @brief  Selects the Input Trigger source
   6526            * @param  TIMx to select the TIM peripheral
   6527            * @param  InputTriggerSource The Input Trigger source.
   6528            *          This parameter can be one of the following values:
   6529            *            @arg TIM_TS_ITR0: Internal Trigger 0
   6530            *            @arg TIM_TS_ITR1: Internal Trigger 1
   6531            *            @arg TIM_TS_ITR2: Internal Trigger 2
   6532            *            @arg TIM_TS_ITR3: Internal Trigger 3
   6533            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   6534            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   6535            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   6536            *            @arg TIM_TS_ETRF: External Trigger input
   6537            * @retval None
   6538            */
   6539          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
   6540          {
   6541            uint32_t tmpsmcr;
   6542          
   6543            /* Get the TIMx SMCR register value */
   6544            tmpsmcr = TIMx->SMCR;
   6545            /* Reset the TS Bits */
   6546            tmpsmcr &= ~TIM_SMCR_TS;
   6547            /* Set the Input Trigger source and the slave mode*/
   6548            tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   6549            /* Write to TIMx SMCR */
   6550            TIMx->SMCR = tmpsmcr;
   6551          }
   6552          /**
   6553            * @brief  Configures the TIMx External Trigger (ETR).
   6554            * @param  TIMx to select the TIM peripheral
   6555            * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.
   6556            *          This parameter can be one of the following values:
   6557            *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
   6558            *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
   6559            *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
   6560            *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
   6561            * @param  TIM_ExtTRGPolarity The external Trigger Polarity.
   6562            *          This parameter can be one of the following values:
   6563            *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
   6564            *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
   6565            * @param  ExtTRGFilter External Trigger Filter.
   6566            *          This parameter must be a value between 0x00 and 0x0F
   6567            * @retval None
   6568            */
   6569          void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
   6570                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   6571          {
   6572            uint32_t tmpsmcr;
   6573          
   6574            tmpsmcr = TIMx->SMCR;
   6575          
   6576            /* Reset the ETR Bits */
   6577            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   6578          
   6579            /* Set the Prescaler, the Filter value and the Polarity */
   6580            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   6581          
   6582            /* Write to TIMx SMCR */
   6583            TIMx->SMCR = tmpsmcr;
   6584          }
   6585          
   6586          /**
   6587            * @brief  Enables or disables the TIM Capture Compare Channel x.
   6588            * @param  TIMx to select the TIM peripheral
   6589            * @param  Channel specifies the TIM Channel
   6590            *          This parameter can be one of the following values:
   6591            *            @arg TIM_CHANNEL_1: TIM Channel 1
   6592            *            @arg TIM_CHANNEL_2: TIM Channel 2
   6593            *            @arg TIM_CHANNEL_3: TIM Channel 3
   6594            *            @arg TIM_CHANNEL_4: TIM Channel 4
   6595            * @param  ChannelState specifies the TIM Channel CCxE bit new state.
   6596            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
   6597            * @retval None
   6598            */
   6599          void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
   6600          {
   6601            uint32_t tmp;
   6602          
   6603            /* Check the parameters */
   6604            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   6605            assert_param(IS_TIM_CHANNELS(Channel));
   6606          
   6607            tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   6608          
   6609            /* Reset the CCxE Bit */
   6610            TIMx->CCER &= ~tmp;
   6611          
   6612            /* Set or reset the CCxE Bit */
   6613            TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   6614          }
   6615          
   6616          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6617          /**
   6618            * @brief  Reset interrupt callbacks to the legacy weak callbacks.
   6619            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   6620            *                the configuration information for TIM module.
   6621            * @retval None
   6622            */
   6623          void TIM_ResetCallback(TIM_HandleTypeDef *htim)
   6624          {
   6625            /* Reset the TIM callback to the legacy weak callbacks */
   6626            htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak PeriodElapsedCallback             */
   6627            htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak PeriodElapsedHalfCpltCallback     */
   6628            htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak TriggerCallback                   */
   6629            htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak TriggerHalfCpltCallback           */
   6630            htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC_CaptureCallback                */
   6631            htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC_CaptureHalfCpltCallback        */
   6632            htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC_DelayElapsedCallback           */
   6633            htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM_PulseFinishedCallback         */
   6634            htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM_PulseFinishedHalfCpltCallback */
   6635            htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak ErrorCallback                     */
   6636            htim->CommutationCallback               = HAL_TIMEx_CommutCallback;                  /* Legacy weak CommutationCallback               */
   6637            htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;          /* Legacy weak CommutationHalfCpltCallback       */
   6638            htim->BreakCallback                     = HAL_TIMEx_BreakCallback;                   /* Legacy weak BreakCallback                     */
   6639          }
   6640          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6641          
   6642          /**
   6643            * @}
   6644            */
   6645          
   6646          #endif /* HAL_TIM_MODULE_ENABLED */
   6647          /**
   6648            * @}
   6649            */
   6650          
   6651          /**
   6652            * @}
   6653            */
   6654          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/


 
 
 0 bytes of memory

Errors: none
Warnings: none

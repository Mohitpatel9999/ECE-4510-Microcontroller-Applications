###############################################################################
#
# IAR ANSI C/C++ Compiler V8.42.1.233/W32 for ARM         13/Feb/2020  10:18:05
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\mohit\Desktop\Microapps
#        projects\HW4.1\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
#    Command line      =
#        -f C:\Users\mohit\AppData\Local\Temp\EWFC27.tmp
#        ("C:\Users\mohit\Desktop\Microapps
#        projects\HW4.1\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c"
#        -D USE_HAL_DRIVER -D STM32F429xx -lC "C:\Users\mohit\Desktop\Microapps
#        projects\HW4.1\EWARM\HW4.1\List" -o "C:\Users\mohit\Desktop\Microapps
#        projects\HW4.1\EWARM\HW4.1\Obj" --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I "C:\Users\mohit\Desktop\Microapps projects\HW4.1\EWARM/../Inc\" -I
#        "C:\Users\mohit\Desktop\Microapps
#        projects\HW4.1\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\" -I
#        "C:\Users\mohit\Desktop\Microapps
#        projects\HW4.1\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\" -I
#        "C:\Users\mohit\Desktop\Microapps
#        projects\HW4.1\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\" -I
#        "C:\Users\mohit\Desktop\Microapps
#        projects\HW4.1\EWARM/../Drivers/CMSIS/Include\" -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\mohit\Desktop\Microapps
#        projects\HW4.1\EWARM\HW4.1\List\stm32f4xx_hal_tim.lst
#    Object file       =
#        C:\Users\mohit\Desktop\Microapps
#        projects\HW4.1\EWARM\HW4.1\Obj\stm32f4xx_hal_tim.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#      __size_limit    =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Users\mohit\Desktop\Microapps projects\HW4.1\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Timer (TIM) peripheral:
      8            *           + TIM Time Base Initialization
      9            *           + TIM Time Base Start
     10            *           + TIM Time Base Start Interruption
     11            *           + TIM Time Base Start DMA
     12            *           + TIM Output Compare/PWM Initialization
     13            *           + TIM Output Compare/PWM Channel Configuration
     14            *           + TIM Output Compare/PWM  Start
     15            *           + TIM Output Compare/PWM  Start Interruption
     16            *           + TIM Output Compare/PWM Start DMA
     17            *           + TIM Input Capture Initialization
     18            *           + TIM Input Capture Channel Configuration
     19            *           + TIM Input Capture Start
     20            *           + TIM Input Capture Start Interruption
     21            *           + TIM Input Capture Start DMA
     22            *           + TIM One Pulse Initialization
     23            *           + TIM One Pulse Channel Configuration
     24            *           + TIM One Pulse Start
     25            *           + TIM Encoder Interface Initialization
     26            *           + TIM Encoder Interface Start
     27            *           + TIM Encoder Interface Start Interruption
     28            *           + TIM Encoder Interface Start DMA
     29            *           + Commutation Event configuration with Interruption and DMA
     30            *           + TIM OCRef clear configuration
     31            *           + TIM External Clock configuration
     32            @verbatim
     33            ==============================================================================
     34                                ##### TIMER Generic features #####
     35            ==============================================================================
     36            [..] The Timer features include:
     37                 (#) 16-bit up, down, up/down auto-reload counter.
     38                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the
     39                     counter clock frequency either by any factor between 1 and 65536.
     40                 (#) Up to 4 independent channels for:
     41                     (++) Input Capture
     42                     (++) Output Compare
     43                     (++) PWM generation (Edge and Center-aligned Mode)
     44                     (++) One-pulse mode output
     45                 (#) Synchronization circuit to control the timer with external signals and to interconnect
     46                      several timers together.
     47                 (#) Supports incremental encoder for positioning purposes
     48          
     49                      ##### How to use this driver #####
     50            ==============================================================================
     51              [..]
     52               (#) Initialize the TIM low level resources by implementing the following functions
     53                   depending on the selected feature:
     54                     (++) Time Base : HAL_TIM_Base_MspInit()
     55                     (++) Input Capture : HAL_TIM_IC_MspInit()
     56                     (++) Output Compare : HAL_TIM_OC_MspInit()
     57                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     58                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     59                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     60          
     61               (#) Initialize the TIM low level resources :
     62                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     63                  (##) TIM pins configuration
     64                      (+++) Enable the clock for the TIM GPIOs using the following function:
     65                       __HAL_RCC_GPIOx_CLK_ENABLE();
     66                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     67          
     68               (#) The external Clock can be configured, if needed (the default clock is the
     69                   internal clock from the APBx), using the following function:
     70                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     71                   any start function.
     72          
     73               (#) Configure the TIM in the desired functioning mode using one of the
     74                 Initialization function of this driver:
     75                 (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     76                 (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an
     77                      Output Compare signal.
     78                 (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a
     79                      PWM signal.
     80                 (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an
     81                      external signal.
     82                 (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer
     83                      in One Pulse Mode.
     84                 (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     85          
     86               (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
     87                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     88                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     89                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     90                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     91                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     92                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     93          
     94               (#) The DMA Burst is managed with the two following functions:
     95                   HAL_TIM_DMABurst_WriteStart()
     96                   HAL_TIM_DMABurst_ReadStart()
     97          
     98              *** Callback registration ***
     99            =============================================
    100          
    101            [..]
    102            The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1
    103            allows the user to configure dynamically the driver callbacks.
    104          
    105            [..]
    106            Use Function @ref HAL_TIM_RegisterCallback() to register a callback.
    107            @ref HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,
    108            the Callback ID and a pointer to the user callback function.
    109          
    110            [..]
    111            Use function @ref HAL_TIM_UnRegisterCallback() to reset a callback to the default
    112            weak function.
    113            @ref HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
    114            and the Callback ID.
    115          
    116            [..]
    117            These functions allow to register/unregister following callbacks:
    118              (+) Base_MspInitCallback              : TIM Base Msp Init Callback.
    119              (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.
    120              (+) IC_MspInitCallback                : TIM IC Msp Init Callback.
    121              (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.
    122              (+) OC_MspInitCallback                : TIM OC Msp Init Callback.
    123              (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.
    124              (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.
    125              (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.
    126              (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.
    127              (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.
    128              (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.
    129              (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.
    130              (+) HallSensor_MspInitCallback        : TIM Hall Sensor Msp Init Callback.
    131              (+) HallSensor_MspDeInitCallback      : TIM Hall Sensor Msp DeInit Callback.
    132              (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.
    133              (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.
    134              (+) TriggerCallback                   : TIM Trigger Callback.
    135              (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.
    136              (+) IC_CaptureCallback                : TIM Input Capture Callback.
    137              (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.
    138              (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.
    139              (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.
    140              (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.
    141              (+) ErrorCallback                     : TIM Error Callback.
    142              (+) CommutationCallback               : TIM Commutation Callback.
    143              (+) CommutationHalfCpltCallback       : TIM Commutation half complete Callback.
    144              (+) BreakCallback                     : TIM Break Callback.
    145          
    146            [..]
    147          By default, after the Init and when the state is HAL_TIM_STATE_RESET
    148          all interrupt callbacks are set to the corresponding weak functions:
    149            examples @ref HAL_TIM_TriggerCallback(), @ref HAL_TIM_ErrorCallback().
    150          
    151            [..]
    152            Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
    153            functionalities in the Init / DeInit only when these callbacks are null
    154            (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit
    155              keep and use the user MspInit / MspDeInit callbacks(registered beforehand)
    156          
    157            [..]
    158              Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.
    159              Exception done MspInit / MspDeInit that can be registered / unregistered
    160              in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,
    161              thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.
    162            In that case first register the MspInit/MspDeInit user callbacks
    163                using @ref HAL_TIM_RegisterCallback() before calling DeInit or Init function.
    164          
    165            [..]
    166                When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or
    167                not defined, the callback registration feature is not available and all callbacks
    168                are set to the corresponding weak functions.
    169          
    170            @endverbatim
    171            ******************************************************************************
    172            * @attention
    173            *
    174            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    175            * All rights reserved.</center></h2>
    176            *
    177            * This software component is licensed by ST under BSD 3-Clause license,
    178            * the "License"; You may not use this file except in compliance with the
    179            * License. You may obtain a copy of the License at:
    180            *                        opensource.org/licenses/BSD-3-Clause
    181            *
    182            ******************************************************************************
    183            */
    184          
    185          /* Includes ------------------------------------------------------------------*/
    186          #include "stm32f4xx_hal.h"
    187          
    188          /** @addtogroup STM32F4xx_HAL_Driver
    189            * @{
    190            */
    191          
    192          /** @defgroup TIM TIM
    193            * @brief TIM HAL module driver
    194            * @{
    195            */
    196          
    197          #ifdef HAL_TIM_MODULE_ENABLED
    198          
    199          /* Private typedef -----------------------------------------------------------*/
    200          /* Private define ------------------------------------------------------------*/
    201          /* Private macro -------------------------------------------------------------*/
    202          /* Private variables ---------------------------------------------------------*/
    203          /* Private function prototypes -----------------------------------------------*/
    204          /** @addtogroup TIM_Private_Functions
    205            * @{
    206            */
    207          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    208          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    209          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    210          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    211          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    212                                        uint32_t TIM_ICFilter);
    213          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    214          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    215                                        uint32_t TIM_ICFilter);
    216          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    217                                        uint32_t TIM_ICFilter);
    218          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource);
    219          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    220          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma);
    221          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    222          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma);
    223          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    224                                                            TIM_SlaveConfigTypeDef *sSlaveConfig);
    225          /**
    226            * @}
    227            */
    228          /* Exported functions --------------------------------------------------------*/
    229          
    230          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    231            * @{
    232            */
    233          
    234          /** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions
    235            *  @brief    Time Base functions
    236            *
    237          @verbatim
    238            ==============================================================================
    239                        ##### Time Base functions #####
    240            ==============================================================================
    241            [..]
    242              This section provides functions allowing to:
    243              (+) Initialize and configure the TIM base.
    244              (+) De-initialize the TIM base.
    245              (+) Start the Time Base.
    246              (+) Stop the Time Base.
    247              (+) Start the Time Base and enable interrupt.
    248              (+) Stop the Time Base and disable interrupt.
    249              (+) Start the Time Base and enable DMA transfer.
    250              (+) Stop the Time Base and disable DMA transfer.
    251          
    252          @endverbatim
    253            * @{
    254            */
    255          /**
    256            * @brief  Initializes the TIM Time base Unit according to the specified
    257            *         parameters in the TIM_HandleTypeDef and initialize the associated handle.
    258            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    259            *         requires a timer reset to avoid unexpected direction
    260            *         due to DIR bit readonly in center aligned mode.
    261            *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
    262            * @param  htim TIM Base handle
    263            * @retval HAL status
    264            */

   \                                 In section .text, align 2, keep-with-next
    265          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    266          {
   \                     HAL_TIM_Base_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    267            /* Check the TIM handle allocation */
    268            if (htim == NULL)
   \        0x4   0xD101             BNE.N    ??HAL_TIM_Base_Init_0
    269            {
    270              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
    271            }
    272          
    273            /* Check the parameters */
    274            assert_param(IS_TIM_INSTANCE(htim->Instance));
    275            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    276            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    277            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    278          
    279            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Base_Init_0: (+1)
   \        0xA   0x....'....        BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_28: (+1)
   \        0xE   0xB918             CBNZ.N   R0,??HAL_TIM_Base_Init_1
    280            {
    281              /* Allocate lock resource and initialize it */
    282              htim->Lock = HAL_UNLOCKED;
   \       0x10   0x....'....        BL       ?Subroutine21
    283          
    284          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    285              /* Reset interrupt callbacks to legacy weak callbacks */
    286              TIM_ResetCallback(htim);
    287          
    288              if (htim->Base_MspInitCallback == NULL)
    289              {
    290                htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
    291              }
    292              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    293              htim->Base_MspInitCallback(htim);
    294          #else
    295              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    296              HAL_TIM_Base_MspInit(htim);
    297          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    298            }
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x14   0x....'....        BL       HAL_TIM_Base_MspInit
    299          
    300            /* Set the TIM state */
    301            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_1: (+1)
   \       0x18   0x....             B.N      ?Subroutine3
    302          
    303            /* Set the Time Base configuration */
    304            TIM_Base_SetConfig(htim->Instance, &htim->Init);
    305          
    306            /* Initialize the TIM state*/
    307            htim->State = HAL_TIM_STATE_READY;
    308          
    309            return HAL_OK;
    310          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x2002             MOVS     R0,#+2
   \        0x2   0x7068             STRB     R0,[R5, #+1]
   \        0x4   0x1D21             ADDS     R1,R4,#+4
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x....'....        BL       TIM_Base_SetConfig
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x7068             STRB     R0,[R5, #+1]
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x7029             STRB     R1,[R5, #+0]
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \        0x0   0xF104 0x053C      ADD      R5,R4,#+60
   \        0x4   0x7868             LDRB     R0,[R5, #+1]
   \        0x6   0x4770             BX       LR
    311          
    312          /**
    313            * @brief  DeInitializes the TIM Base peripheral
    314            * @param  htim TIM Base handle
    315            * @retval HAL status
    316            */

   \                                 In section .text, align 2, keep-with-next
    317          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    318          {
   \                     HAL_TIM_Base_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    319            /* Check the parameters */
    320            assert_param(IS_TIM_INSTANCE(htim->Instance));
    321          
    322            htim->State = HAL_TIM_STATE_BUSY;
   \        0x2   0x....'....        BL       ?Subroutine24
    323          
    324            /* Disable the TIM Peripheral Clock */
    325            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_45: (+1)
   \        0x6   0xBF02             ITTT     EQ
   \        0x8   0x6A09             LDREQ    R1,[R1, #+32]
   \        0xA   0xF240 0x4244      MOVWEQ   R2,#+1092
   \        0xE   0x4211             TSTEQ    R1,R2
   \       0x10   0x....'....        BL       ?Subroutine16
    326          
    327          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    328            if (htim->Base_MspDeInitCallback == NULL)
    329            {
    330              htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
    331            }
    332            /* DeInit the low level hardware */
    333            htim->Base_MspDeInitCallback(htim);
    334          #else
    335            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    336            HAL_TIM_Base_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x14   0x....'....        BL       HAL_TIM_Base_MspDeInit
    337          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    338          
    339            /* Change TIM state */
    340            htim->State = HAL_TIM_STATE_RESET;
   \       0x18   0x....             B.N      ?Subroutine10
    341          
    342            /* Release Lock */
    343            __HAL_UNLOCK(htim);
    344          
    345            return HAL_OK;
    346          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x7060             STRB     R0,[R4, #+1]
   \        0x4   0x7020             STRB     R0,[R4, #+0]
   \        0x6   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine24: (+1)
   \        0x0   0xF100 0x043C      ADD      R4,R0,#+60
   \        0x4   0x2102             MOVS     R1,#+2
   \        0x6   0x7061             STRB     R1,[R4, #+1]
   \        0x8   0xF241 0x1311      MOVW     R3,#+4369
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0x6A0A             LDR      R2,[R1, #+32]
   \       0x10   0x421A             TST      R2,R3
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0xD104             BNE.N    ??Subroutine16_0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x0852             LSRS     R2,R2,#+1
   \        0x8   0x0052             LSLS     R2,R2,#+1
   \        0xA   0x600A             STR      R2,[R1, #+0]
   \                     ??Subroutine16_0: (+1)
   \        0xC   0x4770             BX       LR
    347          
    348          /**
    349            * @brief  Initializes the TIM Base MSP.
    350            * @param  htim TIM Base handle
    351            * @retval None
    352            */

   \                                 In section .text, align 2
    353          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    354          {
    355            /* Prevent unused argument(s) compilation warning */
    356            UNUSED(htim);
    357          
    358            /* NOTE : This function should not be modified, when the callback is needed,
    359                      the HAL_TIM_Base_MspInit could be implemented in the user file
    360             */
    361          }
   \                     HAL_TIM_Base_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    362          
    363          /**
    364            * @brief  DeInitializes TIM Base MSP.
    365            * @param  htim TIM Base handle
    366            * @retval None
    367            */

   \                                 In section .text, align 2
    368          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    369          {
    370            /* Prevent unused argument(s) compilation warning */
    371            UNUSED(htim);
    372          
    373            /* NOTE : This function should not be modified, when the callback is needed,
    374                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    375             */
    376          }
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    377          
    378          
    379          /**
    380            * @brief  Starts the TIM Base generation.
    381            * @param  htim TIM Base handle
    382            * @retval HAL status
    383            */

   \                                 In section .text, align 2, keep-with-next
    384          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    385          {
    386            uint32_t tmpsmcr;
    387          
    388            /* Check the parameters */
    389            assert_param(IS_TIM_INSTANCE(htim->Instance));
    390          
    391            /* Set the TIM state */
    392            htim->State = HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Start: (+1)
   \        0x0   0x2102             MOVS     R1,#+2
   \        0x2   0xF880 0x103D      STRB     R1,[R0, #+61]
    393          
    394            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    395            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \        0x6   0x6802             LDR      R2,[R0, #+0]
   \        0x8   0x6891             LDR      R1,[R2, #+8]
    396            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \        0xA   0xF001 0x0107      AND      R1,R1,#0x7
   \        0xE   0x2906             CMP      R1,#+6
   \       0x10   0xD004             BEQ.N    ??HAL_TIM_Base_Start_0
    397            {
    398              __HAL_TIM_ENABLE(htim);
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0x680A             LDR      R2,[R1, #+0]
   \       0x16   0xF042 0x0201      ORR      R2,R2,#0x1
   \       0x1A   0x600A             STR      R2,[R1, #+0]
    399            }
    400          
    401            /* Change the TIM state*/
    402            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Start_0: (+1)
   \       0x1C   0x....             B.N      ?Subroutine13
    403          
    404            /* Return function status */
    405            return HAL_OK;
    406          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0xF880 0x103D      STRB     R1,[R0, #+61]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x4770             BX       LR               ;; return
    407          
    408          /**
    409            * @brief  Stops the TIM Base generation.
    410            * @param  htim TIM Base handle
    411            * @retval HAL status
    412            */

   \                                 In section .text, align 2, keep-with-next
    413          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    414          {
    415            /* Check the parameters */
    416            assert_param(IS_TIM_INSTANCE(htim->Instance));
    417          
    418            /* Set the TIM state */
    419            htim->State = HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Stop: (+1)
   \        0x0   0x2102             MOVS     R1,#+2
   \        0x2   0xF880 0x103D      STRB     R1,[R0, #+61]
    420          
    421            /* Disable the Peripheral */
    422            __HAL_TIM_DISABLE(htim);
   \        0x6   0xF241 0x1311      MOVW     R3,#+4369
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0x6A0A             LDR      R2,[R1, #+32]
   \        0xE   0x421A             TST      R2,R3
   \       0x10   0xBF02             ITTT     EQ
   \       0x12   0x6A09             LDREQ    R1,[R1, #+32]
   \       0x14   0xF240 0x4244      MOVWEQ   R2,#+1092
   \       0x18   0x4211             TSTEQ    R1,R2
   \       0x1A   0xD104             BNE.N    ??HAL_TIM_Base_Stop_0
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0x680A             LDR      R2,[R1, #+0]
   \       0x20   0x0852             LSRS     R2,R2,#+1
   \       0x22   0x0052             LSLS     R2,R2,#+1
   \       0x24   0x600A             STR      R2,[R1, #+0]
    423          
    424            /* Change the TIM state*/
    425            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_0: (+1)
   \       0x26                      REQUIRE ?Subroutine13
   \       0x26                      ;; // Fall through to label ?Subroutine13
    426          
    427            /* Return function status */
    428            return HAL_OK;
    429          }
    430          
    431          /**
    432            * @brief  Starts the TIM Base generation in interrupt mode.
    433            * @param  htim TIM Base handle
    434            * @retval HAL status
    435            */

   \                                 In section .text, align 2, keep-with-next
    436          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    437          {
    438            uint32_t tmpsmcr;
    439          
    440            /* Check the parameters */
    441            assert_param(IS_TIM_INSTANCE(htim->Instance));
    442          
    443            /* Enable the TIM Update interrupt */
    444            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Start_IT: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF041 0x0101      ORR      R1,R1,#0x1
   \        0x8   0x60C1             STR      R1,[R0, #+12]
    445          
    446            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    447            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \        0xA   0x6881             LDR      R1,[R0, #+8]
    448            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \        0xC   0xF001 0x0107      AND      R1,R1,#0x7
   \       0x10   0x2906             CMP      R1,#+6
   \       0x12   0xD003             BEQ.N    ??HAL_TIM_Base_Start_IT_0
    449            {
    450              __HAL_TIM_ENABLE(htim);
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF041 0x0101      ORR      R1,R1,#0x1
   \       0x1A   0x6001             STR      R1,[R0, #+0]
    451            }
    452          
    453            /* Return function status */
    454            return HAL_OK;
   \                     ??HAL_TIM_Base_Start_IT_0: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x4770             BX       LR               ;; return
    455          }
    456          
    457          /**
    458            * @brief  Stops the TIM Base generation in interrupt mode.
    459            * @param  htim TIM Base handle
    460            * @retval HAL status
    461            */

   \                                 In section .text, align 2, keep-with-next
    462          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    463          {
    464            /* Check the parameters */
    465            assert_param(IS_TIM_INSTANCE(htim->Instance));
    466            /* Disable the TIM Update interrupt */
    467            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Stop_IT: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0x0849             LSRS     R1,R1,#+1
   \        0x6   0x0049             LSLS     R1,R1,#+1
   \        0x8   0x60C1             STR      R1,[R0, #+12]
    468          
    469            /* Disable the Peripheral */
    470            __HAL_TIM_DISABLE(htim);
   \        0xA   0xF241 0x1211      MOVW     R2,#+4369
   \        0xE   0x6A01             LDR      R1,[R0, #+32]
   \       0x10   0x4211             TST      R1,R2
   \       0x12   0xBF02             ITTT     EQ
   \       0x14   0x6A01             LDREQ    R1,[R0, #+32]
   \       0x16   0xF240 0x4244      MOVWEQ   R2,#+1092
   \       0x1A   0x4211             TSTEQ    R1,R2
   \       0x1C   0xD103             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0x0849             LSRS     R1,R1,#+1
   \       0x22   0x0049             LSLS     R1,R1,#+1
   \       0x24   0x6001             STR      R1,[R0, #+0]
    471          
    472            /* Return function status */
    473            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x4770             BX       LR               ;; return
    474          }
    475          
    476          /**
    477            * @brief  Starts the TIM Base generation in DMA mode.
    478            * @param  htim TIM Base handle
    479            * @param  pData The source Buffer address.
    480            * @param  Length The length of data to be transferred from memory to peripheral.
    481            * @retval HAL status
    482            */

   \                                 In section .text, align 2, keep-with-next
    483          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    484          {
   \                     HAL_TIM_Base_Start_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4613             MOV      R3,R2
    485            uint32_t tmpsmcr;
    486          
    487            /* Check the parameters */
    488            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    489          
    490            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0x6   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD028             BEQ.N    ??HAL_TIM_Base_Start_DMA_0
    491            {
    492              return HAL_BUSY;
    493            }
    494            else if (htim->State == HAL_TIM_STATE_READY)
   \        0xE   0x....'....        BL       ?Subroutine32
   \                     ??CrossCallReturnLabel_75: (+1)
   \       0x12   0xD104             BNE.N    ??CrossCallReturnLabel_79
    495            {
    496              if ((pData == NULL) && (Length > 0U))
   \       0x14   0xB909             CBNZ.N   R1,??HAL_TIM_Base_Start_DMA_1
   \       0x16   0x0018             MOVS     R0,R3
   \       0x18   0xD114             BNE.N    ??HAL_TIM_Base_Start_DMA_2
    497              {
    498                return HAL_ERROR;
    499              }
    500              else
    501              {
    502                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_1: (+1)
   \       0x1A   0x....'....        BL       ?Subroutine33
    503              }
    504            }
    505            else
    506            {
    507              /* nothing to do */
    508            }
    509          
    510            /* Set the DMA Period elapsed callbacks */
    511            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??CrossCallReturnLabel_79: (+1)
   \       0x1E   0x6A20             LDR      R0,[R4, #+32]
   \       0x20   0x....'....        LDR.W    R2,??DataTable22
   \       0x24   0x63C2             STR      R2,[R0, #+60]
    512            htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x26   0x6A20             LDR      R0,[R4, #+32]
   \       0x28   0x....'....        LDR.W    R2,??DataTable22_1
   \       0x2C   0x6402             STR      R2,[R0, #+64]
    513          
    514            /* Set the DMA error callback */
    515            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x2E   0x6A20             LDR      R0,[R4, #+32]
   \       0x30   0x....'....        LDR.W    R2,??DataTable22_2
   \       0x34   0x64C2             STR      R2,[R0, #+76]
    516          
    517            /* Enable the DMA stream */
    518            if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length) != HAL_OK)
   \       0x36   0x6825             LDR      R5,[R4, #+0]
   \       0x38   0x6A20             LDR      R0,[R4, #+32]
   \       0x3A   0xF105 0x022C      ADD      R2,R5,#+44
   \       0x3E   0x....'....        BL       HAL_DMA_Start_IT
   \       0x42   0xB108             CBZ.N    R0,??HAL_TIM_Base_Start_DMA_3
    519            {
    520              return HAL_ERROR;
   \                     ??HAL_TIM_Base_Start_DMA_2: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}
    521            }
    522          
    523            /* Enable the TIM Update DMA request */
    524            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \                     ??HAL_TIM_Base_Start_DMA_3: (+1)
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x68C1             LDR      R1,[R0, #+12]
   \       0x4C   0xF441 0x7180      ORR      R1,R1,#0x100
   \       0x50   0x60C1             STR      R1,[R0, #+12]
    525          
    526            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    527            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x52   0x....'....        BL       ?Subroutine57
    528            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \                     ??CrossCallReturnLabel_151: (+1)
   \       0x56   0xD002             BEQ.N    ??CrossCallReturnLabel_53
    529            {
    530              __HAL_TIM_ENABLE(htim);
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x....'....        BL       ??Subroutine25_1
    531            }
    532          
    533            /* Return function status */
    534            return HAL_OK;
   \                     ??CrossCallReturnLabel_53: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Start_DMA_0: (+1)
   \       0x60   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    535          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine33: (+1)
   \        0x0   0x2002             MOVS     R0,#+2
   \        0x2   0xF884 0x003D      STRB     R0,[R4, #+61]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine32: (+1)
   \        0x0   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \        0x4   0x2801             CMP      R0,#+1
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine57: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6880             LDR      R0,[R0, #+8]
   \        0x4   0xF000 0x0007      AND      R0,R0,#0x7
   \        0x8   0x2806             CMP      R0,#+6
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine25: (+1)
   \        0x0   0x60C1             STR      R1,[R0, #+12]
   \        0x2   0x2201             MOVS     R2,#+1
   \                     ??Subroutine25_0: (+1)
   \        0x4   0x6830             LDR      R0,[R6, #+0]
   \                     ??Subroutine25_1: (+1)
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0xF041 0x0101      ORR      R1,R1,#0x1
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \        0xE   0x4770             BX       LR
    536          
    537          /**
    538            * @brief  Stops the TIM Base generation in DMA mode.
    539            * @param  htim TIM Base handle
    540            * @retval HAL status
    541            */

   \                                 In section .text, align 2, keep-with-next
    542          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    543          {
   \                     HAL_TIM_Base_Stop_DMA: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    544            /* Check the parameters */
    545            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    546          
    547            /* Disable the TIM Update DMA request */
    548            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C1             LDR      R1,[R0, #+12]
   \        0x8   0xF421 0x7180      BIC      R1,R1,#0x100
   \        0xC   0x60C1             STR      R1,[R0, #+12]
    549          
    550            (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   \        0xE   0x6A20             LDR      R0,[R4, #+32]
   \       0x10   0x....'....        BL       HAL_DMA_Abort_IT
    551          
    552            /* Disable the Peripheral */
    553            __HAL_TIM_DISABLE(htim);
   \       0x14   0x....'....        BL       ?Subroutine39
   \                     ??CrossCallReturnLabel_85: (+1)
   \       0x18   0xBF02             ITTT     EQ
   \       0x1A   0x6A00             LDREQ    R0,[R0, #+32]
   \       0x1C   0xF240 0x4144      MOVWEQ   R1,#+1092
   \       0x20   0x4208             TSTEQ    R0,R1
   \       0x22   0x....'....        B.W      ?Subroutine6
    554          
    555            /* Change the htim state */
    556            htim->State = HAL_TIM_STATE_READY;
    557          
    558            /* Return function status */
    559            return HAL_OK;
    560          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine39: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6A01             LDR      R1,[R0, #+32]
   \        0x4   0xF241 0x1211      MOVW     R2,#+4369
   \        0x8   0x4211             TST      R1,R2
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0xD104             BNE.N    ??Subroutine6_0
   \        0x2   0x6820             LDR      R0,[R4, #+0]
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x0849             LSRS     R1,R1,#+1
   \        0x8   0x0049             LSLS     R1,R1,#+1
   \        0xA   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine6_0: (+1)
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xF884 0x003D      STRB     R0,[R4, #+61]
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xBD10             POP      {R4,PC}          ;; return
    561          
    562          /**
    563            * @}
    564            */
    565          
    566          /** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions
    567            *  @brief    TIM Output Compare functions
    568            *
    569          @verbatim
    570            ==============================================================================
    571                            ##### TIM Output Compare functions #####
    572            ==============================================================================
    573            [..]
    574              This section provides functions allowing to:
    575              (+) Initialize and configure the TIM Output Compare.
    576              (+) De-initialize the TIM Output Compare.
    577              (+) Start the TIM Output Compare.
    578              (+) Stop the TIM Output Compare.
    579              (+) Start the TIM Output Compare and enable interrupt.
    580              (+) Stop the TIM Output Compare and disable interrupt.
    581              (+) Start the TIM Output Compare and enable DMA transfer.
    582              (+) Stop the TIM Output Compare and disable DMA transfer.
    583          
    584          @endverbatim
    585            * @{
    586            */
    587          /**
    588            * @brief  Initializes the TIM Output Compare according to the specified
    589            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
    590            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    591            *         requires a timer reset to avoid unexpected direction
    592            *         due to DIR bit readonly in center aligned mode.
    593            *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
    594            * @param  htim TIM Output Compare handle
    595            * @retval HAL status
    596            */

   \                                 In section .text, align 2, keep-with-next
    597          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
    598          {
   \                     HAL_TIM_OC_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    599            /* Check the TIM handle allocation */
    600            if (htim == NULL)
   \        0x4   0xD101             BNE.N    ??HAL_TIM_OC_Init_0
    601            {
    602              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
    603            }
    604          
    605            /* Check the parameters */
    606            assert_param(IS_TIM_INSTANCE(htim->Instance));
    607            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    608            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    609            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    610          
    611            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OC_Init_0: (+1)
   \        0xA   0x....'....        BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_29: (+1)
   \        0xE   0xB918             CBNZ.N   R0,??HAL_TIM_OC_Init_1
    612            {
    613              /* Allocate lock resource and initialize it */
    614              htim->Lock = HAL_UNLOCKED;
   \       0x10   0x....'....        BL       ?Subroutine21
    615          
    616          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    617              /* Reset interrupt callbacks to legacy weak callbacks */
    618              TIM_ResetCallback(htim);
    619          
    620              if (htim->OC_MspInitCallback == NULL)
    621              {
    622                htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;
    623              }
    624              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    625              htim->OC_MspInitCallback(htim);
    626          #else
    627              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    628              HAL_TIM_OC_MspInit(htim);
    629          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    630            }
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x14   0x....'....        BL       HAL_TIM_OC_MspInit
    631          
    632            /* Set the TIM state */
    633            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_1: (+1)
   \       0x18                      REQUIRE ?Subroutine3
   \       0x18                      ;; // Fall through to label ?Subroutine3
    634          
    635            /* Init the base time for the Output Compare */
    636            TIM_Base_SetConfig(htim->Instance,  &htim->Init);
    637          
    638            /* Initialize the TIM state*/
    639            htim->State = HAL_TIM_STATE_READY;
    640          
    641            return HAL_OK;
    642          }
    643          
    644          /**
    645            * @brief  DeInitializes the TIM peripheral
    646            * @param  htim TIM Output Compare handle
    647            * @retval HAL status
    648            */

   \                                 In section .text, align 2, keep-with-next
    649          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    650          {
   \                     HAL_TIM_OC_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    651            /* Check the parameters */
    652            assert_param(IS_TIM_INSTANCE(htim->Instance));
    653          
    654            htim->State = HAL_TIM_STATE_BUSY;
   \        0x2   0x....'....        BL       ?Subroutine24
    655          
    656            /* Disable the TIM Peripheral Clock */
    657            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_46: (+1)
   \        0x6   0xBF02             ITTT     EQ
   \        0x8   0x6A09             LDREQ    R1,[R1, #+32]
   \        0xA   0xF240 0x4244      MOVWEQ   R2,#+1092
   \        0xE   0x4211             TSTEQ    R1,R2
   \       0x10   0x....'....        BL       ?Subroutine16
    658          
    659          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    660            if (htim->OC_MspDeInitCallback == NULL)
    661            {
    662              htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
    663            }
    664            /* DeInit the low level hardware */
    665            htim->OC_MspDeInitCallback(htim);
    666          #else
    667            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    668            HAL_TIM_OC_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x14   0x....'....        BL       HAL_TIM_OC_MspDeInit
    669          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    670          
    671            /* Change TIM state */
    672            htim->State = HAL_TIM_STATE_RESET;
   \       0x18                      REQUIRE ?Subroutine10
   \       0x18                      ;; // Fall through to label ?Subroutine10
    673          
    674            /* Release Lock */
    675            __HAL_UNLOCK(htim);
    676          
    677            return HAL_OK;
    678          }
    679          
    680          /**
    681            * @brief  Initializes the TIM Output Compare MSP.
    682            * @param  htim TIM Output Compare handle
    683            * @retval None
    684            */

   \                                 In section .text, align 2
    685          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    686          {
    687            /* Prevent unused argument(s) compilation warning */
    688            UNUSED(htim);
    689          
    690            /* NOTE : This function should not be modified, when the callback is needed,
    691                      the HAL_TIM_OC_MspInit could be implemented in the user file
    692             */
    693          }
   \                     HAL_TIM_OC_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    694          
    695          /**
    696            * @brief  DeInitializes TIM Output Compare MSP.
    697            * @param  htim TIM Output Compare handle
    698            * @retval None
    699            */

   \                                 In section .text, align 2
    700          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    701          {
    702            /* Prevent unused argument(s) compilation warning */
    703            UNUSED(htim);
    704          
    705            /* NOTE : This function should not be modified, when the callback is needed,
    706                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    707             */
    708          }
   \                     HAL_TIM_OC_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    709          
    710          /**
    711            * @brief  Starts the TIM Output Compare signal generation.
    712            * @param  htim TIM Output Compare handle
    713            * @param  Channel TIM Channel to be enabled
    714            *          This parameter can be one of the following values:
    715            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    716            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    717            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    718            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    719            * @retval HAL status
    720            */

   \                                 In section .text, align 2, keep-with-next
    721          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    722          {
   \                     HAL_TIM_OC_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine29
    723            uint32_t tmpsmcr;
    724          
    725            /* Check the parameters */
    726            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    727          
    728            /* Enable the Output compare channel */
    729            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    730          
    731            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_69: (+1)
   \        0x6   0x....'....        BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_91: (+1)
   \        0xA   0xBF1C             ITT      NE
   \        0xC   0x....'....        LDRNE.W  R2,??DataTable22_3  ;; 0x40010400
   \       0x10   0x4290             CMPNE    R0,R2
   \       0x12   0x....             B.N      ?Subroutine5
    732            {
    733              /* Enable the main output */
    734              __HAL_TIM_MOE_ENABLE(htim);
    735            }
    736          
    737            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    738            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    739            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    740            {
    741              __HAL_TIM_ENABLE(htim);
    742            }
    743          
    744            /* Return function status */
    745            return HAL_OK;
    746          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xD103             BNE.N    ??Subroutine5_0
   \        0x2   0x6C41             LDR      R1,[R0, #+68]
   \        0x4   0xF441 0x4100      ORR      R1,R1,#0x8000
   \        0x8   0x6441             STR      R1,[R0, #+68]
   \                     ??Subroutine5_0: (+1)
   \        0xA   0x6881             LDR      R1,[R0, #+8]
   \        0xC   0xF001 0x0107      AND      R1,R1,#0x7
   \       0x10   0x2906             CMP      R1,#+6
   \       0x12   0xD003             BEQ.N    ??Subroutine5_1
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF041 0x0101      ORR      R1,R1,#0x1
   \       0x1A   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine5_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine29: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x....'....        B.W      TIM_CCxChannelCmd

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine40: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x....'....        LDR.W    R1,??DataTable22_4  ;; 0x40010000
   \        0x6   0x4288             CMP      R0,R1
   \        0x8   0x4770             BX       LR
    747          
    748          /**
    749            * @brief  Stops the TIM Output Compare signal generation.
    750            * @param  htim TIM Output Compare handle
    751            * @param  Channel TIM Channel to be disabled
    752            *          This parameter can be one of the following values:
    753            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    754            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    755            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    756            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    757            * @retval HAL status
    758            */

   \                                 In section .text, align 2, keep-with-next
    759          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    760          {
   \                     HAL_TIM_OC_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine30
    761            /* Check the parameters */
    762            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    763          
    764            /* Disable the Output compare channel */
    765            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    766          
    767            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_72: (+1)
   \        0x6   0x....'....        BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_99: (+1)
   \        0xA   0xBF1C             ITT      NE
   \        0xC   0x....'....        LDRNE.W  R4,??DataTable22_3  ;; 0x40010400
   \       0x10   0x42A0             CMPNE    R0,R4
   \       0x12   0x....'....        BL       ?Subroutine60
   \                     ??CrossCallReturnLabel_159: (+1)
   \       0x16   0xD106             BNE.N    ??CrossCallReturnLabel_0
    768            {
    769              /* Disable the Main Output */
    770              __HAL_TIM_MOE_DISABLE(htim);
   \       0x18   0x6A03             LDR      R3,[R0, #+32]
   \       0x1A   0x4213             TST      R3,R2
   \       0x1C   0xBF04             ITT      EQ
   \       0x1E   0x6A03             LDREQ    R3,[R0, #+32]
   \       0x20   0x420B             TSTEQ    R3,R1
   \       0x22   0x....'....        BL       ?Subroutine15
    771            }
    772          
    773            /* Disable the Peripheral */
    774            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x26   0x6A03             LDR      R3,[R0, #+32]
   \       0x28   0x4213             TST      R3,R2
   \       0x2A   0xBF04             ITT      EQ
   \       0x2C   0x6A02             LDREQ    R2,[R0, #+32]
   \       0x2E   0x420A             TSTEQ    R2,R1
   \       0x30   0x....             B.N      ?Subroutine7
    775          
    776            /* Return function status */
    777            return HAL_OK;
    778          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0xD103             BNE.N    ??Subroutine7_0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x0849             LSRS     R1,R1,#+1
   \        0x6   0x0049             LSLS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine7_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine30: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x....'....        B.W      TIM_CCxChannelCmd

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine60: (+1)
   \        0x0   0xF240 0x4144      MOVW     R1,#+1092
   \        0x4   0xF241 0x1211      MOVW     R2,#+4369
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine41: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x....'....        LDR.W    R3,??DataTable22_4  ;; 0x40010000
   \        0x6   0x4298             CMP      R0,R3
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0xD103             BNE.N    ??Subroutine15_0
   \        0x2   0x6C43             LDR      R3,[R0, #+68]
   \        0x4   0xF423 0x4300      BIC      R3,R3,#0x8000
   \        0x8   0x6443             STR      R3,[R0, #+68]
   \                     ??Subroutine15_0: (+1)
   \        0xA   0x4770             BX       LR
    779          
    780          /**
    781            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    782            * @param  htim TIM Output Compare handle
    783            * @param  Channel TIM Channel to be enabled
    784            *          This parameter can be one of the following values:
    785            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    786            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    787            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    788            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    789            * @retval HAL status
    790            */

   \                                 In section .text, align 2, keep-with-next
    791          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    792          {
   \                     HAL_TIM_OC_Start_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine27
    793            uint32_t tmpsmcr;
    794          
    795            /* Check the parameters */
    796            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    797          
    798            switch (Channel)
    799            {
    800              case TIM_CHANNEL_1:
    801              {
    802                /* Enable the TIM Capture/Compare 1 interrupt */
    803                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
    804                break;
    805              }
    806          
    807              case TIM_CHANNEL_2:
    808              {
    809                /* Enable the TIM Capture/Compare 2 interrupt */
    810                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
    811                break;
    812              }
    813          
    814              case TIM_CHANNEL_3:
    815              {
    816                /* Enable the TIM Capture/Compare 3 interrupt */
    817                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
    818                break;
    819              }
    820          
    821              case TIM_CHANNEL_4:
    822              {
    823                /* Enable the TIM Capture/Compare 4 interrupt */
    824                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
    825                break;
    826              }
    827          
    828              default:
    829                break;
    830            }
    831          
    832            /* Enable the Output compare channel */
    833            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    834          
    835            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_63: (+1)
   \        0x6   0x....'....        BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_92: (+1)
   \        0xA   0xBF1C             ITT      NE
   \        0xC   0x....'....        LDRNE.W  R2,??DataTable22_3  ;; 0x40010400
   \       0x10   0x4290             CMPNE    R0,R2
   \       0x12                      REQUIRE ?Subroutine5
   \       0x12                      ;; // Fall through to label ?Subroutine5
    836            {
    837              /* Enable the main output */
    838              __HAL_TIM_MOE_ENABLE(htim);
    839            }
    840          
    841            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    842            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    843            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    844            {
    845              __HAL_TIM_ENABLE(htim);
    846            }
    847          
    848            /* Return function status */
    849            return HAL_OK;
    850          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine27: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xD006             BEQ.N    ??Subroutine27_0
   \        0x6   0x2904             CMP      R1,#+4
   \        0x8   0xD009             BEQ.N    ??Subroutine27_1
   \        0xA   0x2908             CMP      R1,#+8
   \        0xC   0xD00C             BEQ.N    ??Subroutine27_2
   \        0xE   0x290C             CMP      R1,#+12
   \       0x10   0xD00F             BEQ.N    ??Subroutine27_3
   \       0x12   0xE013             B.N      ??Subroutine27_4
   \                     ??Subroutine27_0: (+1)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x68C2             LDR      R2,[R0, #+12]
   \       0x18   0xF042 0x0202      ORR      R2,R2,#0x2
   \       0x1C   0xE00D             B.N      ??Subroutine27_5
   \                     ??Subroutine27_1: (+1)
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x68C2             LDR      R2,[R0, #+12]
   \       0x22   0xF042 0x0204      ORR      R2,R2,#0x4
   \       0x26   0xE008             B.N      ??Subroutine27_5
   \                     ??Subroutine27_2: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C2             LDR      R2,[R0, #+12]
   \       0x2C   0xF042 0x0208      ORR      R2,R2,#0x8
   \       0x30   0xE003             B.N      ??Subroutine27_5
   \                     ??Subroutine27_3: (+1)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x68C2             LDR      R2,[R0, #+12]
   \       0x36   0xF042 0x0210      ORR      R2,R2,#0x10
   \                     ??Subroutine27_5: (+1)
   \       0x3A   0x60C2             STR      R2,[R0, #+12]
   \                     ??Subroutine27_4: (+1)
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x2201             MOVS     R2,#+1
   \       0x40   0x....'....        B.W      TIM_CCxChannelCmd
    851          
    852          /**
    853            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    854            * @param  htim TIM Output Compare handle
    855            * @param  Channel TIM Channel to be disabled
    856            *          This parameter can be one of the following values:
    857            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    858            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    859            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    860            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    861            * @retval HAL status
    862            */

   \                                 In section .text, align 2, keep-with-next
    863          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    864          {
   \                     HAL_TIM_OC_Stop_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine28
    865            /* Check the parameters */
    866            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    867          
    868            switch (Channel)
    869            {
    870              case TIM_CHANNEL_1:
    871              {
    872                /* Disable the TIM Capture/Compare 1 interrupt */
    873                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
    874                break;
    875              }
    876          
    877              case TIM_CHANNEL_2:
    878              {
    879                /* Disable the TIM Capture/Compare 2 interrupt */
    880                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
    881                break;
    882              }
    883          
    884              case TIM_CHANNEL_3:
    885              {
    886                /* Disable the TIM Capture/Compare 3 interrupt */
    887                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
    888                break;
    889              }
    890          
    891              case TIM_CHANNEL_4:
    892              {
    893                /* Disable the TIM Capture/Compare 4 interrupt */
    894                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
    895                break;
    896              }
    897          
    898              default:
    899                break;
    900            }
    901          
    902            /* Disable the Output compare channel */
    903            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    904          
    905            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_66: (+1)
   \        0x6   0x....'....        BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_100: (+1)
   \        0xA   0xBF1C             ITT      NE
   \        0xC   0x....'....        LDRNE.W  R4,??DataTable22_3  ;; 0x40010400
   \       0x10   0x42A0             CMPNE    R0,R4
   \       0x12   0x....'....        BL       ?Subroutine60
   \                     ??CrossCallReturnLabel_160: (+1)
   \       0x16   0xD106             BNE.N    ??CrossCallReturnLabel_1
    906            {
    907              /* Disable the Main Output */
    908              __HAL_TIM_MOE_DISABLE(htim);
   \       0x18   0x6A03             LDR      R3,[R0, #+32]
   \       0x1A   0x4213             TST      R3,R2
   \       0x1C   0xBF04             ITT      EQ
   \       0x1E   0x6A03             LDREQ    R3,[R0, #+32]
   \       0x20   0x420B             TSTEQ    R3,R1
   \       0x22   0x....'....        BL       ?Subroutine15
    909            }
    910          
    911            /* Disable the Peripheral */
    912            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x26   0x6A03             LDR      R3,[R0, #+32]
   \       0x28   0x4213             TST      R3,R2
   \       0x2A   0xBF04             ITT      EQ
   \       0x2C   0x6A02             LDREQ    R2,[R0, #+32]
   \       0x2E   0x420A             TSTEQ    R2,R1
   \       0x30                      REQUIRE ?Subroutine7
   \       0x30                      ;; // Fall through to label ?Subroutine7
    913          
    914            /* Return function status */
    915            return HAL_OK;
    916          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine28: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xD006             BEQ.N    ??Subroutine28_0
   \        0x6   0x2904             CMP      R1,#+4
   \        0x8   0xD009             BEQ.N    ??Subroutine28_1
   \        0xA   0x2908             CMP      R1,#+8
   \        0xC   0xD00C             BEQ.N    ??Subroutine28_2
   \        0xE   0x290C             CMP      R1,#+12
   \       0x10   0xD00F             BEQ.N    ??Subroutine28_3
   \       0x12   0xE013             B.N      ??Subroutine28_4
   \                     ??Subroutine28_0: (+1)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x68C2             LDR      R2,[R0, #+12]
   \       0x18   0xF022 0x0202      BIC      R2,R2,#0x2
   \       0x1C   0xE00D             B.N      ??Subroutine28_5
   \                     ??Subroutine28_1: (+1)
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x68C2             LDR      R2,[R0, #+12]
   \       0x22   0xF022 0x0204      BIC      R2,R2,#0x4
   \       0x26   0xE008             B.N      ??Subroutine28_5
   \                     ??Subroutine28_2: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C2             LDR      R2,[R0, #+12]
   \       0x2C   0xF022 0x0208      BIC      R2,R2,#0x8
   \       0x30   0xE003             B.N      ??Subroutine28_5
   \                     ??Subroutine28_3: (+1)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x68C2             LDR      R2,[R0, #+12]
   \       0x36   0xF022 0x0210      BIC      R2,R2,#0x10
   \                     ??Subroutine28_5: (+1)
   \       0x3A   0x60C2             STR      R2,[R0, #+12]
   \                     ??Subroutine28_4: (+1)
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x....'....        B.W      TIM_CCxChannelCmd
    917          
    918          /**
    919            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    920            * @param  htim TIM Output Compare handle
    921            * @param  Channel TIM Channel to be enabled
    922            *          This parameter can be one of the following values:
    923            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    924            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    925            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    926            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    927            * @param  pData The source Buffer address.
    928            * @param  Length The length of data to be transferred from memory to TIM peripheral
    929            * @retval HAL status
    930            */

   \                                 In section .text, align 2, keep-with-next
    931          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    932          {
   \                     HAL_TIM_OC_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine31
    933            uint32_t tmpsmcr;
    934          
    935            /* Check the parameters */
    936            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    937          
    938            if (htim->State == HAL_TIM_STATE_BUSY)
   \                     ??CrossCallReturnLabel_73: (+1)
   \        0x6   0xD036             BEQ.N    ??CrossCallReturnLabel_14
    939            {
    940              return HAL_BUSY;
    941            }
    942            else if (htim->State == HAL_TIM_STATE_READY)
   \        0x8   0x....'....        BL       ?Subroutine32
   \                     ??CrossCallReturnLabel_76: (+1)
   \        0xC   0xD104             BNE.N    ??CrossCallReturnLabel_80
    943            {
    944              if ((pData == NULL) && (Length > 0U))
   \        0xE   0xB909             CBNZ.N   R1,??HAL_TIM_OC_Start_DMA_0
   \       0x10   0x0018             MOVS     R0,R3
   \       0x12   0xD121             BNE.N    ??HAL_TIM_OC_Start_DMA_1
    945              {
    946                return HAL_ERROR;
    947              }
    948              else
    949              {
    950                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_0: (+1)
   \       0x14   0x....'....        BL       ?Subroutine33
    951              }
    952            }
    953            else
    954            {
    955              /* nothing to do */
    956            }
    957          
    958            switch (Channel)
   \                     ??CrossCallReturnLabel_80: (+1)
   \       0x18   0x....'....        BL       ?Subroutine61
   \                     ??CrossCallReturnLabel_167: (+1)
   \       0x1C   0xD006             BEQ.N    ??HAL_TIM_OC_Start_DMA_2
   \       0x1E   0x2D04             CMP      R5,#+4
   \       0x20   0xD00B             BEQ.N    ??HAL_TIM_OC_Start_DMA_3
   \       0x22   0x2D08             CMP      R5,#+8
   \       0x24   0xD00F             BEQ.N    ??HAL_TIM_OC_Start_DMA_4
   \       0x26   0x2D0C             CMP      R5,#+12
   \       0x28   0xD013             BEQ.N    ??HAL_TIM_OC_Start_DMA_5
   \       0x2A   0xE01A             B.N      ??HAL_TIM_OC_Start_DMA_6
    959            {
    960              case TIM_CHANNEL_1:
    961              {
    962                /* Set the DMA compare callbacks */
    963                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_2: (+1)
   \       0x2C   0x....'....        BL       ?Subroutine34
    964                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    965          
    966                /* Set the DMA error callback */
    967                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
    968          
    969                /* Enable the DMA stream */
    970                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_224: (+1)
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD111             BNE.N    ??HAL_TIM_OC_Start_DMA_1
    971                {
    972                  return HAL_ERROR;
    973                }
    974          
    975                /* Enable the TIM Capture/Compare 1 DMA request */
    976                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \       0x34   0x....'....        BL       ?Subroutine50
    977                break;
    978              }
   \                     ??CrossCallReturnLabel_133: (+1)
   \       0x38   0xE012             B.N      ??CrossCallReturnLabel_142
    979          
    980              case TIM_CHANNEL_2:
    981              {
    982                /* Set the DMA compare callbacks */
    983                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_3: (+1)
   \       0x3A   0x....'....        BL       ?Subroutine35
    984                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    985          
    986                /* Set the DMA error callback */
    987                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
    988          
    989                /* Enable the DMA stream */
    990                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_221: (+1)
   \       0x3E   0xB958             CBNZ.N   R0,??HAL_TIM_OC_Start_DMA_1
    991                {
    992                  return HAL_ERROR;
    993                }
    994          
    995                /* Enable the TIM Capture/Compare 2 DMA request */
    996                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \       0x40   0x....'....        BL       ?Subroutine51
    997                break;
    998              }
   \                     ??CrossCallReturnLabel_136: (+1)
   \       0x44   0xE00C             B.N      ??CrossCallReturnLabel_142
    999          
   1000              case TIM_CHANNEL_3:
   1001              {
   1002                /* Set the DMA compare callbacks */
   1003                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_4: (+1)
   \       0x46   0x....'....        BL       ?Subroutine36
   1004                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1005          
   1006                /* Set the DMA error callback */
   1007                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1008          
   1009                /* Enable the DMA stream */
   1010                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_218: (+1)
   \       0x4A   0xB928             CBNZ.N   R0,??HAL_TIM_OC_Start_DMA_1
   1011                {
   1012                  return HAL_ERROR;
   1013                }
   1014                /* Enable the TIM Capture/Compare 3 DMA request */
   1015                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \       0x4C   0x....'....        BL       ?Subroutine52
   1016                break;
   1017              }
   \                     ??CrossCallReturnLabel_139: (+1)
   \       0x50   0xE006             B.N      ??CrossCallReturnLabel_142
   1018          
   1019              case TIM_CHANNEL_4:
   1020              {
   1021                /* Set the DMA compare callbacks */
   1022                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_5: (+1)
   \       0x52   0x....'....        BL       ?Subroutine37
   1023                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1024          
   1025                /* Set the DMA error callback */
   1026                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1027          
   1028                /* Enable the DMA stream */
   1029                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_215: (+1)
   \       0x56   0xB108             CBZ.N    R0,??HAL_TIM_OC_Start_DMA_7
   1030                {
   1031                  return HAL_ERROR;
   \                     ??HAL_TIM_OC_Start_DMA_1: (+1)
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xBDF2             POP      {R1,R4-R7,PC}
   1032                }
   1033                /* Enable the TIM Capture/Compare 4 DMA request */
   1034                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Start_DMA_7: (+1)
   \       0x5C   0x....'....        BL       ?Subroutine53
   \                     ??CrossCallReturnLabel_142: (+1)
   \       0x60   0x60C1             STR      R1,[R0, #+12]
   1035                break;
   1036              }
   1037          
   1038              default:
   1039                break;
   1040            }
   1041          
   1042            /* Enable the Output compare channel */
   1043            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_6: (+1)
   \       0x62   0x....'....        BL       ?Subroutine47
   1044          
   1045            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_126: (+1)
   \       0x66   0x....'....        BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_93: (+1)
   \       0x6A   0xBF1C             ITT      NE
   \       0x6C   0x....'....        LDRNE.W  R2,??DataTable22_3  ;; 0x40010400
   \       0x70   0x4290             CMPNE    R0,R2
   \       0x72   0x....'....        BL       ?Subroutine17
   1046            {
   1047              /* Enable the main output */
   1048              __HAL_TIM_MOE_ENABLE(htim);
   1049            }
   1050          
   1051            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1052            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1053            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1054            {
   1055              __HAL_TIM_ENABLE(htim);
   1056            }
   1057          
   1058            /* Return function status */
   1059            return HAL_OK;
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x76   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1060          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine37: (+1)
   \        0x0   0x6B27             LDR      R7,[R4, #+48]
   \        0x2   0x63FE             STR      R6,[R7, #+60]
   \        0x4   0x6B26             LDR      R6,[R4, #+48]
   \        0x6   0x6432             STR      R2,[R6, #+64]
   \        0x8   0x6B22             LDR      R2,[R4, #+48]
   \        0xA   0x64D0             STR      R0,[R2, #+76]
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0xF100 0x0240      ADD      R2,R0,#+64
   \       0x12                      REQUIRE ??Subroutine74_0
   \       0x12                      ;; // Fall through to label ??Subroutine74_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine74_0: (+1)
   \        0x0   0x6B20             LDR      R0,[R4, #+48]
   \        0x2   0x....'....        B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine36: (+1)
   \        0x0   0x6AE7             LDR      R7,[R4, #+44]
   \        0x2   0x63FE             STR      R6,[R7, #+60]
   \        0x4   0x6AE6             LDR      R6,[R4, #+44]
   \        0x6   0x6432             STR      R2,[R6, #+64]
   \        0x8   0x6AE2             LDR      R2,[R4, #+44]
   \        0xA   0x64D0             STR      R0,[R2, #+76]
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0xF100 0x023C      ADD      R2,R0,#+60
   \       0x12                      REQUIRE ??Subroutine75_0
   \       0x12                      ;; // Fall through to label ??Subroutine75_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine75_0: (+1)
   \        0x0   0x6AE0             LDR      R0,[R4, #+44]
   \        0x2   0x....'....        B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine35: (+1)
   \        0x0   0x6AA7             LDR      R7,[R4, #+40]
   \        0x2   0x63FE             STR      R6,[R7, #+60]
   \        0x4   0x6AA6             LDR      R6,[R4, #+40]
   \        0x6   0x6432             STR      R2,[R6, #+64]
   \        0x8   0x6AA2             LDR      R2,[R4, #+40]
   \        0xA   0x64D0             STR      R0,[R2, #+76]
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0xF100 0x0238      ADD      R2,R0,#+56
   \       0x12                      REQUIRE ??Subroutine76_0
   \       0x12                      ;; // Fall through to label ??Subroutine76_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine76_0: (+1)
   \        0x0   0x6AA0             LDR      R0,[R4, #+40]
   \        0x2   0x....'....        B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine34: (+1)
   \        0x0   0x6A67             LDR      R7,[R4, #+36]
   \        0x2   0x63FE             STR      R6,[R7, #+60]
   \        0x4   0x6A66             LDR      R6,[R4, #+36]
   \        0x6   0x6432             STR      R2,[R6, #+64]
   \        0x8   0x6A67             LDR      R7,[R4, #+36]
   \        0xA   0x64F8             STR      R0,[R7, #+76]
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0xF100 0x0234      ADD      R2,R0,#+52
   \       0x12                      REQUIRE ??Subroutine77_0
   \       0x12                      ;; // Fall through to label ??Subroutine77_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine77_0: (+1)
   \        0x0   0x6A60             LDR      R0,[R4, #+36]
   \        0x2   0x....'....        B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine61: (+1)
   \        0x0   0x002F             MOVS     R7,R5
   \        0x2   0x....'....        LDR.W    R0,??DataTable22_2
   \        0x6   0x....'....        LDR.W    R2,??DataTable22_5
   \        0xA   0x....'....        LDR.W    R6,??DataTable22_6
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine53: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF441 0x5180      ORR      R1,R1,#0x1000
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine52: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF441 0x6100      ORR      R1,R1,#0x800
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine51: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF441 0x6180      ORR      R1,R1,#0x400
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine50: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF441 0x7100      ORR      R1,R1,#0x200
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine47: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4629             MOV      R1,R5
   \        0x6   0x....'....        B.W      TIM_CCxChannelCmd

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine31: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \        0x8   0x2802             CMP      R0,#+2
   \        0xA   0x4611             MOV      R1,R2
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0xD103             BNE.N    ??Subroutine17_0
   \        0x2   0x6C41             LDR      R1,[R0, #+68]
   \        0x4   0xF441 0x4100      ORR      R1,R1,#0x8000
   \        0x8   0x6441             STR      R1,[R0, #+68]
   \                     ??Subroutine17_0: (+1)
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6880             LDR      R0,[R0, #+8]
   \        0xE   0xF000 0x0007      AND      R0,R0,#0x7
   \       0x12   0x2806             CMP      R0,#+6
   \       0x14   0xD004             BEQ.N    ??Subroutine17_1
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF041 0x0101      ORR      R1,R1,#0x1
   \       0x1E   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine17_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x4770             BX       LR
   1061          
   1062          /**
   1063            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
   1064            * @param  htim TIM Output Compare handle
   1065            * @param  Channel TIM Channel to be disabled
   1066            *          This parameter can be one of the following values:
   1067            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1068            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1069            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1070            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1071            * @retval HAL status
   1072            */

   \                                 In section .text, align 2, keep-with-next
   1073          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1074          {
   \                     HAL_TIM_OC_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x000D             MOVS     R5,R1
   \        0x4   0x4604             MOV      R4,R0
   1075            /* Check the parameters */
   1076            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1077          
   1078            switch (Channel)
   \        0x6   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_DMA_0
   \        0x8   0x2D04             CMP      R5,#+4
   \        0xA   0xD007             BEQ.N    ??HAL_TIM_OC_Stop_DMA_1
   \        0xC   0x2D08             CMP      R5,#+8
   \        0xE   0xD008             BEQ.N    ??HAL_TIM_OC_Stop_DMA_2
   \       0x10   0x2D0C             CMP      R5,#+12
   \       0x12   0xD009             BEQ.N    ??HAL_TIM_OC_Stop_DMA_3
   \       0x14   0xE00C             B.N      ??HAL_TIM_OC_Stop_DMA_4
   1079            {
   1080              case TIM_CHANNEL_1:
   1081              {
   1082                /* Disable the TIM Capture/Compare 1 DMA request */
   1083                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Stop_DMA_0: (+1)
   \       0x16   0x....'....        BL       ?Subroutine42
   1084                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   1085                break;
   1086              }
   \                     ??CrossCallReturnLabel_107: (+1)
   \       0x1A   0xE007             B.N      ??CrossCallReturnLabel_121
   1087          
   1088              case TIM_CHANNEL_2:
   1089              {
   1090                /* Disable the TIM Capture/Compare 2 DMA request */
   1091                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Stop_DMA_1: (+1)
   \       0x1C   0x....'....        BL       ?Subroutine44
   1092                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   1093                break;
   1094              }
   \                     ??CrossCallReturnLabel_115: (+1)
   \       0x20   0xE004             B.N      ??CrossCallReturnLabel_121
   1095          
   1096              case TIM_CHANNEL_3:
   1097              {
   1098                /* Disable the TIM Capture/Compare 3 DMA request */
   1099                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Stop_DMA_2: (+1)
   \       0x22   0x....'....        BL       ?Subroutine45
   1100                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   1101                break;
   1102              }
   \                     ??CrossCallReturnLabel_118: (+1)
   \       0x26   0xE001             B.N      ??CrossCallReturnLabel_121
   1103          
   1104              case TIM_CHANNEL_4:
   1105              {
   1106                /* Disable the TIM Capture/Compare 4 interrupt */
   1107                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Stop_DMA_3: (+1)
   \       0x28   0x....'....        BL       ?Subroutine46
   1108                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??CrossCallReturnLabel_121: (+1)
   \       0x2C   0x....'....        BL       HAL_DMA_Abort_IT
   1109                break;
   1110              }
   1111          
   1112              default:
   1113                break;
   1114            }
   1115          
   1116            /* Disable the Output compare channel */
   1117            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_DMA_4: (+1)
   \       0x30   0x....'....        BL       ?Subroutine48
   1118          
   1119            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_129: (+1)
   \       0x34   0x....'....        BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_101: (+1)
   \       0x38   0xBF1C             ITT      NE
   \       0x3A   0x....'....        LDRNE.W  R5,??DataTable22_3  ;; 0x40010400
   \       0x3E   0x42A8             CMPNE    R0,R5
   \       0x40   0x....'....        BL       ?Subroutine60
   \                     ??CrossCallReturnLabel_161: (+1)
   \       0x44   0xD106             BNE.N    ??CrossCallReturnLabel_2
   1120            {
   1121              /* Disable the Main Output */
   1122              __HAL_TIM_MOE_DISABLE(htim);
   \       0x46   0x6A03             LDR      R3,[R0, #+32]
   \       0x48   0x4213             TST      R3,R2
   \       0x4A   0xBF04             ITT      EQ
   \       0x4C   0x6A03             LDREQ    R3,[R0, #+32]
   \       0x4E   0x420B             TSTEQ    R3,R1
   \       0x50   0x....'....        BL       ?Subroutine15
   1123            }
   1124          
   1125            /* Disable the Peripheral */
   1126            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6A03             LDR      R3,[R0, #+32]
   \       0x58   0x4213             TST      R3,R2
   \       0x5A   0xBF04             ITT      EQ
   \       0x5C   0x6A00             LDREQ    R0,[R0, #+32]
   \       0x5E   0x4208             TSTEQ    R0,R1
   \       0x60   0x....             B.N      ?Subroutine2
   1127          
   1128            /* Change the htim state */
   1129            htim->State = HAL_TIM_STATE_READY;
   1130          
   1131            /* Return function status */
   1132            return HAL_OK;
   1133          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xD104             BNE.N    ??Subroutine2_0
   \        0x2   0x6821             LDR      R1,[R4, #+0]
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x0840             LSRS     R0,R0,#+1
   \        0x8   0x0040             LSLS     R0,R0,#+1
   \        0xA   0x6008             STR      R0,[R1, #+0]
   \                     ??Subroutine2_0: (+1)
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xF884 0x003D      STRB     R0,[R4, #+61]
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine48: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x4629             MOV      R1,R5
   \        0x6   0x....'....        B.W      TIM_CCxChannelCmd

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine46: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF421 0x5180      BIC      R1,R1,#0x1000
   \        0x8   0x60C1             STR      R1,[R0, #+12]
   \        0xA   0x6B20             LDR      R0,[R4, #+48]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine45: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF421 0x6100      BIC      R1,R1,#0x800
   \        0x8   0x60C1             STR      R1,[R0, #+12]
   \        0xA   0x6AE0             LDR      R0,[R4, #+44]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine44: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF421 0x6180      BIC      R1,R1,#0x400
   \        0x8   0x60C1             STR      R1,[R0, #+12]
   \        0xA   0x6AA0             LDR      R0,[R4, #+40]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine42: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF421 0x7100      BIC      R1,R1,#0x200
   \        0x8   0x60C1             STR      R1,[R0, #+12]
   \        0xA   0x6A60             LDR      R0,[R4, #+36]
   \        0xC   0x4770             BX       LR
   1134          
   1135          /**
   1136            * @}
   1137            */
   1138          
   1139          /** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions
   1140            *  @brief    TIM PWM functions
   1141            *
   1142          @verbatim
   1143            ==============================================================================
   1144                                    ##### TIM PWM functions #####
   1145            ==============================================================================
   1146            [..]
   1147              This section provides functions allowing to:
   1148              (+) Initialize and configure the TIM PWM.
   1149              (+) De-initialize the TIM PWM.
   1150              (+) Start the TIM PWM.
   1151              (+) Stop the TIM PWM.
   1152              (+) Start the TIM PWM and enable interrupt.
   1153              (+) Stop the TIM PWM and disable interrupt.
   1154              (+) Start the TIM PWM and enable DMA transfer.
   1155              (+) Stop the TIM PWM and disable DMA transfer.
   1156          
   1157          @endverbatim
   1158            * @{
   1159            */
   1160          /**
   1161            * @brief  Initializes the TIM PWM Time Base according to the specified
   1162            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1163            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1164            *         requires a timer reset to avoid unexpected direction
   1165            *         due to DIR bit readonly in center aligned mode.
   1166            *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
   1167            * @param  htim TIM PWM handle
   1168            * @retval HAL status
   1169            */

   \                                 In section .text, align 2, keep-with-next
   1170          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
   1171          {
   \                     HAL_TIM_PWM_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1172            /* Check the TIM handle allocation */
   1173            if (htim == NULL)
   \        0x4   0xD101             BNE.N    ??HAL_TIM_PWM_Init_0
   1174            {
   1175              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
   1176            }
   1177          
   1178            /* Check the parameters */
   1179            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1180            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1181            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1182            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1183          
   1184            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_PWM_Init_0: (+1)
   \        0xA   0x....'....        BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_30: (+1)
   \        0xE   0xB918             CBNZ.N   R0,??HAL_TIM_PWM_Init_1
   1185            {
   1186              /* Allocate lock resource and initialize it */
   1187              htim->Lock = HAL_UNLOCKED;
   \       0x10   0x....'....        BL       ?Subroutine21
   1188          
   1189          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1190              /* Reset interrupt callbacks to legacy weak callbacks */
   1191              TIM_ResetCallback(htim);
   1192          
   1193              if (htim->PWM_MspInitCallback == NULL)
   1194              {
   1195                htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
   1196              }
   1197              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1198              htim->PWM_MspInitCallback(htim);
   1199          #else
   1200              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1201              HAL_TIM_PWM_MspInit(htim);
   1202          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1203            }
   \                     ??CrossCallReturnLabel_36: (+1)
   \       0x14   0x....'....        BL       HAL_TIM_PWM_MspInit
   1204          
   1205            /* Set the TIM state */
   1206            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Init_1: (+1)
   \       0x18   0x....             B.N      ?Subroutine3
   1207          
   1208            /* Init the base time for the PWM */
   1209            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   1210          
   1211            /* Initialize the TIM state*/
   1212            htim->State = HAL_TIM_STATE_READY;
   1213          
   1214            return HAL_OK;
   1215          }
   1216          
   1217          /**
   1218            * @brief  DeInitializes the TIM peripheral
   1219            * @param  htim TIM PWM handle
   1220            * @retval HAL status
   1221            */

   \                                 In section .text, align 2, keep-with-next
   1222          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1223          {
   \                     HAL_TIM_PWM_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1224            /* Check the parameters */
   1225            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1226          
   1227            htim->State = HAL_TIM_STATE_BUSY;
   \        0x2   0x....'....        BL       ?Subroutine24
   1228          
   1229            /* Disable the TIM Peripheral Clock */
   1230            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_47: (+1)
   \        0x6   0xBF02             ITTT     EQ
   \        0x8   0x6A09             LDREQ    R1,[R1, #+32]
   \        0xA   0xF240 0x4244      MOVWEQ   R2,#+1092
   \        0xE   0x4211             TSTEQ    R1,R2
   \       0x10   0x....'....        BL       ?Subroutine16
   1231          
   1232          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1233            if (htim->PWM_MspDeInitCallback == NULL)
   1234            {
   1235              htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
   1236            }
   1237            /* DeInit the low level hardware */
   1238            htim->PWM_MspDeInitCallback(htim);
   1239          #else
   1240            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1241            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x14   0x....'....        BL       HAL_TIM_PWM_MspDeInit
   1242          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1243          
   1244            /* Change TIM state */
   1245            htim->State = HAL_TIM_STATE_RESET;
   \       0x18   0x....             B.N      ?Subroutine10
   1246          
   1247            /* Release Lock */
   1248            __HAL_UNLOCK(htim);
   1249          
   1250            return HAL_OK;
   1251          }
   1252          
   1253          /**
   1254            * @brief  Initializes the TIM PWM MSP.
   1255            * @param  htim TIM PWM handle
   1256            * @retval None
   1257            */

   \                                 In section .text, align 2
   1258          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1259          {
   1260            /* Prevent unused argument(s) compilation warning */
   1261            UNUSED(htim);
   1262          
   1263            /* NOTE : This function should not be modified, when the callback is needed,
   1264                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1265             */
   1266          }
   \                     HAL_TIM_PWM_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1267          
   1268          /**
   1269            * @brief  DeInitializes TIM PWM MSP.
   1270            * @param  htim TIM PWM handle
   1271            * @retval None
   1272            */

   \                                 In section .text, align 2
   1273          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1274          {
   1275            /* Prevent unused argument(s) compilation warning */
   1276            UNUSED(htim);
   1277          
   1278            /* NOTE : This function should not be modified, when the callback is needed,
   1279                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1280             */
   1281          }
   \                     HAL_TIM_PWM_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1282          
   1283          /**
   1284            * @brief  Starts the PWM signal generation.
   1285            * @param  htim TIM handle
   1286            * @param  Channel TIM Channels to be enabled
   1287            *          This parameter can be one of the following values:
   1288            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1289            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1290            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1291            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1292            * @retval HAL status
   1293            */

   \                                 In section .text, align 2, keep-with-next
   1294          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1295          {
   \                     HAL_TIM_PWM_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine29
   1296            uint32_t tmpsmcr;
   1297          
   1298            /* Check the parameters */
   1299            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1300          
   1301            /* Enable the Capture compare channel */
   1302            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1303          
   1304            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_68: (+1)
   \        0x6   0x....'....        BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_94: (+1)
   \        0xA   0xBF1C             ITT      NE
   \        0xC   0x....'....        LDRNE.W  R2,??DataTable22_3  ;; 0x40010400
   \       0x10   0x4290             CMPNE    R0,R2
   \       0x12   0x....             B.N      ?Subroutine5
   1305            {
   1306              /* Enable the main output */
   1307              __HAL_TIM_MOE_ENABLE(htim);
   1308            }
   1309          
   1310            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1311            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1312            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1313            {
   1314              __HAL_TIM_ENABLE(htim);
   1315            }
   1316          
   1317            /* Return function status */
   1318            return HAL_OK;
   1319          }
   1320          
   1321          /**
   1322            * @brief  Stops the PWM signal generation.
   1323            * @param  htim TIM PWM handle
   1324            * @param  Channel TIM Channels to be disabled
   1325            *          This parameter can be one of the following values:
   1326            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1327            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1328            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1329            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1330            * @retval HAL status
   1331            */

   \                                 In section .text, align 2, keep-with-next
   1332          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1333          {
   \                     HAL_TIM_PWM_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....'....        BL       ?Subroutine30
   1334            /* Check the parameters */
   1335            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1336          
   1337            /* Disable the Capture compare channel */
   1338            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1339          
   1340            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_71: (+1)
   \        0x6   0x....'....        BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_102: (+1)
   \        0xA   0xBF1C             ITT      NE
   \        0xC   0x....'....        LDRNE.W  R5,??DataTable22_3  ;; 0x40010400
   \       0x10   0x42A8             CMPNE    R0,R5
   \       0x12   0x....'....        BL       ?Subroutine60
   \                     ??CrossCallReturnLabel_162: (+1)
   \       0x16   0xD106             BNE.N    ??CrossCallReturnLabel_3
   1341            {
   1342              /* Disable the Main Output */
   1343              __HAL_TIM_MOE_DISABLE(htim);
   \       0x18   0x6A03             LDR      R3,[R0, #+32]
   \       0x1A   0x4213             TST      R3,R2
   \       0x1C   0xBF04             ITT      EQ
   \       0x1E   0x6A03             LDREQ    R3,[R0, #+32]
   \       0x20   0x420B             TSTEQ    R3,R1
   \       0x22   0x....'....        BL       ?Subroutine15
   1344            }
   1345          
   1346            /* Disable the Peripheral */
   1347            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6A03             LDR      R3,[R0, #+32]
   \       0x2A   0x4213             TST      R3,R2
   \       0x2C   0xBF04             ITT      EQ
   \       0x2E   0x6A00             LDREQ    R0,[R0, #+32]
   \       0x30   0x4208             TSTEQ    R0,R1
   \       0x32                      REQUIRE ?Subroutine2
   \       0x32                      ;; // Fall through to label ?Subroutine2
   1348          
   1349            /* Change the htim state */
   1350            htim->State = HAL_TIM_STATE_READY;
   1351          
   1352            /* Return function status */
   1353            return HAL_OK;
   1354          }
   1355          
   1356          /**
   1357            * @brief  Starts the PWM signal generation in interrupt mode.
   1358            * @param  htim TIM PWM handle
   1359            * @param  Channel TIM Channel to be enabled
   1360            *          This parameter can be one of the following values:
   1361            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1362            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1363            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1364            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1365            * @retval HAL status
   1366            */

   \                                 In section .text, align 2, keep-with-next
   1367          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1368          {
   \                     HAL_TIM_PWM_Start_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine27
   1369            uint32_t tmpsmcr;
   1370            /* Check the parameters */
   1371            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1372          
   1373            switch (Channel)
   1374            {
   1375              case TIM_CHANNEL_1:
   1376              {
   1377                /* Enable the TIM Capture/Compare 1 interrupt */
   1378                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1379                break;
   1380              }
   1381          
   1382              case TIM_CHANNEL_2:
   1383              {
   1384                /* Enable the TIM Capture/Compare 2 interrupt */
   1385                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1386                break;
   1387              }
   1388          
   1389              case TIM_CHANNEL_3:
   1390              {
   1391                /* Enable the TIM Capture/Compare 3 interrupt */
   1392                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1393                break;
   1394              }
   1395          
   1396              case TIM_CHANNEL_4:
   1397              {
   1398                /* Enable the TIM Capture/Compare 4 interrupt */
   1399                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1400                break;
   1401              }
   1402          
   1403              default:
   1404                break;
   1405            }
   1406          
   1407            /* Enable the Capture compare channel */
   1408            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1409          
   1410            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_62: (+1)
   \        0x6   0x....'....        BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_95: (+1)
   \        0xA   0xBF1C             ITT      NE
   \        0xC   0x....'....        LDRNE.W  R2,??DataTable22_3  ;; 0x40010400
   \       0x10   0x4290             CMPNE    R0,R2
   \       0x12   0x....             B.N      ?Subroutine5
   1411            {
   1412              /* Enable the main output */
   1413              __HAL_TIM_MOE_ENABLE(htim);
   1414            }
   1415          
   1416            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1417            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1418            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1419            {
   1420              __HAL_TIM_ENABLE(htim);
   1421            }
   1422          
   1423            /* Return function status */
   1424            return HAL_OK;
   1425          }
   1426          
   1427          /**
   1428            * @brief  Stops the PWM signal generation in interrupt mode.
   1429            * @param  htim TIM PWM handle
   1430            * @param  Channel TIM Channels to be disabled
   1431            *          This parameter can be one of the following values:
   1432            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1433            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1434            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1435            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1436            * @retval HAL status
   1437            */

   \                                 In section .text, align 2, keep-with-next
   1438          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1439          {
   \                     HAL_TIM_PWM_Stop_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine28
   1440            /* Check the parameters */
   1441            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1442          
   1443            switch (Channel)
   1444            {
   1445              case TIM_CHANNEL_1:
   1446              {
   1447                /* Disable the TIM Capture/Compare 1 interrupt */
   1448                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1449                break;
   1450              }
   1451          
   1452              case TIM_CHANNEL_2:
   1453              {
   1454                /* Disable the TIM Capture/Compare 2 interrupt */
   1455                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1456                break;
   1457              }
   1458          
   1459              case TIM_CHANNEL_3:
   1460              {
   1461                /* Disable the TIM Capture/Compare 3 interrupt */
   1462                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1463                break;
   1464              }
   1465          
   1466              case TIM_CHANNEL_4:
   1467              {
   1468                /* Disable the TIM Capture/Compare 4 interrupt */
   1469                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1470                break;
   1471              }
   1472          
   1473              default:
   1474                break;
   1475            }
   1476          
   1477            /* Disable the Capture compare channel */
   1478            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1479          
   1480            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_65: (+1)
   \        0x6   0x....'....        BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_103: (+1)
   \        0xA   0xBF1C             ITT      NE
   \        0xC   0x....'....        LDRNE.W  R4,??DataTable22_3  ;; 0x40010400
   \       0x10   0x42A0             CMPNE    R0,R4
   \       0x12   0x....'....        BL       ?Subroutine60
   \                     ??CrossCallReturnLabel_163: (+1)
   \       0x16   0xD106             BNE.N    ??CrossCallReturnLabel_4
   1481            {
   1482              /* Disable the Main Output */
   1483              __HAL_TIM_MOE_DISABLE(htim);
   \       0x18   0x6A03             LDR      R3,[R0, #+32]
   \       0x1A   0x4213             TST      R3,R2
   \       0x1C   0xBF04             ITT      EQ
   \       0x1E   0x6A03             LDREQ    R3,[R0, #+32]
   \       0x20   0x420B             TSTEQ    R3,R1
   \       0x22   0x....'....        BL       ?Subroutine15
   1484            }
   1485          
   1486            /* Disable the Peripheral */
   1487            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x26   0x6A03             LDR      R3,[R0, #+32]
   \       0x28   0x4213             TST      R3,R2
   \       0x2A   0xBF04             ITT      EQ
   \       0x2C   0x6A02             LDREQ    R2,[R0, #+32]
   \       0x2E   0x420A             TSTEQ    R2,R1
   \       0x30   0x....             B.N      ?Subroutine7
   1488          
   1489            /* Return function status */
   1490            return HAL_OK;
   1491          }
   1492          
   1493          /**
   1494            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1495            * @param  htim TIM PWM handle
   1496            * @param  Channel TIM Channels to be enabled
   1497            *          This parameter can be one of the following values:
   1498            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1499            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1500            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1501            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1502            * @param  pData The source Buffer address.
   1503            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1504            * @retval HAL status
   1505            */

   \                                 In section .text, align 2, keep-with-next
   1506          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1507          {
   \                     HAL_TIM_PWM_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine31
   1508            uint32_t tmpsmcr;
   1509          
   1510            /* Check the parameters */
   1511            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1512          
   1513            if (htim->State == HAL_TIM_STATE_BUSY)
   \                     ??CrossCallReturnLabel_74: (+1)
   \        0x6   0xD036             BEQ.N    ??CrossCallReturnLabel_15
   1514            {
   1515              return HAL_BUSY;
   1516            }
   1517            else if (htim->State == HAL_TIM_STATE_READY)
   \        0x8   0x....'....        BL       ?Subroutine32
   \                     ??CrossCallReturnLabel_77: (+1)
   \        0xC   0xD104             BNE.N    ??CrossCallReturnLabel_81
   1518            {
   1519              if ((pData == NULL) && (Length > 0U))
   \        0xE   0xB909             CBNZ.N   R1,??HAL_TIM_PWM_Start_DMA_0
   \       0x10   0x0018             MOVS     R0,R3
   \       0x12   0xD121             BNE.N    ??HAL_TIM_PWM_Start_DMA_1
   1520              {
   1521                return HAL_ERROR;
   1522              }
   1523              else
   1524              {
   1525                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_0: (+1)
   \       0x14   0x....'....        BL       ?Subroutine33
   1526              }
   1527            }
   1528            else
   1529            {
   1530              /* nothing to do */
   1531            }
   1532          
   1533            switch (Channel)
   \                     ??CrossCallReturnLabel_81: (+1)
   \       0x18   0x....'....        BL       ?Subroutine61
   \                     ??CrossCallReturnLabel_168: (+1)
   \       0x1C   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_DMA_2
   \       0x1E   0x2D04             CMP      R5,#+4
   \       0x20   0xD00B             BEQ.N    ??HAL_TIM_PWM_Start_DMA_3
   \       0x22   0x2D08             CMP      R5,#+8
   \       0x24   0xD00F             BEQ.N    ??HAL_TIM_PWM_Start_DMA_4
   \       0x26   0x2D0C             CMP      R5,#+12
   \       0x28   0xD013             BEQ.N    ??HAL_TIM_PWM_Start_DMA_5
   \       0x2A   0xE01A             B.N      ??HAL_TIM_PWM_Start_DMA_6
   1534            {
   1535              case TIM_CHANNEL_1:
   1536              {
   1537                /* Set the DMA compare callbacks */
   1538                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_2: (+1)
   \       0x2C   0x....'....        BL       ?Subroutine34
   1539                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1540          
   1541                /* Set the DMA error callback */
   1542                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   1543          
   1544                /* Enable the DMA stream */
   1545                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_223: (+1)
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD111             BNE.N    ??HAL_TIM_PWM_Start_DMA_1
   1546                {
   1547                  return HAL_ERROR;
   1548                }
   1549          
   1550                /* Enable the TIM Capture/Compare 1 DMA request */
   1551                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \       0x34   0x....'....        BL       ?Subroutine50
   1552                break;
   1553              }
   \                     ??CrossCallReturnLabel_134: (+1)
   \       0x38   0xE012             B.N      ??CrossCallReturnLabel_143
   1554          
   1555              case TIM_CHANNEL_2:
   1556              {
   1557                /* Set the DMA compare callbacks */
   1558                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_3: (+1)
   \       0x3A   0x....'....        BL       ?Subroutine35
   1559                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1560          
   1561                /* Set the DMA error callback */
   1562                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   1563          
   1564                /* Enable the DMA stream */
   1565                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_220: (+1)
   \       0x3E   0xB958             CBNZ.N   R0,??HAL_TIM_PWM_Start_DMA_1
   1566                {
   1567                  return HAL_ERROR;
   1568                }
   1569                /* Enable the TIM Capture/Compare 2 DMA request */
   1570                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \       0x40   0x....'....        BL       ?Subroutine51
   1571                break;
   1572              }
   \                     ??CrossCallReturnLabel_137: (+1)
   \       0x44   0xE00C             B.N      ??CrossCallReturnLabel_143
   1573          
   1574              case TIM_CHANNEL_3:
   1575              {
   1576                /* Set the DMA compare callbacks */
   1577                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_4: (+1)
   \       0x46   0x....'....        BL       ?Subroutine36
   1578                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1579          
   1580                /* Set the DMA error callback */
   1581                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1582          
   1583                /* Enable the DMA stream */
   1584                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_217: (+1)
   \       0x4A   0xB928             CBNZ.N   R0,??HAL_TIM_PWM_Start_DMA_1
   1585                {
   1586                  return HAL_ERROR;
   1587                }
   1588                /* Enable the TIM Output Capture/Compare 3 request */
   1589                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \       0x4C   0x....'....        BL       ?Subroutine52
   1590                break;
   1591              }
   \                     ??CrossCallReturnLabel_140: (+1)
   \       0x50   0xE006             B.N      ??CrossCallReturnLabel_143
   1592          
   1593              case TIM_CHANNEL_4:
   1594              {
   1595                /* Set the DMA compare callbacks */
   1596                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_5: (+1)
   \       0x52   0x....'....        BL       ?Subroutine37
   1597                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1598          
   1599                /* Set the DMA error callback */
   1600                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1601          
   1602                /* Enable the DMA stream */
   1603                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_214: (+1)
   \       0x56   0xB108             CBZ.N    R0,??HAL_TIM_PWM_Start_DMA_7
   1604                {
   1605                  return HAL_ERROR;
   \                     ??HAL_TIM_PWM_Start_DMA_1: (+1)
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xBDF2             POP      {R1,R4-R7,PC}
   1606                }
   1607                /* Enable the TIM Capture/Compare 4 DMA request */
   1608                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Start_DMA_7: (+1)
   \       0x5C   0x....'....        BL       ?Subroutine53
   \                     ??CrossCallReturnLabel_143: (+1)
   \       0x60   0x60C1             STR      R1,[R0, #+12]
   1609                break;
   1610              }
   1611          
   1612              default:
   1613                break;
   1614            }
   1615          
   1616            /* Enable the Capture compare channel */
   1617            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_6: (+1)
   \       0x62   0x....'....        BL       ?Subroutine47
   1618          
   1619            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_125: (+1)
   \       0x66   0x....'....        BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_96: (+1)
   \       0x6A   0xBF1C             ITT      NE
   \       0x6C   0x....'....        LDRNE.W  R2,??DataTable22_3  ;; 0x40010400
   \       0x70   0x4290             CMPNE    R0,R2
   \       0x72   0x....'....        BL       ?Subroutine17
   1620            {
   1621              /* Enable the main output */
   1622              __HAL_TIM_MOE_ENABLE(htim);
   1623            }
   1624          
   1625            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1626            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1627            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1628            {
   1629              __HAL_TIM_ENABLE(htim);
   1630            }
   1631          
   1632            /* Return function status */
   1633            return HAL_OK;
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x76   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1634          }
   1635          
   1636          /**
   1637            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1638            * @param  htim TIM PWM handle
   1639            * @param  Channel TIM Channels to be disabled
   1640            *          This parameter can be one of the following values:
   1641            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1642            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1643            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1644            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1645            * @retval HAL status
   1646            */

   \                                 In section .text, align 2, keep-with-next
   1647          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1648          {
   \                     HAL_TIM_PWM_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x000D             MOVS     R5,R1
   \        0x4   0x4604             MOV      R4,R0
   1649            /* Check the parameters */
   1650            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1651          
   1652            switch (Channel)
   \        0x6   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_0
   \        0x8   0x2D04             CMP      R5,#+4
   \        0xA   0xD007             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_1
   \        0xC   0x2D08             CMP      R5,#+8
   \        0xE   0xD008             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_2
   \       0x10   0x2D0C             CMP      R5,#+12
   \       0x12   0xD009             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_3
   \       0x14   0xE00C             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1653            {
   1654              case TIM_CHANNEL_1:
   1655              {
   1656                /* Disable the TIM Capture/Compare 1 DMA request */
   1657                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Stop_DMA_0: (+1)
   \       0x16   0x....'....        BL       ?Subroutine42
   1658                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   1659                break;
   1660              }
   \                     ??CrossCallReturnLabel_108: (+1)
   \       0x1A   0xE007             B.N      ??CrossCallReturnLabel_122
   1661          
   1662              case TIM_CHANNEL_2:
   1663              {
   1664                /* Disable the TIM Capture/Compare 2 DMA request */
   1665                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Stop_DMA_1: (+1)
   \       0x1C   0x....'....        BL       ?Subroutine44
   1666                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   1667                break;
   1668              }
   \                     ??CrossCallReturnLabel_116: (+1)
   \       0x20   0xE004             B.N      ??CrossCallReturnLabel_122
   1669          
   1670              case TIM_CHANNEL_3:
   1671              {
   1672                /* Disable the TIM Capture/Compare 3 DMA request */
   1673                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Stop_DMA_2: (+1)
   \       0x22   0x....'....        BL       ?Subroutine45
   1674                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   1675                break;
   1676              }
   \                     ??CrossCallReturnLabel_119: (+1)
   \       0x26   0xE001             B.N      ??CrossCallReturnLabel_122
   1677          
   1678              case TIM_CHANNEL_4:
   1679              {
   1680                /* Disable the TIM Capture/Compare 4 interrupt */
   1681                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Stop_DMA_3: (+1)
   \       0x28   0x....'....        BL       ?Subroutine46
   1682                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??CrossCallReturnLabel_122: (+1)
   \       0x2C   0x....'....        BL       HAL_DMA_Abort_IT
   1683                break;
   1684              }
   1685          
   1686              default:
   1687                break;
   1688            }
   1689          
   1690            /* Disable the Capture compare channel */
   1691            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_DMA_4: (+1)
   \       0x30   0x....'....        BL       ?Subroutine48
   1692          
   1693            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_128: (+1)
   \       0x34   0x....'....        BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_104: (+1)
   \       0x38   0xBF1C             ITT      NE
   \       0x3A   0x....'....        LDRNE.W  R5,??DataTable22_3  ;; 0x40010400
   \       0x3E   0x42A8             CMPNE    R0,R5
   \       0x40   0x....'....        BL       ?Subroutine60
   \                     ??CrossCallReturnLabel_164: (+1)
   \       0x44   0xD106             BNE.N    ??CrossCallReturnLabel_5
   1694            {
   1695              /* Disable the Main Output */
   1696              __HAL_TIM_MOE_DISABLE(htim);
   \       0x46   0x6A03             LDR      R3,[R0, #+32]
   \       0x48   0x4213             TST      R3,R2
   \       0x4A   0xBF04             ITT      EQ
   \       0x4C   0x6A03             LDREQ    R3,[R0, #+32]
   \       0x4E   0x420B             TSTEQ    R3,R1
   \       0x50   0x....'....        BL       ?Subroutine15
   1697            }
   1698          
   1699            /* Disable the Peripheral */
   1700            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6A03             LDR      R3,[R0, #+32]
   \       0x58   0x4213             TST      R3,R2
   \       0x5A   0xBF04             ITT      EQ
   \       0x5C   0x6A00             LDREQ    R0,[R0, #+32]
   \       0x5E   0x4208             TSTEQ    R0,R1
   \       0x60   0x....             B.N      ?Subroutine2
   1701          
   1702            /* Change the htim state */
   1703            htim->State = HAL_TIM_STATE_READY;
   1704          
   1705            /* Return function status */
   1706            return HAL_OK;
   1707          }
   1708          
   1709          /**
   1710            * @}
   1711            */
   1712          
   1713          /** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions
   1714            *  @brief    TIM Input Capture functions
   1715            *
   1716          @verbatim
   1717            ==============================================================================
   1718                        ##### TIM Input Capture functions #####
   1719            ==============================================================================
   1720           [..]
   1721             This section provides functions allowing to:
   1722             (+) Initialize and configure the TIM Input Capture.
   1723             (+) De-initialize the TIM Input Capture.
   1724             (+) Start the TIM Input Capture.
   1725             (+) Stop the TIM Input Capture.
   1726             (+) Start the TIM Input Capture and enable interrupt.
   1727             (+) Stop the TIM Input Capture and disable interrupt.
   1728             (+) Start the TIM Input Capture and enable DMA transfer.
   1729             (+) Stop the TIM Input Capture and disable DMA transfer.
   1730          
   1731          @endverbatim
   1732            * @{
   1733            */
   1734          /**
   1735            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1736            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1737            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1738            *         requires a timer reset to avoid unexpected direction
   1739            *         due to DIR bit readonly in center aligned mode.
   1740            *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
   1741            * @param  htim TIM Input Capture handle
   1742            * @retval HAL status
   1743            */

   \                                 In section .text, align 2, keep-with-next
   1744          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1745          {
   \                     HAL_TIM_IC_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1746            /* Check the TIM handle allocation */
   1747            if (htim == NULL)
   \        0x4   0xD101             BNE.N    ??HAL_TIM_IC_Init_0
   1748            {
   1749              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
   1750            }
   1751          
   1752            /* Check the parameters */
   1753            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1754            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1755            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1756            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1757          
   1758            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_IC_Init_0: (+1)
   \        0xA   0x....'....        BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_31: (+1)
   \        0xE   0xB918             CBNZ.N   R0,??HAL_TIM_IC_Init_1
   1759            {
   1760              /* Allocate lock resource and initialize it */
   1761              htim->Lock = HAL_UNLOCKED;
   \       0x10   0x....'....        BL       ?Subroutine21
   1762          
   1763          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1764              /* Reset interrupt callbacks to legacy weak callbacks */
   1765              TIM_ResetCallback(htim);
   1766          
   1767              if (htim->IC_MspInitCallback == NULL)
   1768              {
   1769                htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
   1770              }
   1771              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1772              htim->IC_MspInitCallback(htim);
   1773          #else
   1774              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1775              HAL_TIM_IC_MspInit(htim);
   1776          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1777            }
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x14   0x....'....        BL       HAL_TIM_IC_MspInit
   1778          
   1779            /* Set the TIM state */
   1780            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Init_1: (+1)
   \       0x18   0x....             B.N      ?Subroutine3
   1781          
   1782            /* Init the base time for the input capture */
   1783            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   1784          
   1785            /* Initialize the TIM state*/
   1786            htim->State = HAL_TIM_STATE_READY;
   1787          
   1788            return HAL_OK;
   1789          }
   1790          
   1791          /**
   1792            * @brief  DeInitializes the TIM peripheral
   1793            * @param  htim TIM Input Capture handle
   1794            * @retval HAL status
   1795            */

   \                                 In section .text, align 2, keep-with-next
   1796          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1797          {
   \                     HAL_TIM_IC_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1798            /* Check the parameters */
   1799            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1800          
   1801            htim->State = HAL_TIM_STATE_BUSY;
   \        0x2   0x....'....        BL       ?Subroutine24
   1802          
   1803            /* Disable the TIM Peripheral Clock */
   1804            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_48: (+1)
   \        0x6   0xBF02             ITTT     EQ
   \        0x8   0x6A09             LDREQ    R1,[R1, #+32]
   \        0xA   0xF240 0x4244      MOVWEQ   R2,#+1092
   \        0xE   0x4211             TSTEQ    R1,R2
   \       0x10   0x....'....        BL       ?Subroutine16
   1805          
   1806          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1807            if (htim->IC_MspDeInitCallback == NULL)
   1808            {
   1809              htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
   1810            }
   1811            /* DeInit the low level hardware */
   1812            htim->IC_MspDeInitCallback(htim);
   1813          #else
   1814            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1815            HAL_TIM_IC_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x14   0x....'....        BL       HAL_TIM_IC_MspDeInit
   1816          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1817          
   1818            /* Change TIM state */
   1819            htim->State = HAL_TIM_STATE_RESET;
   \       0x18   0x....             B.N      ?Subroutine10
   1820          
   1821            /* Release Lock */
   1822            __HAL_UNLOCK(htim);
   1823          
   1824            return HAL_OK;
   1825          }
   1826          
   1827          /**
   1828            * @brief  Initializes the TIM Input Capture MSP.
   1829            * @param  htim TIM Input Capture handle
   1830            * @retval None
   1831            */

   \                                 In section .text, align 2
   1832          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1833          {
   1834            /* Prevent unused argument(s) compilation warning */
   1835            UNUSED(htim);
   1836          
   1837            /* NOTE : This function should not be modified, when the callback is needed,
   1838                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1839             */
   1840          }
   \                     HAL_TIM_IC_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1841          
   1842          /**
   1843            * @brief  DeInitializes TIM Input Capture MSP.
   1844            * @param  htim TIM handle
   1845            * @retval None
   1846            */

   \                                 In section .text, align 2
   1847          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1848          {
   1849            /* Prevent unused argument(s) compilation warning */
   1850            UNUSED(htim);
   1851          
   1852            /* NOTE : This function should not be modified, when the callback is needed,
   1853                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1854             */
   1855          }
   \                     HAL_TIM_IC_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1856          
   1857          /**
   1858            * @brief  Starts the TIM Input Capture measurement.
   1859            * @param  htim TIM Input Capture handle
   1860            * @param  Channel TIM Channels to be enabled
   1861            *          This parameter can be one of the following values:
   1862            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1863            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1864            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1865            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1866            * @retval HAL status
   1867            */

   \                                 In section .text, align 2, keep-with-next
   1868          HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1869          {
   \                     HAL_TIM_IC_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine29
   1870            uint32_t tmpsmcr;
   1871          
   1872            /* Check the parameters */
   1873            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1874          
   1875            /* Enable the Input Capture channel */
   1876            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1877          
   1878            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1879            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??CrossCallReturnLabel_67: (+1)
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x....             B.N      ??Subroutine5_0
   1880            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1881            {
   1882              __HAL_TIM_ENABLE(htim);
   1883            }
   1884          
   1885            /* Return function status */
   1886            return HAL_OK;
   1887          }
   1888          
   1889          /**
   1890            * @brief  Stops the TIM Input Capture measurement.
   1891            * @param  htim TIM Input Capture handle
   1892            * @param  Channel TIM Channels to be disabled
   1893            *          This parameter can be one of the following values:
   1894            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1895            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1896            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1897            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1898            * @retval HAL status
   1899            */

   \                                 In section .text, align 2, keep-with-next
   1900          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1901          {
   \                     HAL_TIM_IC_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine30
   1902            /* Check the parameters */
   1903            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1904          
   1905            /* Disable the Input Capture channel */
   1906            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1907          
   1908            /* Disable the Peripheral */
   1909            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_70: (+1)
   \        0x6   0x....'....        BL       ?Subroutine39
   \                     ??CrossCallReturnLabel_86: (+1)
   \        0xA   0xBF02             ITTT     EQ
   \        0xC   0x6A01             LDREQ    R1,[R0, #+32]
   \        0xE   0xF240 0x4244      MOVWEQ   R2,#+1092
   \       0x12   0x4211             TSTEQ    R1,R2
   \       0x14   0x....             B.N      ?Subroutine7
   1910          
   1911            /* Return function status */
   1912            return HAL_OK;
   1913          }
   1914          
   1915          /**
   1916            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1917            * @param  htim TIM Input Capture handle
   1918            * @param  Channel TIM Channels to be enabled
   1919            *          This parameter can be one of the following values:
   1920            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1921            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1922            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1923            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1924            * @retval HAL status
   1925            */

   \                                 In section .text, align 2, keep-with-next
   1926          HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1927          {
   \                     HAL_TIM_IC_Start_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine27
   1928            uint32_t tmpsmcr;
   1929          
   1930            /* Check the parameters */
   1931            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1932          
   1933            switch (Channel)
   1934            {
   1935              case TIM_CHANNEL_1:
   1936              {
   1937                /* Enable the TIM Capture/Compare 1 interrupt */
   1938                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1939                break;
   1940              }
   1941          
   1942              case TIM_CHANNEL_2:
   1943              {
   1944                /* Enable the TIM Capture/Compare 2 interrupt */
   1945                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1946                break;
   1947              }
   1948          
   1949              case TIM_CHANNEL_3:
   1950              {
   1951                /* Enable the TIM Capture/Compare 3 interrupt */
   1952                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1953                break;
   1954              }
   1955          
   1956              case TIM_CHANNEL_4:
   1957              {
   1958                /* Enable the TIM Capture/Compare 4 interrupt */
   1959                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1960                break;
   1961              }
   1962          
   1963              default:
   1964                break;
   1965            }
   1966            /* Enable the Input Capture channel */
   1967            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1968          
   1969            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1970            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??CrossCallReturnLabel_61: (+1)
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x....             B.N      ??Subroutine5_0
   1971            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1972            {
   1973              __HAL_TIM_ENABLE(htim);
   1974            }
   1975          
   1976            /* Return function status */
   1977            return HAL_OK;
   1978          }
   1979          
   1980          /**
   1981            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1982            * @param  htim TIM Input Capture handle
   1983            * @param  Channel TIM Channels to be disabled
   1984            *          This parameter can be one of the following values:
   1985            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1986            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1987            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1988            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1989            * @retval HAL status
   1990            */

   \                                 In section .text, align 2, keep-with-next
   1991          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1992          {
   \                     HAL_TIM_IC_Stop_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine28
   1993            /* Check the parameters */
   1994            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1995          
   1996            switch (Channel)
   1997            {
   1998              case TIM_CHANNEL_1:
   1999              {
   2000                /* Disable the TIM Capture/Compare 1 interrupt */
   2001                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2002                break;
   2003              }
   2004          
   2005              case TIM_CHANNEL_2:
   2006              {
   2007                /* Disable the TIM Capture/Compare 2 interrupt */
   2008                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2009                break;
   2010              }
   2011          
   2012              case TIM_CHANNEL_3:
   2013              {
   2014                /* Disable the TIM Capture/Compare 3 interrupt */
   2015                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   2016                break;
   2017              }
   2018          
   2019              case TIM_CHANNEL_4:
   2020              {
   2021                /* Disable the TIM Capture/Compare 4 interrupt */
   2022                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   2023                break;
   2024              }
   2025          
   2026              default:
   2027                break;
   2028            }
   2029          
   2030            /* Disable the Input Capture channel */
   2031            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   2032          
   2033            /* Disable the Peripheral */
   2034            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_64: (+1)
   \        0x6   0x....'....        BL       ?Subroutine39
   \                     ??CrossCallReturnLabel_87: (+1)
   \        0xA   0xBF02             ITTT     EQ
   \        0xC   0x6A01             LDREQ    R1,[R0, #+32]
   \        0xE   0xF240 0x4244      MOVWEQ   R2,#+1092
   \       0x12   0x4211             TSTEQ    R1,R2
   \       0x14   0x....             B.N      ?Subroutine7
   2035          
   2036            /* Return function status */
   2037            return HAL_OK;
   2038          }
   2039          
   2040          /**
   2041            * @brief  Starts the TIM Input Capture measurement in DMA mode.
   2042            * @param  htim TIM Input Capture handle
   2043            * @param  Channel TIM Channels to be enabled
   2044            *          This parameter can be one of the following values:
   2045            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2046            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2047            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2048            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2049            * @param  pData The destination Buffer address.
   2050            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2051            * @retval HAL status
   2052            */

   \                                 In section .text, align 2, keep-with-next
   2053          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   2054          {
   \                     HAL_TIM_IC_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   2055            uint32_t tmpsmcr;
   2056          
   2057            /* Check the parameters */
   2058            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2059            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2060          
   2061            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0x6   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD05D             BEQ.N    ??HAL_TIM_IC_Start_DMA_0
   2062            {
   2063              return HAL_BUSY;
   2064            }
   2065            else if (htim->State == HAL_TIM_STATE_READY)
   \        0xE   0x....'....        BL       ?Subroutine32
   \                     ??CrossCallReturnLabel_78: (+1)
   \       0x12   0xD104             BNE.N    ??CrossCallReturnLabel_82
   2066            {
   2067              if ((pData == NULL) && (Length > 0U))
   \       0x14   0xB90A             CBNZ.N   R2,??HAL_TIM_IC_Start_DMA_1
   \       0x16   0x0018             MOVS     R0,R3
   \       0x18   0xD149             BNE.N    ??HAL_TIM_IC_Start_DMA_2
   2068              {
   2069                return HAL_ERROR;
   2070              }
   2071              else
   2072              {
   2073                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_1: (+1)
   \       0x1A   0x....'....        BL       ?Subroutine33
   2074              }
   2075            }
   2076            else
   2077            {
   2078              /* nothing to do */
   2079            }
   2080          
   2081            switch (Channel)
   \                     ??CrossCallReturnLabel_82: (+1)
   \       0x1E   0x002F             MOVS     R7,R5
   \       0x20   0x....             LDR.N    R0,??DataTable22_2
   \       0x22   0x....'....        LDR.W    R1,??DataTable24
   \       0x26   0x....'....        LDR.W    R6,??DataTable24_1
   \       0x2A   0xD006             BEQ.N    ??HAL_TIM_IC_Start_DMA_3
   \       0x2C   0x2D04             CMP      R5,#+4
   \       0x2E   0xD014             BEQ.N    ??HAL_TIM_IC_Start_DMA_4
   \       0x30   0x2D08             CMP      R5,#+8
   \       0x32   0xD021             BEQ.N    ??HAL_TIM_IC_Start_DMA_5
   \       0x34   0x2D0C             CMP      R5,#+12
   \       0x36   0xD02E             BEQ.N    ??HAL_TIM_IC_Start_DMA_6
   \       0x38   0xE03E             B.N      ??HAL_TIM_IC_Start_DMA_7
   2082            {
   2083              case TIM_CHANNEL_1:
   2084              {
   2085                /* Set the DMA capture callbacks */
   2086                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_3: (+1)
   \       0x3A   0x6A67             LDR      R7,[R4, #+36]
   \       0x3C   0x63FE             STR      R6,[R7, #+60]
   2087                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x3E   0x6A66             LDR      R6,[R4, #+36]
   \       0x40   0x6431             STR      R1,[R6, #+64]
   2088          
   2089                /* Set the DMA error callback */
   2090                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x42   0x6A67             LDR      R7,[R4, #+36]
   \       0x44   0x64F8             STR      R0,[R7, #+76]
   2091          
   2092                /* Enable the DMA stream */
   2093                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0xF100 0x0134      ADD      R1,R0,#+52
   \       0x4C   0x....'....        BL       ??Subroutine77_0
   \                     ??CrossCallReturnLabel_222: (+1)
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD12C             BNE.N    ??HAL_TIM_IC_Start_DMA_2
   2094                {
   2095                  return HAL_ERROR;
   2096                }
   2097                /* Enable the TIM Capture/Compare 1 DMA request */
   2098                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \       0x54   0x....'....        BL       ?Subroutine50
   2099                break;
   2100              }
   \                     ??CrossCallReturnLabel_135: (+1)
   \       0x58   0xE02D             B.N      ??CrossCallReturnLabel_144
   2101          
   2102              case TIM_CHANNEL_2:
   2103              {
   2104                /* Set the DMA capture callbacks */
   2105                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_4: (+1)
   \       0x5A   0x6AA7             LDR      R7,[R4, #+40]
   \       0x5C   0x63FE             STR      R6,[R7, #+60]
   2106                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x5E   0x6AA6             LDR      R6,[R4, #+40]
   \       0x60   0x6431             STR      R1,[R6, #+64]
   2107          
   2108                /* Set the DMA error callback */
   2109                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x62   0x6AA1             LDR      R1,[R4, #+40]
   \       0x64   0x64C8             STR      R0,[R1, #+76]
   2110          
   2111                /* Enable the DMA stream */
   2112                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length) != HAL_OK)
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0xF100 0x0138      ADD      R1,R0,#+56
   \       0x6C   0x....'....        BL       ??Subroutine76_0
   \                     ??CrossCallReturnLabel_219: (+1)
   \       0x70   0xB9E8             CBNZ.N   R0,??HAL_TIM_IC_Start_DMA_2
   2113                {
   2114                  return HAL_ERROR;
   2115                }
   2116                /* Enable the TIM Capture/Compare 2  DMA request */
   2117                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \       0x72   0x....'....        BL       ?Subroutine51
   2118                break;
   2119              }
   \                     ??CrossCallReturnLabel_138: (+1)
   \       0x76   0xE01E             B.N      ??CrossCallReturnLabel_144
   2120          
   2121              case TIM_CHANNEL_3:
   2122              {
   2123                /* Set the DMA capture callbacks */
   2124                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_5: (+1)
   \       0x78   0x6AE7             LDR      R7,[R4, #+44]
   \       0x7A   0x63FE             STR      R6,[R7, #+60]
   2125                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x7C   0x6AE6             LDR      R6,[R4, #+44]
   \       0x7E   0x6431             STR      R1,[R6, #+64]
   2126          
   2127                /* Set the DMA error callback */
   2128                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0x80   0x6AE1             LDR      R1,[R4, #+44]
   \       0x82   0x64C8             STR      R0,[R1, #+76]
   2129          
   2130                /* Enable the DMA stream */
   2131                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length) != HAL_OK)
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0xF100 0x013C      ADD      R1,R0,#+60
   \       0x8A   0x....'....        BL       ??Subroutine75_0
   \                     ??CrossCallReturnLabel_216: (+1)
   \       0x8E   0xB970             CBNZ.N   R0,??HAL_TIM_IC_Start_DMA_2
   2132                {
   2133                  return HAL_ERROR;
   2134                }
   2135                /* Enable the TIM Capture/Compare 3  DMA request */
   2136                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \       0x90   0x....'....        BL       ?Subroutine52
   2137                break;
   2138              }
   \                     ??CrossCallReturnLabel_141: (+1)
   \       0x94   0xE00F             B.N      ??CrossCallReturnLabel_144
   2139          
   2140              case TIM_CHANNEL_4:
   2141              {
   2142                /* Set the DMA capture callbacks */
   2143                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_6: (+1)
   \       0x96   0x6B27             LDR      R7,[R4, #+48]
   \       0x98   0x63FE             STR      R6,[R7, #+60]
   2144                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x9A   0x6B26             LDR      R6,[R4, #+48]
   \       0x9C   0x6431             STR      R1,[R6, #+64]
   2145          
   2146                /* Set the DMA error callback */
   2147                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \       0x9E   0x6B21             LDR      R1,[R4, #+48]
   \       0xA0   0x64C8             STR      R0,[R1, #+76]
   2148          
   2149                /* Enable the DMA stream */
   2150                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length) != HAL_OK)
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0xF100 0x0140      ADD      R1,R0,#+64
   \       0xA8   0x....'....        BL       ??Subroutine74_0
   \                     ??CrossCallReturnLabel_213: (+1)
   \       0xAC   0xB108             CBZ.N    R0,??HAL_TIM_IC_Start_DMA_8
   2151                {
   2152                  return HAL_ERROR;
   \                     ??HAL_TIM_IC_Start_DMA_2: (+1)
   \       0xAE   0x2001             MOVS     R0,#+1
   \       0xB0   0xBDF2             POP      {R1,R4-R7,PC}
   2153                }
   2154                /* Enable the TIM Capture/Compare 4  DMA request */
   2155                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Start_DMA_8: (+1)
   \       0xB2   0x....'....        BL       ?Subroutine53
   \                     ??CrossCallReturnLabel_144: (+1)
   \       0xB6   0x60C1             STR      R1,[R0, #+12]
   2156                break;
   2157              }
   2158          
   2159              default:
   2160                break;
   2161            }
   2162          
   2163            /* Enable the Input Capture channel */
   2164            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_7: (+1)
   \       0xB8   0x....'....        BL       ?Subroutine47
   2165          
   2166            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   2167            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??CrossCallReturnLabel_124: (+1)
   \       0xBC   0x....'....        BL       ?Subroutine57
   2168            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \                     ??CrossCallReturnLabel_152: (+1)
   \       0xC0   0xD002             BEQ.N    ??CrossCallReturnLabel_54
   2169            {
   2170              __HAL_TIM_ENABLE(htim);
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x....'....        BL       ??Subroutine25_1
   2171            }
   2172          
   2173            /* Return function status */
   2174            return HAL_OK;
   \                     ??CrossCallReturnLabel_54: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Start_DMA_0: (+1)
   \       0xCA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2175          }
   2176          
   2177          /**
   2178            * @brief  Stops the TIM Input Capture measurement in DMA mode.
   2179            * @param  htim TIM Input Capture handle
   2180            * @param  Channel TIM Channels to be disabled
   2181            *          This parameter can be one of the following values:
   2182            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2183            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2184            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2185            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2186            * @retval HAL status
   2187            */

   \                                 In section .text, align 2, keep-with-next
   2188          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2189          {
   \                     HAL_TIM_IC_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x000D             MOVS     R5,R1
   \        0x4   0x4604             MOV      R4,R0
   2190            /* Check the parameters */
   2191            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2192            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2193          
   2194            switch (Channel)
   \        0x6   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_DMA_0
   \        0x8   0x2D04             CMP      R5,#+4
   \        0xA   0xD007             BEQ.N    ??HAL_TIM_IC_Stop_DMA_1
   \        0xC   0x2D08             CMP      R5,#+8
   \        0xE   0xD008             BEQ.N    ??HAL_TIM_IC_Stop_DMA_2
   \       0x10   0x2D0C             CMP      R5,#+12
   \       0x12   0xD009             BEQ.N    ??HAL_TIM_IC_Stop_DMA_3
   \       0x14   0xE00C             B.N      ??HAL_TIM_IC_Stop_DMA_4
   2195            {
   2196              case TIM_CHANNEL_1:
   2197              {
   2198                /* Disable the TIM Capture/Compare 1 DMA request */
   2199                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Stop_DMA_0: (+1)
   \       0x16   0x....'....        BL       ?Subroutine42
   2200                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   2201                break;
   2202              }
   \                     ??CrossCallReturnLabel_109: (+1)
   \       0x1A   0xE007             B.N      ??CrossCallReturnLabel_123
   2203          
   2204              case TIM_CHANNEL_2:
   2205              {
   2206                /* Disable the TIM Capture/Compare 2 DMA request */
   2207                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Stop_DMA_1: (+1)
   \       0x1C   0x....'....        BL       ?Subroutine44
   2208                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   2209                break;
   2210              }
   \                     ??CrossCallReturnLabel_117: (+1)
   \       0x20   0xE004             B.N      ??CrossCallReturnLabel_123
   2211          
   2212              case TIM_CHANNEL_3:
   2213              {
   2214                /* Disable the TIM Capture/Compare 3  DMA request */
   2215                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Stop_DMA_2: (+1)
   \       0x22   0x....'....        BL       ?Subroutine45
   2216                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   2217                break;
   2218              }
   \                     ??CrossCallReturnLabel_120: (+1)
   \       0x26   0xE001             B.N      ??CrossCallReturnLabel_123
   2219          
   2220              case TIM_CHANNEL_4:
   2221              {
   2222                /* Disable the TIM Capture/Compare 4  DMA request */
   2223                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Stop_DMA_3: (+1)
   \       0x28   0x....'....        BL       ?Subroutine46
   2224                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??CrossCallReturnLabel_123: (+1)
   \       0x2C   0x....'....        BL       HAL_DMA_Abort_IT
   2225                break;
   2226              }
   2227          
   2228              default:
   2229                break;
   2230            }
   2231          
   2232            /* Disable the Input Capture channel */
   2233            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_DMA_4: (+1)
   \       0x30   0x....'....        BL       ?Subroutine48
   2234          
   2235            /* Disable the Peripheral */
   2236            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_127: (+1)
   \       0x34   0x....'....        BL       ?Subroutine39
   \                     ??CrossCallReturnLabel_88: (+1)
   \       0x38   0xBF02             ITTT     EQ
   \       0x3A   0x6A00             LDREQ    R0,[R0, #+32]
   \       0x3C   0xF240 0x4144      MOVWEQ   R1,#+1092
   \       0x40   0x4208             TSTEQ    R0,R1
   \       0x42   0xD104             BNE.N    ??HAL_TIM_IC_Stop_DMA_5
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6801             LDR      R1,[R0, #+0]
   \       0x48   0x0849             LSRS     R1,R1,#+1
   \       0x4A   0x0049             LSLS     R1,R1,#+1
   \       0x4C   0x6001             STR      R1,[R0, #+0]
   2237          
   2238            /* Change the htim state */
   2239            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_Stop_DMA_5: (+1)
   \       0x4E   0x....             B.N      ??Subroutine2_0
   2240          
   2241            /* Return function status */
   2242            return HAL_OK;
   2243          }
   2244          /**
   2245            * @}
   2246            */
   2247          
   2248          /** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions
   2249            *  @brief    TIM One Pulse functions
   2250            *
   2251          @verbatim
   2252            ==============================================================================
   2253                                  ##### TIM One Pulse functions #####
   2254            ==============================================================================
   2255            [..]
   2256              This section provides functions allowing to:
   2257              (+) Initialize and configure the TIM One Pulse.
   2258              (+) De-initialize the TIM One Pulse.
   2259              (+) Start the TIM One Pulse.
   2260              (+) Stop the TIM One Pulse.
   2261              (+) Start the TIM One Pulse and enable interrupt.
   2262              (+) Stop the TIM One Pulse and disable interrupt.
   2263              (+) Start the TIM One Pulse and enable DMA transfer.
   2264              (+) Stop the TIM One Pulse and disable DMA transfer.
   2265          
   2266          @endverbatim
   2267            * @{
   2268            */
   2269          /**
   2270            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   2271            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   2272            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2273            *         requires a timer reset to avoid unexpected direction
   2274            *         due to DIR bit readonly in center aligned mode.
   2275            *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()
   2276            * @param  htim TIM One Pulse handle
   2277            * @param  OnePulseMode Select the One pulse mode.
   2278            *         This parameter can be one of the following values:
   2279            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   2280            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   2281            * @retval HAL status
   2282            */

   \                                 In section .text, align 2, keep-with-next
   2283          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   2284          {
   \                     HAL_TIM_OnePulse_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460E             MOV      R6,R1
   2285            /* Check the TIM handle allocation */
   2286            if (htim == NULL)
   \        0x6   0xD101             BNE.N    ??HAL_TIM_OnePulse_Init_0
   2287            {
   2288              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xBD70             POP      {R4-R6,PC}
   2289            }
   2290          
   2291            /* Check the parameters */
   2292            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2293            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2294            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2295            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   2296            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2297          
   2298            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0: (+1)
   \        0xC   0x....'....        BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x10   0xB918             CBNZ.N   R0,??HAL_TIM_OnePulse_Init_1
   2299            {
   2300              /* Allocate lock resource and initialize it */
   2301              htim->Lock = HAL_UNLOCKED;
   \       0x12   0x....'....        BL       ?Subroutine21
   2302          
   2303          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2304              /* Reset interrupt callbacks to legacy weak callbacks */
   2305              TIM_ResetCallback(htim);
   2306          
   2307              if (htim->OnePulse_MspInitCallback == NULL)
   2308              {
   2309                htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;
   2310              }
   2311              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2312              htim->OnePulse_MspInitCallback(htim);
   2313          #else
   2314              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2315              HAL_TIM_OnePulse_MspInit(htim);
   2316          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2317            }
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0x16   0x....'....        BL       HAL_TIM_OnePulse_MspInit
   2318          
   2319            /* Set the TIM state */
   2320            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OnePulse_Init_1: (+1)
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x7068             STRB     R0,[R5, #+1]
   2321          
   2322            /* Configure the Time base in the One Pulse Mode */
   2323            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x1E   0x1D21             ADDS     R1,R4,#+4
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x....'....        BL       TIM_Base_SetConfig
   2324          
   2325            /* Reset the OPM Bit */
   2326            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6801             LDR      R1,[R0, #+0]
   \       0x2A   0xF021 0x0108      BIC      R1,R1,#0x8
   \       0x2E   0x6001             STR      R1,[R0, #+0]
   2327          
   2328            /* Configure the OPM Mode */
   2329            htim->Instance->CR1 |= OnePulseMode;
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6802             LDR      R2,[R0, #+0]
   \       0x34   0x4316             ORRS     R6,R6,R2
   \       0x36   0x6006             STR      R6,[R0, #+0]
   2330          
   2331            /* Initialize the TIM state*/
   2332            htim->State = HAL_TIM_STATE_READY;
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0x7068             STRB     R0,[R5, #+1]
   2333          
   2334            return HAL_OK;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return
   2335          }
   2336          
   2337          /**
   2338            * @brief  DeInitializes the TIM One Pulse
   2339            * @param  htim TIM One Pulse handle
   2340            * @retval HAL status
   2341            */

   \                                 In section .text, align 2, keep-with-next
   2342          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2343          {
   \                     HAL_TIM_OnePulse_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   2344            /* Check the parameters */
   2345            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2346          
   2347            htim->State = HAL_TIM_STATE_BUSY;
   \        0x2   0x....'....        BL       ?Subroutine24
   2348          
   2349            /* Disable the TIM Peripheral Clock */
   2350            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_49: (+1)
   \        0x6   0xBF02             ITTT     EQ
   \        0x8   0x6A09             LDREQ    R1,[R1, #+32]
   \        0xA   0xF240 0x4244      MOVWEQ   R2,#+1092
   \        0xE   0x4211             TSTEQ    R1,R2
   \       0x10   0x....'....        BL       ?Subroutine16
   2351          
   2352          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2353            if (htim->OnePulse_MspDeInitCallback == NULL)
   2354            {
   2355              htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
   2356            }
   2357            /* DeInit the low level hardware */
   2358            htim->OnePulse_MspDeInitCallback(htim);
   2359          #else
   2360            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2361            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x14   0x....'....        BL       HAL_TIM_OnePulse_MspDeInit
   2362          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2363          
   2364            /* Change TIM state */
   2365            htim->State = HAL_TIM_STATE_RESET;
   \       0x18   0x....             B.N      ?Subroutine10
   2366          
   2367            /* Release Lock */
   2368            __HAL_UNLOCK(htim);
   2369          
   2370            return HAL_OK;
   2371          }
   2372          
   2373          /**
   2374            * @brief  Initializes the TIM One Pulse MSP.
   2375            * @param  htim TIM One Pulse handle
   2376            * @retval None
   2377            */

   \                                 In section .text, align 2
   2378          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2379          {
   2380            /* Prevent unused argument(s) compilation warning */
   2381            UNUSED(htim);
   2382          
   2383            /* NOTE : This function should not be modified, when the callback is needed,
   2384                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2385             */
   2386          }
   \                     HAL_TIM_OnePulse_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2387          
   2388          /**
   2389            * @brief  DeInitializes TIM One Pulse MSP.
   2390            * @param  htim TIM One Pulse handle
   2391            * @retval None
   2392            */

   \                                 In section .text, align 2
   2393          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2394          {
   2395            /* Prevent unused argument(s) compilation warning */
   2396            UNUSED(htim);
   2397          
   2398            /* NOTE : This function should not be modified, when the callback is needed,
   2399                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2400             */
   2401          }
   \                     HAL_TIM_OnePulse_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2402          
   2403          /**
   2404            * @brief  Starts the TIM One Pulse signal generation.
   2405            * @param  htim TIM One Pulse handle
   2406            * @param  OutputChannel TIM Channels to be enabled
   2407            *          This parameter can be one of the following values:
   2408            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2409            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2410            * @retval HAL status
   2411            */

   \                                 In section .text, align 2, keep-with-next
   2412          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2413          {
   \                     HAL_TIM_OnePulse_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2414            /* Prevent unused argument(s) compilation warning */
   2415            UNUSED(OutputChannel);
   2416          
   2417            /* Enable the Capture compare and the Input Capture channels
   2418              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2419              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2420              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2421              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2422          
   2423              No need to enable the counter, it's enabled automatically by hardware
   2424              (the counter starts in response to a stimulus and generate a pulse */
   2425          
   2426            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x....'....        BL       ??Subroutine18_0
   2427            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??CrossCallReturnLabel_23: (+1)
   \        0xC   0x....'....        BL       ?Subroutine49
   2428          
   2429            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_132: (+1)
   \       0x10   0x....'....        BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_97: (+1)
   \       0x14   0xBF1C             ITT      NE
   \       0x16   0x....             LDRNE.N  R2,??DataTable22_3  ;; 0x40010400
   \       0x18   0x4290             CMPNE    R0,R2
   \       0x1A   0x....             B.N      ?Subroutine8
   2430            {
   2431              /* Enable the main output */
   2432              __HAL_TIM_MOE_ENABLE(htim);
   2433            }
   2434          
   2435            /* Return function status */
   2436            return HAL_OK;
   2437          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0xD103             BNE.N    ??Subroutine8_0
   \        0x2   0x6C41             LDR      R1,[R0, #+68]
   \        0x4   0xF441 0x4100      ORR      R1,R1,#0x8000
   \        0x8   0x6441             STR      R1,[R0, #+68]
   \                     ??Subroutine8_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine49: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x2104             MOVS     R1,#+4
   \        0x6   0x....'....        B.W      TIM_CCxChannelCmd

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x2201             MOVS     R2,#+1
   \                     ??Subroutine18_0: (+1)
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x....'....        B.W      TIM_CCxChannelCmd
   2438          
   2439          /**
   2440            * @brief  Stops the TIM One Pulse signal generation.
   2441            * @param  htim TIM One Pulse handle
   2442            * @param  OutputChannel TIM Channels to be disable
   2443            *          This parameter can be one of the following values:
   2444            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2445            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2446            * @retval HAL status
   2447            */

   \                                 In section .text, align 2, keep-with-next
   2448          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2449          {
   \                     HAL_TIM_OnePulse_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2450            /* Prevent unused argument(s) compilation warning */
   2451            UNUSED(OutputChannel);
   2452          
   2453            /* Disable the Capture compare and the Input Capture channels
   2454            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2455            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2456            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2457            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2458          
   2459            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x....'....        BL       ??Subroutine18_0
   2460            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??CrossCallReturnLabel_22: (+1)
   \        0xC   0x....'....        BL       ?Subroutine43
   2461          
   2462            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_114: (+1)
   \       0x10   0x....'....        BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_105: (+1)
   \       0x14   0xBF1C             ITT      NE
   \       0x16   0x....             LDRNE.N  R4,??DataTable22_3  ;; 0x40010400
   \       0x18   0x42A0             CMPNE    R0,R4
   \       0x1A   0x....'....        BL       ?Subroutine60
   \                     ??CrossCallReturnLabel_165: (+1)
   \       0x1E   0xD106             BNE.N    ??CrossCallReturnLabel_6
   2463            {
   2464              /* Disable the Main Output */
   2465              __HAL_TIM_MOE_DISABLE(htim);
   \       0x20   0x6A03             LDR      R3,[R0, #+32]
   \       0x22   0x4213             TST      R3,R2
   \       0x24   0xBF04             ITT      EQ
   \       0x26   0x6A03             LDREQ    R3,[R0, #+32]
   \       0x28   0x420B             TSTEQ    R3,R1
   \       0x2A   0x....'....        BL       ?Subroutine15
   2466            }
   2467          
   2468            /* Disable the Peripheral */
   2469            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x2E   0x6A03             LDR      R3,[R0, #+32]
   \       0x30   0x4213             TST      R3,R2
   \       0x32   0xBF04             ITT      EQ
   \       0x34   0x6A02             LDREQ    R2,[R0, #+32]
   \       0x36   0x420A             TSTEQ    R2,R1
   \       0x38   0x....             B.N      ?Subroutine7
   2470          
   2471            /* Return function status */
   2472            return HAL_OK;
   2473          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine43: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2104             MOVS     R1,#+4
   \        0x6   0x....'....        B.W      TIM_CCxChannelCmd
   2474          
   2475          /**
   2476            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2477            * @param  htim TIM One Pulse handle
   2478            * @param  OutputChannel TIM Channels to be enabled
   2479            *          This parameter can be one of the following values:
   2480            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2481            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2482            * @retval HAL status
   2483            */

   \                                 In section .text, align 2, keep-with-next
   2484          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2485          {
   \                     HAL_TIM_OnePulse_Start_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2486            /* Prevent unused argument(s) compilation warning */
   2487            UNUSED(OutputChannel);
   2488          
   2489            /* Enable the Capture compare and the Input Capture channels
   2490              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2491              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2492              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2493              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2494          
   2495              No need to enable the counter, it's enabled automatically by hardware
   2496              (the counter starts in response to a stimulus and generate a pulse */
   2497          
   2498            /* Enable the TIM Capture/Compare 1 interrupt */
   2499            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2500          
   2501            /* Enable the TIM Capture/Compare 2 interrupt */
   2502            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2503          
   2504            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0x....'....        BL       ?Subroutine54
   \                     ??CrossCallReturnLabel_145: (+1)
   \        0xA   0x68C1             LDR      R1,[R0, #+12]
   \        0xC   0xF041 0x0104      ORR      R1,R1,#0x4
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   \       0x12   0x....'....        BL       ??Subroutine18_0
   2505            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x16   0x....'....        BL       ?Subroutine49
   2506          
   2507            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_131: (+1)
   \       0x1A   0x....'....        BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_98: (+1)
   \       0x1E   0xBF1C             ITT      NE
   \       0x20   0x....             LDRNE.N  R2,??DataTable22_3  ;; 0x40010400
   \       0x22   0x4290             CMPNE    R0,R2
   \       0x24                      REQUIRE ?Subroutine8
   \       0x24                      ;; // Fall through to label ?Subroutine8
   2508            {
   2509              /* Enable the main output */
   2510              __HAL_TIM_MOE_ENABLE(htim);
   2511            }
   2512          
   2513            /* Return function status */
   2514            return HAL_OK;
   2515          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine54: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF041 0x0102      ORR      R1,R1,#0x2
   \        0x8   0x60C1             STR      R1,[R0, #+12]
   \        0xA   0x4770             BX       LR
   2516          
   2517          /**
   2518            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2519            * @param  htim TIM One Pulse handle
   2520            * @param  OutputChannel TIM Channels to be enabled
   2521            *          This parameter can be one of the following values:
   2522            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2523            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2524            * @retval HAL status
   2525            */

   \                                 In section .text, align 2, keep-with-next
   2526          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2527          {
   \                     HAL_TIM_OnePulse_Stop_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2528            /* Prevent unused argument(s) compilation warning */
   2529            UNUSED(OutputChannel);
   2530          
   2531            /* Disable the TIM Capture/Compare 1 interrupt */
   2532            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2533          
   2534            /* Disable the TIM Capture/Compare 2 interrupt */
   2535            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2536          
   2537            /* Disable the Capture compare and the Input Capture channels
   2538            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2539            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2540            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2541            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2542            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x....'....        BL       ?Subroutine55
   \                     ??CrossCallReturnLabel_147: (+1)
   \        0xA   0x68C1             LDR      R1,[R0, #+12]
   \        0xC   0xF021 0x0104      BIC      R1,R1,#0x4
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   \       0x12   0x....'....        BL       ??Subroutine18_0
   2543            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x16   0x....'....        BL       ?Subroutine43
   2544          
   2545            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \                     ??CrossCallReturnLabel_113: (+1)
   \       0x1A   0x....'....        BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_106: (+1)
   \       0x1E   0xBF1C             ITT      NE
   \       0x20   0x....             LDRNE.N  R4,??DataTable22_3  ;; 0x40010400
   \       0x22   0x42A0             CMPNE    R0,R4
   \       0x24   0x....'....        BL       ?Subroutine60
   \                     ??CrossCallReturnLabel_166: (+1)
   \       0x28   0xD106             BNE.N    ??CrossCallReturnLabel_7
   2546            {
   2547              /* Disable the Main Output */
   2548              __HAL_TIM_MOE_DISABLE(htim);
   \       0x2A   0x6A03             LDR      R3,[R0, #+32]
   \       0x2C   0x4213             TST      R3,R2
   \       0x2E   0xBF04             ITT      EQ
   \       0x30   0x6A03             LDREQ    R3,[R0, #+32]
   \       0x32   0x420B             TSTEQ    R3,R1
   \       0x34   0x....'....        BL       ?Subroutine15
   2549            }
   2550          
   2551            /* Disable the Peripheral */
   2552            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x38   0x6A03             LDR      R3,[R0, #+32]
   \       0x3A   0x4213             TST      R3,R2
   \       0x3C   0xBF04             ITT      EQ
   \       0x3E   0x6A02             LDREQ    R2,[R0, #+32]
   \       0x40   0x420A             TSTEQ    R2,R1
   \       0x42   0x....'....        B.W      ?Subroutine7
   2553          
   2554            /* Return function status */
   2555            return HAL_OK;
   2556          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine55: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF021 0x0102      BIC      R1,R1,#0x2
   \        0x8   0x60C1             STR      R1,[R0, #+12]
   \        0xA   0x4770             BX       LR
   2557          
   2558          /**
   2559            * @}
   2560            */
   2561          
   2562          /** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions
   2563            *  @brief    TIM Encoder functions
   2564            *
   2565          @verbatim
   2566            ==============================================================================
   2567                                    ##### TIM Encoder functions #####
   2568            ==============================================================================
   2569            [..]
   2570              This section provides functions allowing to:
   2571              (+) Initialize and configure the TIM Encoder.
   2572              (+) De-initialize the TIM Encoder.
   2573              (+) Start the TIM Encoder.
   2574              (+) Stop the TIM Encoder.
   2575              (+) Start the TIM Encoder and enable interrupt.
   2576              (+) Stop the TIM Encoder and disable interrupt.
   2577              (+) Start the TIM Encoder and enable DMA transfer.
   2578              (+) Stop the TIM Encoder and disable DMA transfer.
   2579          
   2580          @endverbatim
   2581            * @{
   2582            */
   2583          /**
   2584            * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.
   2585            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2586            *         requires a timer reset to avoid unexpected direction
   2587            *         due to DIR bit readonly in center aligned mode.
   2588            *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
   2589            * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together
   2590            *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource
   2591            *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa
   2592            * @param  htim TIM Encoder Interface handle
   2593            * @param  sConfig TIM Encoder Interface configuration structure
   2594            * @retval HAL status
   2595            */

   \                                 In section .text, align 2, keep-with-next
   2596          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)
   2597          {
   \                     HAL_TIM_Encoder_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460E             MOV      R6,R1
   2598            uint32_t tmpsmcr;
   2599            uint32_t tmpccmr1;
   2600            uint32_t tmpccer;
   2601          
   2602            /* Check the TIM handle allocation */
   2603            if (htim == NULL)
   \        0x6   0xD101             BNE.N    ??HAL_TIM_Encoder_Init_0
   2604            {
   2605              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xBDF2             POP      {R1,R4-R7,PC}
   2606            }
   2607          
   2608            /* Check the parameters */
   2609            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2610            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2611            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2612            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2613            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2614            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2615            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2616            assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC1Polarity));
   2617            assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC2Polarity));
   2618            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2619            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2620            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2621            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2622          
   2623            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0: (+1)
   \        0xC   0x....'....        BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x10   0xB918             CBNZ.N   R0,??HAL_TIM_Encoder_Init_1
   2624            {
   2625              /* Allocate lock resource and initialize it */
   2626              htim->Lock = HAL_UNLOCKED;
   \       0x12   0x....'....        BL       ?Subroutine21
   2627          
   2628          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2629              /* Reset interrupt callbacks to legacy weak callbacks */
   2630              TIM_ResetCallback(htim);
   2631          
   2632              if (htim->Encoder_MspInitCallback == NULL)
   2633              {
   2634                htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
   2635              }
   2636              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2637              htim->Encoder_MspInitCallback(htim);
   2638          #else
   2639              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2640              HAL_TIM_Encoder_MspInit(htim);
   2641          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2642            }
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0x16   0x....'....        BL       HAL_TIM_Encoder_MspInit
   2643          
   2644            /* Set the TIM state */
   2645            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Init_1: (+1)
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x7068             STRB     R0,[R5, #+1]
   2646          
   2647            /* Reset the SMS and ECE bits */
   2648            htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x....'....        LDR.W    R0,??DataTable25  ;; 0xffffbff8
   \       0x24   0x688A             LDR      R2,[R1, #+8]
   \       0x26   0x4002             ANDS     R2,R0,R2
   \       0x28   0x608A             STR      R2,[R1, #+8]
   2649          
   2650            /* Configure the Time base in the Encoder Mode */
   2651            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x2A   0x1D21             ADDS     R1,R4,#+4
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x....'....        BL       TIM_Base_SetConfig
   2652          
   2653            /* Get the TIMx SMCR register value */
   2654            tmpsmcr = htim->Instance->SMCR;
   \       0x32   0x6822             LDR      R2,[R4, #+0]
   2655          
   2656            /* Get the TIMx CCMR1 register value */
   2657            tmpccmr1 = htim->Instance->CCMR1;
   2658          
   2659            /* Get the TIMx CCER register value */
   2660            tmpccer = htim->Instance->CCER;
   2661          
   2662            /* Set the encoder Mode */
   2663            tmpsmcr |= sConfig->EncoderMode;
   2664          
   2665            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2666            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   2667            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
   2668          
   2669            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2670            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   2671            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   2672            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
   2673            tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
   \       0x34   0x....'....        LDR.W    R1,??DataTable25_1  ;; 0xfffffcfc
   \       0x38   0x6893             LDR      R3,[R2, #+8]
   \       0x3A   0x6990             LDR      R0,[R2, #+24]
   \       0x3C   0x6A17             LDR      R7,[R2, #+32]
   \       0x3E   0x4001             ANDS     R1,R1,R0
   \       0x40   0x68B0             LDR      R0,[R6, #+8]
   \       0x42   0x4308             ORRS     R0,R0,R1
   \       0x44   0x69B1             LDR      R1,[R6, #+24]
   \       0x46   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \       0x4A   0x....'....        LDR.W    R1,??DataTable25_2  ;; 0xffff0303
   \       0x4E   0x4001             ANDS     R1,R1,R0
   \       0x50   0x68F0             LDR      R0,[R6, #+12]
   \       0x52   0x4308             ORRS     R0,R0,R1
   \       0x54   0x69F1             LDR      R1,[R6, #+28]
   \       0x56   0xEA40 0x2101      ORR      R1,R0,R1, LSL #+8
   \       0x5A   0x6930             LDR      R0,[R6, #+16]
   \       0x5C   0xEA41 0x1000      ORR      R0,R1,R0, LSL #+4
   \       0x60   0x6A31             LDR      R1,[R6, #+32]
   \       0x62   0xEA40 0x3C01      ORR      R12,R0,R1, LSL #+12
   2674          
   2675            /* Set the TI1 and the TI2 Polarities */
   2676            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   2677            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   2678            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
   \       0x66   0x6870             LDR      R0,[R6, #+4]
   \       0x68   0x6971             LDR      R1,[R6, #+20]
   \       0x6A   0xF027 0x07AA      BIC      R7,R7,#0xAA
   \       0x6E   0x4307             ORRS     R7,R0,R7
   2679          
   2680            /* Write to TIMx SMCR */
   2681            htim->Instance->SMCR = tmpsmcr;
   \       0x70   0x6830             LDR      R0,[R6, #+0]
   \       0x72   0x4303             ORRS     R3,R0,R3
   \       0x74   0xEA47 0x1701      ORR      R7,R7,R1, LSL #+4
   \       0x78   0x6093             STR      R3,[R2, #+8]
   2682          
   2683            /* Write to TIMx CCMR1 */
   2684            htim->Instance->CCMR1 = tmpccmr1;
   \       0x7A   0x6821             LDR      R1,[R4, #+0]
   \       0x7C   0xF8C1 0xC018      STR      R12,[R1, #+24]
   2685          
   2686            /* Write to TIMx CCER */
   2687            htim->Instance->CCER = tmpccer;
   2688          
   2689            /* Initialize the TIM state*/
   2690            htim->State = HAL_TIM_STATE_READY;
   \       0x80   0x2101             MOVS     R1,#+1
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6207             STR      R7,[R0, #+32]
   \       0x86   0x7069             STRB     R1,[R5, #+1]
   2691          
   2692            return HAL_OK;
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2693          }
   2694          
   2695          
   2696          /**
   2697            * @brief  DeInitializes the TIM Encoder interface
   2698            * @param  htim TIM Encoder Interface handle
   2699            * @retval HAL status
   2700            */

   \                                 In section .text, align 2, keep-with-next
   2701          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2702          {
   \                     HAL_TIM_Encoder_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   2703            /* Check the parameters */
   2704            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2705          
   2706            htim->State = HAL_TIM_STATE_BUSY;
   \        0x2   0x....'....        BL       ?Subroutine24
   2707          
   2708            /* Disable the TIM Peripheral Clock */
   2709            __HAL_TIM_DISABLE(htim);
   \                     ??CrossCallReturnLabel_50: (+1)
   \        0x6   0xBF02             ITTT     EQ
   \        0x8   0x6A09             LDREQ    R1,[R1, #+32]
   \        0xA   0xF240 0x4244      MOVWEQ   R2,#+1092
   \        0xE   0x4211             TSTEQ    R1,R2
   \       0x10   0x....'....        BL       ?Subroutine16
   2710          
   2711          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2712            if (htim->Encoder_MspDeInitCallback == NULL)
   2713            {
   2714              htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
   2715            }
   2716            /* DeInit the low level hardware */
   2717            htim->Encoder_MspDeInitCallback(htim);
   2718          #else
   2719            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2720            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x14   0x....'....        BL       HAL_TIM_Encoder_MspDeInit
   2721          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2722          
   2723            /* Change TIM state */
   2724            htim->State = HAL_TIM_STATE_RESET;
   \       0x18   0x....'....        B.W      ?Subroutine10
   2725          
   2726            /* Release Lock */
   2727            __HAL_UNLOCK(htim);
   2728          
   2729            return HAL_OK;
   2730          }
   2731          
   2732          /**
   2733            * @brief  Initializes the TIM Encoder Interface MSP.
   2734            * @param  htim TIM Encoder Interface handle
   2735            * @retval None
   2736            */

   \                                 In section .text, align 2
   2737          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2738          {
   2739            /* Prevent unused argument(s) compilation warning */
   2740            UNUSED(htim);
   2741          
   2742            /* NOTE : This function should not be modified, when the callback is needed,
   2743                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2744             */
   2745          }
   \                     HAL_TIM_Encoder_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2746          
   2747          /**
   2748            * @brief  DeInitializes TIM Encoder Interface MSP.
   2749            * @param  htim TIM Encoder Interface handle
   2750            * @retval None
   2751            */

   \                                 In section .text, align 2
   2752          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2753          {
   2754            /* Prevent unused argument(s) compilation warning */
   2755            UNUSED(htim);
   2756          
   2757            /* NOTE : This function should not be modified, when the callback is needed,
   2758                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2759             */
   2760          }
   \                     HAL_TIM_Encoder_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2761          
   2762          /**
   2763            * @brief  Starts the TIM Encoder Interface.
   2764            * @param  htim TIM Encoder Interface handle
   2765            * @param  Channel TIM Channels to be enabled
   2766            *          This parameter can be one of the following values:
   2767            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2768            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2769            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2770            * @retval HAL status
   2771            */

   \                                 In section .text, align 2, keep-with-next
   2772          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2773          {
   \                     HAL_TIM_Encoder_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2774            /* Check the parameters */
   2775            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2776          
   2777            /* Enable the encoder interface channels */
   2778            switch (Channel)
   \        0x4   0xB109             CBZ.N    R1,??HAL_TIM_Encoder_Start_0
   \        0x6   0x2904             CMP      R1,#+4
   \        0x8   0xD101             BNE.N    ??HAL_TIM_Encoder_Start_1
   2779            {
   2780              case TIM_CHANNEL_1:
   2781              {
   2782                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2783                break;
   2784              }
   2785          
   2786              case TIM_CHANNEL_2:
   2787              {
   2788                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_0: (+1)
   \        0xA   0x2201             MOVS     R2,#+1
   \        0xC   0xE003             B.N      ??HAL_TIM_Encoder_Start_2
   2789                break;
   2790              }
   2791          
   2792              default :
   2793              {
   2794                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_1: (+1)
   \        0xE   0x....'....        BL       ?Subroutine18
   2795                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x12   0x2201             MOVS     R2,#+1
   \       0x14   0x2104             MOVS     R1,#+4
   \                     ??HAL_TIM_Encoder_Start_2: (+1)
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x....'....        BL       TIM_CCxChannelCmd
   2796                break;
   2797              }
   2798            }
   2799            /* Enable the Peripheral */
   2800            __HAL_TIM_ENABLE(htim);
   \       0x1C   0x....             B.N      ?Subroutine9
   2801          
   2802            /* Return function status */
   2803            return HAL_OK;
   2804          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x....'....        BL       ??Subroutine25_1
   \                     ??CrossCallReturnLabel_56: (+1)
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD10             POP      {R4,PC}          ;; return
   2805          
   2806          /**
   2807            * @brief  Stops the TIM Encoder Interface.
   2808            * @param  htim TIM Encoder Interface handle
   2809            * @param  Channel TIM Channels to be disabled
   2810            *          This parameter can be one of the following values:
   2811            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2812            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2813            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2814            * @retval HAL status
   2815            */

   \                                 In section .text, align 2, keep-with-next
   2816          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2817          {
   \                     HAL_TIM_Encoder_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2818            /* Check the parameters */
   2819            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2820          
   2821            /* Disable the Input Capture channels 1 and 2
   2822              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2823            switch (Channel)
   \        0x4   0xB109             CBZ.N    R1,??HAL_TIM_Encoder_Stop_0
   \        0x6   0x2904             CMP      R1,#+4
   \        0x8   0xD101             BNE.N    ??HAL_TIM_Encoder_Stop_1
   2824            {
   2825              case TIM_CHANNEL_1:
   2826              {
   2827                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2828                break;
   2829              }
   2830          
   2831              case TIM_CHANNEL_2:
   2832              {
   2833                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_0: (+1)
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0xE005             B.N      ??HAL_TIM_Encoder_Stop_2
   2834                break;
   2835              }
   2836          
   2837              default :
   2838              {
   2839                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_1: (+1)
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x....'....        BL       ??Subroutine18_0
   2840                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0x2104             MOVS     R1,#+4
   \                     ??HAL_TIM_Encoder_Stop_2: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x....'....        BL       TIM_CCxChannelCmd
   2841                break;
   2842              }
   2843            }
   2844          
   2845            /* Disable the Peripheral */
   2846            __HAL_TIM_DISABLE(htim);
   \       0x20   0x....'....        BL       ?Subroutine39
   \                     ??CrossCallReturnLabel_89: (+1)
   \       0x24   0xBF02             ITTT     EQ
   \       0x26   0x6A01             LDREQ    R1,[R0, #+32]
   \       0x28   0xF240 0x4244      MOVWEQ   R2,#+1092
   \       0x2C   0x4211             TSTEQ    R1,R2
   \       0x2E   0x....'....        B.W      ?Subroutine7
   2847          
   2848            /* Return function status */
   2849            return HAL_OK;
   2850          }
   2851          
   2852          /**
   2853            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2854            * @param  htim TIM Encoder Interface handle
   2855            * @param  Channel TIM Channels to be enabled
   2856            *          This parameter can be one of the following values:
   2857            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2858            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2859            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2860            * @retval HAL status
   2861            */

   \                                 In section .text, align 2, keep-with-next
   2862          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2863          {
   \                     HAL_TIM_Encoder_Start_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2864            /* Check the parameters */
   2865            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2866          
   2867            /* Enable the encoder interface channels */
   2868            /* Enable the capture compare Interrupts 1 and/or 2 */
   2869            switch (Channel)
   \        0x4   0xB111             CBZ.N    R1,??HAL_TIM_Encoder_Start_IT_0
   \        0x6   0x2904             CMP      R1,#+4
   \        0x8   0xD009             BEQ.N    ??HAL_TIM_Encoder_Start_IT_1
   \        0xA   0xE00E             B.N      ??HAL_TIM_Encoder_Start_IT_2
   2870            {
   2871              case TIM_CHANNEL_1:
   2872              {
   2873                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0: (+1)
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0x....'....        BL       TIM_CCxChannelCmd
   2874                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x68C1             LDR      R1,[R0, #+12]
   \       0x18   0xF041 0x0102      ORR      R1,R1,#0x2
   \       0x1C   0xE00E             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2875                break;
   2876              }
   2877          
   2878              case TIM_CHANNEL_2:
   2879              {
   2880                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1: (+1)
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x2201             MOVS     R2,#+1
   \       0x22   0x....'....        BL       TIM_CCxChannelCmd
   2881                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0xE005             B.N      ??CrossCallReturnLabel_146
   2882                break;
   2883              }
   2884          
   2885              default :
   2886              {
   2887                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2: (+1)
   \       0x2A   0x....'....        BL       ?Subroutine18
   2888                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x2E   0x....'....        BL       ?Subroutine49
   2889                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??CrossCallReturnLabel_130: (+1)
   \       0x32   0x....'....        BL       ?Subroutine54
   2890                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??CrossCallReturnLabel_146: (+1)
   \       0x36   0x68C1             LDR      R1,[R0, #+12]
   \       0x38   0xF041 0x0104      ORR      R1,R1,#0x4
   \                     ??HAL_TIM_Encoder_Start_IT_3: (+1)
   \       0x3C   0x60C1             STR      R1,[R0, #+12]
   2891                break;
   2892              }
   2893            }
   2894          
   2895            /* Enable the Peripheral */
   2896            __HAL_TIM_ENABLE(htim);
   \       0x3E                      REQUIRE ?Subroutine9
   \       0x3E                      ;; // Fall through to label ?Subroutine9
   2897          
   2898            /* Return function status */
   2899            return HAL_OK;
   2900          }
   2901          
   2902          /**
   2903            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2904            * @param  htim TIM Encoder Interface handle
   2905            * @param  Channel TIM Channels to be disabled
   2906            *          This parameter can be one of the following values:
   2907            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2908            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2909            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2910            * @retval HAL status
   2911            */

   \                                 In section .text, align 2, keep-with-next
   2912          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2913          {
   \                     HAL_TIM_Encoder_Stop_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2914            /* Check the parameters */
   2915            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2916          
   2917            /* Disable the Input Capture channels 1 and 2
   2918              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2919            if (Channel == TIM_CHANNEL_1)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xB931             CBNZ.N   R1,??HAL_TIM_Encoder_Stop_IT_0
   2920            {
   2921              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x8   0x....'....        BL       ?Subroutine59
   2922          
   2923              /* Disable the capture compare Interrupts 1 */
   2924              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??CrossCallReturnLabel_158: (+1)
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x68C1             LDR      R1,[R0, #+12]
   \       0x10   0xF021 0x0102      BIC      R1,R1,#0x2
   \       0x14   0xE00F             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2925            }
   2926            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0: (+1)
   \       0x16   0x2904             CMP      R1,#+4
   \       0x18   0xD102             BNE.N    ??HAL_TIM_Encoder_Stop_IT_2
   2927            {
   2928              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x1A   0x....'....        BL       ?Subroutine59
   2929          
   2930              /* Disable the capture compare Interrupts 2 */
   2931              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??CrossCallReturnLabel_157: (+1)
   \       0x1E   0xE006             B.N      ??CrossCallReturnLabel_148
   2932            }
   2933            else
   2934            {
   2935              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_IT_2: (+1)
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x....'....        BL       ??Subroutine18_0
   2936              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x26   0x....'....        BL       ?Subroutine43
   2937          
   2938              /* Disable the capture compare Interrupts 1 and 2 */
   2939              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??CrossCallReturnLabel_112: (+1)
   \       0x2A   0x....'....        BL       ?Subroutine55
   2940              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??CrossCallReturnLabel_148: (+1)
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x68C1             LDR      R1,[R0, #+12]
   \       0x32   0xF021 0x0104      BIC      R1,R1,#0x4
   \                     ??HAL_TIM_Encoder_Stop_IT_1: (+1)
   \       0x36   0x60C1             STR      R1,[R0, #+12]
   2941            }
   2942          
   2943            /* Disable the Peripheral */
   2944            __HAL_TIM_DISABLE(htim);
   \       0x38   0xF241 0x1211      MOVW     R2,#+4369
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6A01             LDR      R1,[R0, #+32]
   \       0x40   0x4211             TST      R1,R2
   \       0x42   0xBF02             ITTT     EQ
   \       0x44   0x6A00             LDREQ    R0,[R0, #+32]
   \       0x46   0xF240 0x4144      MOVWEQ   R1,#+1092
   \       0x4A   0x4208             TSTEQ    R0,R1
   \       0x4C                      REQUIRE ?Subroutine6
   \       0x4C                      ;; // Fall through to label ?Subroutine6
   2945          
   2946            /* Change the htim state */
   2947            htim->State = HAL_TIM_STATE_READY;
   2948          
   2949            /* Return function status */
   2950            return HAL_OK;
   2951          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine59: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x....'....        B.W      TIM_CCxChannelCmd
   2952          
   2953          /**
   2954            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2955            * @param  htim TIM Encoder Interface handle
   2956            * @param  Channel TIM Channels to be enabled
   2957            *          This parameter can be one of the following values:
   2958            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2959            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2960            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2961            * @param  pData1 The destination Buffer address for IC1.
   2962            * @param  pData2 The destination Buffer address for IC2.
   2963            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2964            * @retval HAL status
   2965            */

   \                                 In section .text, align 2, keep-with-next
   2966          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,
   2967                                                      uint32_t *pData2, uint16_t Length)
   2968          {
   \                     HAL_TIM_Encoder_Start_DMA: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x4698             MOV      R8,R3
   2969            /* Check the parameters */
   2970            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2971          
   2972            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0x8   0xF896 0x003D      LDRB     R0,[R6, #+61]
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD05F             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_0
   \       0x10   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   2973            {
   2974              return HAL_BUSY;
   2975            }
   2976            else if (htim->State == HAL_TIM_STATE_READY)
   \       0x14   0xF896 0x003D      LDRB     R0,[R6, #+61]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD10A             BNE.N    ??HAL_TIM_Encoder_Start_DMA_1
   2977            {
   2978              if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
   \       0x1C   0x2A00             CMP      R2,#+0
   \       0x1E   0xBF18             IT       NE
   \       0x20   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x24   0xD102             BNE.N    ??HAL_TIM_Encoder_Start_DMA_2
   \       0x26   0xEA5F 0x0009      MOVS     R0,R9
   \       0x2A   0xD139             BNE.N    ??HAL_TIM_Encoder_Start_DMA_3
   2979              {
   2980                return HAL_ERROR;
   2981              }
   2982              else
   2983              {
   2984                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_2: (+1)
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0xF886 0x003D      STRB     R0,[R6, #+61]
   2985              }
   2986            }
   2987            else
   2988            {
   2989              /* nothing to do */
   2990            }
   2991          
   2992            switch (Channel)
   \                     ??HAL_TIM_Encoder_Start_DMA_1: (+1)
   \       0x32   0x....'....        ADR.W    R7,TIM_DMAError
   \       0x36   0x....'....        ADR.W    R4,TIM_DMACaptureHalfCplt
   \       0x3A   0x....'....        ADR.W    R5,TIM_DMACaptureCplt
   \       0x3E   0xB121             CBZ.N    R1,??HAL_TIM_Encoder_Start_DMA_4
   \       0x40   0x2904             CMP      R1,#+4
   \       0x42   0xD014             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_5
   \       0x44   0x293C             CMP      R1,#+60
   \       0x46   0xD020             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_6
   \       0x48   0xE041             B.N      ??HAL_TIM_Encoder_Start_DMA_7
   2993            {
   2994              case TIM_CHANNEL_1:
   2995              {
   2996                /* Set the DMA capture callbacks */
   2997                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_4: (+1)
   \       0x4A   0x....'....        BL       ?Subroutine67
   2998                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2999          
   3000                /* Set the DMA error callback */
   3001                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3002          
   3003                /* Enable the DMA stream */
   3004                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_192: (+1)
   \       0x4E   0x6830             LDR      R0,[R6, #+0]
   \       0x50   0xF100 0x0134      ADD      R1,R0,#+52
   \       0x54   0x6A70             LDR      R0,[R6, #+36]
   \       0x56   0x....'....        BL       HAL_DMA_Start_IT
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD120             BNE.N    ??HAL_TIM_Encoder_Start_DMA_3
   3005                {
   3006                  return HAL_ERROR;
   3007                }
   3008                /* Enable the TIM Input Capture DMA request */
   3009                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \       0x5E   0x6830             LDR      R0,[R6, #+0]
   \       0x60   0x68C1             LDR      R1,[R0, #+12]
   \       0x62   0xF441 0x7100      ORR      R1,R1,#0x200
   \       0x66   0x....'....        BL       ?Subroutine25
   3010          
   3011                /* Enable the Peripheral */
   3012                __HAL_TIM_ENABLE(htim);
   3013          
   3014                /* Enable the Capture compare channel */
   3015                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   3016                break;
   3017              }
   \                     ??CrossCallReturnLabel_51: (+1)
   \       0x6A   0x2100             MOVS     R1,#+0
   \       0x6C   0xE009             B.N      ??HAL_TIM_Encoder_Start_DMA_8
   3018          
   3019              case TIM_CHANNEL_2:
   3020              {
   3021                /* Set the DMA capture callbacks */
   3022                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5: (+1)
   \       0x6E   0x....'....        BL       ?Subroutine38
   3023                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3024          
   3025                /* Set the DMA error callback */
   3026                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   3027                /* Enable the DMA stream */
   3028                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_84: (+1)
   \       0x72   0xB9A8             CBNZ.N   R0,??HAL_TIM_Encoder_Start_DMA_3
   3029                {
   3030                  return HAL_ERROR;
   3031                }
   3032                /* Enable the TIM Input Capture  DMA request */
   3033                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \       0x74   0x6830             LDR      R0,[R6, #+0]
   \       0x76   0x68C1             LDR      R1,[R0, #+12]
   \       0x78   0xF441 0x6180      ORR      R1,R1,#0x400
   \       0x7C   0x....'....        BL       ?Subroutine25
   3034          
   3035                /* Enable the Peripheral */
   3036                __HAL_TIM_ENABLE(htim);
   3037          
   3038                /* Enable the Capture compare channel */
   3039                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??CrossCallReturnLabel_52: (+1)
   \       0x80   0x2104             MOVS     R1,#+4
   \                     ??HAL_TIM_Encoder_Start_DMA_8: (+1)
   \       0x82   0x6830             LDR      R0,[R6, #+0]
   \       0x84   0x....'....        BL       TIM_CCxChannelCmd
   3040                break;
   \       0x88   0xE021             B.N      ??HAL_TIM_Encoder_Start_DMA_7
   3041              }
   3042          
   3043              case TIM_CHANNEL_ALL:
   3044              {
   3045                /* Set the DMA capture callbacks */
   3046                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_6: (+1)
   \       0x8A   0x....'....        BL       ?Subroutine67
   3047                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3048          
   3049                /* Set the DMA error callback */
   3050                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3051          
   3052                /* Enable the DMA stream */
   3053                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_193: (+1)
   \       0x8E   0x6831             LDR      R1,[R6, #+0]
   \       0x90   0x6A70             LDR      R0,[R6, #+36]
   \       0x92   0x3134             ADDS     R1,R1,#+52
   \       0x94   0x....'....        BL       HAL_DMA_Start_IT
   \       0x98   0xB910             CBNZ.N   R0,??HAL_TIM_Encoder_Start_DMA_3
   3054                {
   3055                  return HAL_ERROR;
   3056                }
   3057          
   3058                /* Set the DMA capture callbacks */
   3059                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \       0x9A   0x....'....        BL       ?Subroutine38
   3060                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3061          
   3062                /* Set the DMA error callback */
   3063                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3064          
   3065                /* Enable the DMA stream */
   3066                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   \                     ??CrossCallReturnLabel_83: (+1)
   \       0x9E   0xB108             CBZ.N    R0,??HAL_TIM_Encoder_Start_DMA_9
   3067                {
   3068                  return HAL_ERROR;
   \                     ??HAL_TIM_Encoder_Start_DMA_3: (+1)
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0xE015             B.N      ??HAL_TIM_Encoder_Start_DMA_0
   3069                }
   3070                /* Enable the Peripheral */
   3071                __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_DMA_9: (+1)
   \       0xA4   0x....'....        BL       ??Subroutine25_0
   3072          
   3073                /* Enable the Capture compare channel */
   3074                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??CrossCallReturnLabel_55: (+1)
   \       0xA8   0x2201             MOVS     R2,#+1
   \       0xAA   0x6830             LDR      R0,[R6, #+0]
   \       0xAC   0x....'....        BL       ??Subroutine18_0
   3075                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0xB0   0x6830             LDR      R0,[R6, #+0]
   \       0xB2   0x2201             MOVS     R2,#+1
   \       0xB4   0x2104             MOVS     R1,#+4
   \       0xB6   0x....'....        BL       TIM_CCxChannelCmd
   3076          
   3077                /* Enable the TIM Input Capture  DMA request */
   3078                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \       0xBA   0x6830             LDR      R0,[R6, #+0]
   \       0xBC   0x68C1             LDR      R1,[R0, #+12]
   \       0xBE   0xF441 0x7100      ORR      R1,R1,#0x200
   \       0xC2   0x60C1             STR      R1,[R0, #+12]
   3079                /* Enable the TIM Input Capture  DMA request */
   3080                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \       0xC4   0x6830             LDR      R0,[R6, #+0]
   \       0xC6   0x68C1             LDR      R1,[R0, #+12]
   \       0xC8   0xF441 0x6180      ORR      R1,R1,#0x400
   \       0xCC   0x60C1             STR      R1,[R0, #+12]
   3081                break;
   3082              }
   3083          
   3084              default:
   3085                break;
   3086            }
   3087            /* Return function status */
   3088            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_7: (+1)
   \       0xCE   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_0: (+1)
   \       0xD0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   3089          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine67: (+1)
   \        0x0   0x6A70             LDR      R0,[R6, #+36]
   \        0x2   0x63C5             STR      R5,[R0, #+60]
   \        0x4   0x464B             MOV      R3,R9
   \        0x6   0x6A71             LDR      R1,[R6, #+36]
   \        0x8   0x640C             STR      R4,[R1, #+64]
   \        0xA   0x6A70             LDR      R0,[R6, #+36]
   \        0xC   0x64C7             STR      R7,[R0, #+76]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine38: (+1)
   \        0x0   0x6AB0             LDR      R0,[R6, #+40]
   \        0x2   0x63C5             STR      R5,[R0, #+60]
   \        0x4   0x464B             MOV      R3,R9
   \        0x6   0x6AB1             LDR      R1,[R6, #+40]
   \        0x8   0x640C             STR      R4,[R1, #+64]
   \        0xA   0x4642             MOV      R2,R8
   \        0xC   0x6AB0             LDR      R0,[R6, #+40]
   \        0xE   0x64C7             STR      R7,[R0, #+76]
   \       0x10   0x6831             LDR      R1,[R6, #+0]
   \       0x12   0x6AB0             LDR      R0,[R6, #+40]
   \       0x14   0x3138             ADDS     R1,R1,#+56
   \       0x16   0x....'....        B.W      HAL_DMA_Start_IT
   3090          
   3091          /**
   3092            * @brief  Stops the TIM Encoder Interface in DMA mode.
   3093            * @param  htim TIM Encoder Interface handle
   3094            * @param  Channel TIM Channels to be enabled
   3095            *          This parameter can be one of the following values:
   3096            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3097            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3098            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3099            * @retval HAL status
   3100            */

   \                                 In section .text, align 2, keep-with-next
   3101          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   3102          {
   \                     HAL_TIM_Encoder_Stop_DMA: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   3103            /* Check the parameters */
   3104            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   3105          
   3106            /* Disable the Input Capture channels 1 and 2
   3107              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   3108            if (Channel == TIM_CHANNEL_1)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xB921             CBNZ.N   R1,??HAL_TIM_Encoder_Stop_DMA_0
   3109            {
   3110              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x8   0x....'....        BL       ?Subroutine59
   3111          
   3112              /* Disable the capture compare DMA Request 1 */
   3113              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??CrossCallReturnLabel_156: (+1)
   \        0xC   0x....'....        BL       ?Subroutine42
   3114              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   3115            }
   \                     ??CrossCallReturnLabel_110: (+1)
   \       0x10   0xE016             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   3116            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0: (+1)
   \       0x12   0x2904             CMP      R1,#+4
   \       0x14   0xD104             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_2
   3117            {
   3118              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x16   0x....'....        BL       ?Subroutine59
   3119          
   3120              /* Disable the capture compare DMA Request 2 */
   3121              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??CrossCallReturnLabel_155: (+1)
   \       0x1A   0x....'....        BL       ?Subroutine56
   3122              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??CrossCallReturnLabel_149: (+1)
   \       0x1E   0xE00E             B.N      ??HAL_TIM_Encoder_Stop_DMA_3
   3123            }
   3124            else
   3125            {
   3126              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_DMA_2: (+1)
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x....'....        BL       ??Subroutine18_0
   3127              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x26   0x....'....        BL       ?Subroutine43
   3128          
   3129              /* Disable the capture compare DMA Request 1 and 2 */
   3130              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??CrossCallReturnLabel_111: (+1)
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x68C1             LDR      R1,[R0, #+12]
   \       0x2E   0xF421 0x7100      BIC      R1,R1,#0x200
   \       0x32   0x60C1             STR      R1,[R0, #+12]
   3131              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \       0x34   0x....'....        BL       ?Subroutine56
   3132              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??CrossCallReturnLabel_150: (+1)
   \       0x38   0x6A60             LDR      R0,[R4, #+36]
   \       0x3A   0x....'....        BL       HAL_DMA_Abort_IT
   3133              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_Encoder_Stop_DMA_3: (+1)
   \       0x3E   0x6AA0             LDR      R0,[R4, #+40]
   \                     ??HAL_TIM_Encoder_Stop_DMA_1: (+1)
   \       0x40   0x....'....        BL       HAL_DMA_Abort_IT
   3134            }
   3135          
   3136            /* Disable the Peripheral */
   3137            __HAL_TIM_DISABLE(htim);
   \       0x44   0x....'....        BL       ?Subroutine39
   \                     ??CrossCallReturnLabel_90: (+1)
   \       0x48   0xBF02             ITTT     EQ
   \       0x4A   0x6A00             LDREQ    R0,[R0, #+32]
   \       0x4C   0xF240 0x4144      MOVWEQ   R1,#+1092
   \       0x50   0x4208             TSTEQ    R0,R1
   \       0x52   0x....             B.N      ?Subroutine6
   3138          
   3139            /* Change the htim state */
   3140            htim->State = HAL_TIM_STATE_READY;
   3141          
   3142            /* Return function status */
   3143            return HAL_OK;
   3144          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine56: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x68C1             LDR      R1,[R0, #+12]
   \        0x4   0xF421 0x6180      BIC      R1,R1,#0x400
   \        0x8   0x60C1             STR      R1,[R0, #+12]
   \        0xA   0x4770             BX       LR
   3145          
   3146          /**
   3147            * @}
   3148            */
   3149          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management
   3150            *  @brief    TIM IRQ handler management
   3151            *
   3152          @verbatim
   3153            ==============================================================================
   3154                                  ##### IRQ handler management #####
   3155            ==============================================================================
   3156            [..]
   3157              This section provides Timer IRQ handler function.
   3158          
   3159          @endverbatim
   3160            * @{
   3161            */
   3162          /**
   3163            * @brief  This function handles TIM interrupts requests.
   3164            * @param  htim TIM  handle
   3165            * @retval None
   3166            */

   \                                 In section .text, align 2, keep-with-next
   3167          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   3168          {
   \                     HAL_TIM_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   3169            /* Capture compare 1 event */
   3170            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6901             LDR      R1,[R0, #+16]
   \        0x8   0x078A             LSLS     R2,R1,#+30
   \        0xA   0xD515             BPL.N    ??HAL_TIM_IRQHandler_0
   3171            {
   3172              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
   \        0xC   0x68C1             LDR      R1,[R0, #+12]
   \        0xE   0x078A             LSLS     R2,R1,#+30
   \       0x10   0xD512             BPL.N    ??HAL_TIM_IRQHandler_0
   3173              {
   3174                {
   3175                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \       0x12   0xF06F 0x0102      MVN      R1,#+2
   \       0x16   0x6101             STR      R1,[R0, #+16]
   3176                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x18   0x2201             MOVS     R2,#+1
   \       0x1A   0x7722             STRB     R2,[R4, #+28]
   3177          
   3178                  /* Input capture event */
   3179                  if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
   \       0x1C   0x6980             LDR      R0,[R0, #+24]
   \       0x1E   0xF010 0x0F03      TST      R0,#0x3
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_1
   3180                  {
   3181          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3182                    htim->IC_CaptureCallback(htim);
   3183          #else
   3184                    HAL_TIM_IC_CaptureCallback(htim);
   \       0x26   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \       0x2A   0xE003             B.N      ??CrossCallReturnLabel_60
   3185          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3186                  }
   3187                  /* Output compare event */
   3188                  else
   3189                  {
   3190          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3191                    htim->OC_DelayElapsedCallback(htim);
   3192                    htim->PWM_PulseFinishedCallback(htim);
   3193          #else
   3194                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1: (+1)
   \       0x2C   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3195                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0x30   0x....'....        BL       ?Subroutine26
   3196          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3197                  }
   3198                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??CrossCallReturnLabel_60: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x7720             STRB     R0,[R4, #+28]
   3199                }
   3200              }
   3201            }
   3202            /* Capture compare 2 event */
   3203            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0: (+1)
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6901             LDR      R1,[R0, #+16]
   \       0x3C   0x074A             LSLS     R2,R1,#+29
   \       0x3E   0xD515             BPL.N    ??HAL_TIM_IRQHandler_2
   3204            {
   3205              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
   \       0x40   0x68C1             LDR      R1,[R0, #+12]
   \       0x42   0x074A             LSLS     R2,R1,#+29
   \       0x44   0xD512             BPL.N    ??HAL_TIM_IRQHandler_2
   3206              {
   3207                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \       0x46   0xF06F 0x0104      MVN      R1,#+4
   \       0x4A   0x6101             STR      R1,[R0, #+16]
   3208                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x4C   0x2202             MOVS     R2,#+2
   \       0x4E   0x7722             STRB     R2,[R4, #+28]
   3209                /* Input capture event */
   3210                if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
   \       0x50   0x6980             LDR      R0,[R0, #+24]
   \       0x52   0xF410 0x7F40      TST      R0,#0x300
   \       0x56   0x4620             MOV      R0,R4
   \       0x58   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_3
   3211                {
   3212          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3213                  htim->IC_CaptureCallback(htim);
   3214          #else
   3215                  HAL_TIM_IC_CaptureCallback(htim);
   \       0x5A   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \       0x5E   0xE003             B.N      ??CrossCallReturnLabel_59
   3216          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3217                }
   3218                /* Output compare event */
   3219                else
   3220                {
   3221          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3222                  htim->OC_DelayElapsedCallback(htim);
   3223                  htim->PWM_PulseFinishedCallback(htim);
   3224          #else
   3225                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_3: (+1)
   \       0x60   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3226                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0x64   0x....'....        BL       ?Subroutine26
   3227          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3228                }
   3229                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??CrossCallReturnLabel_59: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x7720             STRB     R0,[R4, #+28]
   3230              }
   3231            }
   3232            /* Capture compare 3 event */
   3233            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_2: (+1)
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6901             LDR      R1,[R0, #+16]
   \       0x70   0x070A             LSLS     R2,R1,#+28
   \       0x72   0xD515             BPL.N    ??HAL_TIM_IRQHandler_4
   3234            {
   3235              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
   \       0x74   0x68C1             LDR      R1,[R0, #+12]
   \       0x76   0x070A             LSLS     R2,R1,#+28
   \       0x78   0xD512             BPL.N    ??HAL_TIM_IRQHandler_4
   3236              {
   3237                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \       0x7A   0xF06F 0x0108      MVN      R1,#+8
   \       0x7E   0x6101             STR      R1,[R0, #+16]
   3238                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x80   0x2204             MOVS     R2,#+4
   \       0x82   0x7722             STRB     R2,[R4, #+28]
   3239                /* Input capture event */
   3240                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
   \       0x84   0x69C0             LDR      R0,[R0, #+28]
   \       0x86   0xF010 0x0F03      TST      R0,#0x3
   \       0x8A   0x4620             MOV      R0,R4
   \       0x8C   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_5
   3241                {
   3242          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3243                  htim->IC_CaptureCallback(htim);
   3244          #else
   3245                  HAL_TIM_IC_CaptureCallback(htim);
   \       0x8E   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \       0x92   0xE003             B.N      ??CrossCallReturnLabel_58
   3246          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3247                }
   3248                /* Output compare event */
   3249                else
   3250                {
   3251          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3252                  htim->OC_DelayElapsedCallback(htim);
   3253                  htim->PWM_PulseFinishedCallback(htim);
   3254          #else
   3255                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_5: (+1)
   \       0x94   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3256                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0x98   0x....'....        BL       ?Subroutine26
   3257          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3258                }
   3259                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??CrossCallReturnLabel_58: (+1)
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0x7720             STRB     R0,[R4, #+28]
   3260              }
   3261            }
   3262            /* Capture compare 4 event */
   3263            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_4: (+1)
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x6901             LDR      R1,[R0, #+16]
   \       0xA4   0x06CA             LSLS     R2,R1,#+27
   \       0xA6   0xD515             BPL.N    ??HAL_TIM_IRQHandler_6
   3264            {
   3265              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
   \       0xA8   0x68C1             LDR      R1,[R0, #+12]
   \       0xAA   0x06CA             LSLS     R2,R1,#+27
   \       0xAC   0xD512             BPL.N    ??HAL_TIM_IRQHandler_6
   3266              {
   3267                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \       0xAE   0xF06F 0x0110      MVN      R1,#+16
   \       0xB2   0x6101             STR      R1,[R0, #+16]
   3268                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0xB4   0x2208             MOVS     R2,#+8
   \       0xB6   0x7722             STRB     R2,[R4, #+28]
   3269                /* Input capture event */
   3270                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
   \       0xB8   0x69C0             LDR      R0,[R0, #+28]
   \       0xBA   0xF410 0x7F40      TST      R0,#0x300
   \       0xBE   0x4620             MOV      R0,R4
   \       0xC0   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_7
   3271                {
   3272          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3273                  htim->IC_CaptureCallback(htim);
   3274          #else
   3275                  HAL_TIM_IC_CaptureCallback(htim);
   \       0xC2   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \       0xC6   0xE003             B.N      ??CrossCallReturnLabel_57
   3276          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3277                }
   3278                /* Output compare event */
   3279                else
   3280                {
   3281          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3282                  htim->OC_DelayElapsedCallback(htim);
   3283                  htim->PWM_PulseFinishedCallback(htim);
   3284          #else
   3285                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7: (+1)
   \       0xC8   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3286                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0xCC   0x....'....        BL       ?Subroutine26
   3287          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3288                }
   3289                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??CrossCallReturnLabel_57: (+1)
   \       0xD0   0x2000             MOVS     R0,#+0
   \       0xD2   0x7720             STRB     R0,[R4, #+28]
   3290              }
   3291            }
   3292            /* TIM Update event */
   3293            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_6: (+1)
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x6901             LDR      R1,[R0, #+16]
   \       0xD8   0x07CA             LSLS     R2,R1,#+31
   \       0xDA   0xD508             BPL.N    ??HAL_TIM_IRQHandler_8
   3294            {
   3295              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
   \       0xDC   0x68C1             LDR      R1,[R0, #+12]
   \       0xDE   0x07CA             LSLS     R2,R1,#+31
   \       0xE0   0xD505             BPL.N    ??HAL_TIM_IRQHandler_8
   3296              {
   3297                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \       0xE2   0xF06F 0x0101      MVN      R1,#+1
   \       0xE6   0x6101             STR      R1,[R0, #+16]
   3298          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3299                htim->PeriodElapsedCallback(htim);
   3300          #else
   3301                HAL_TIM_PeriodElapsedCallback(htim);
   \       0xE8   0x4620             MOV      R0,R4
   \       0xEA   0x....'....        BL       HAL_TIM_PeriodElapsedCallback
   3302          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3303              }
   3304            }
   3305            /* TIM Break input event */
   3306            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   \                     ??HAL_TIM_IRQHandler_8: (+1)
   \       0xEE   0x6820             LDR      R0,[R4, #+0]
   \       0xF0   0x6901             LDR      R1,[R0, #+16]
   \       0xF2   0x060A             LSLS     R2,R1,#+24
   \       0xF4   0xD508             BPL.N    ??HAL_TIM_IRQHandler_9
   3307            {
   3308              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
   \       0xF6   0x68C1             LDR      R1,[R0, #+12]
   \       0xF8   0x060A             LSLS     R2,R1,#+24
   \       0xFA   0xD505             BPL.N    ??HAL_TIM_IRQHandler_9
   3309              {
   3310                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \       0xFC   0xF06F 0x0180      MVN      R1,#+128
   \      0x100   0x6101             STR      R1,[R0, #+16]
   3311          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3312                htim->BreakCallback(htim);
   3313          #else
   3314                HAL_TIMEx_BreakCallback(htim);
   \      0x102   0x4620             MOV      R0,R4
   \      0x104   0x....'....        BL       HAL_TIMEx_BreakCallback
   3315          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3316              }
   3317            }
   3318            /* TIM Trigger detection event */
   3319            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_9: (+1)
   \      0x108   0x6820             LDR      R0,[R4, #+0]
   \      0x10A   0x6901             LDR      R1,[R0, #+16]
   \      0x10C   0x064A             LSLS     R2,R1,#+25
   \      0x10E   0xD508             BPL.N    ??HAL_TIM_IRQHandler_10
   3320            {
   3321              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
   \      0x110   0x68C1             LDR      R1,[R0, #+12]
   \      0x112   0x064A             LSLS     R2,R1,#+25
   \      0x114   0xD505             BPL.N    ??HAL_TIM_IRQHandler_10
   3322              {
   3323                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \      0x116   0xF06F 0x0140      MVN      R1,#+64
   \      0x11A   0x6101             STR      R1,[R0, #+16]
   3324          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3325                htim->TriggerCallback(htim);
   3326          #else
   3327                HAL_TIM_TriggerCallback(htim);
   \      0x11C   0x4620             MOV      R0,R4
   \      0x11E   0x....'....        BL       HAL_TIM_TriggerCallback
   3328          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3329              }
   3330            }
   3331            /* TIM commutation event */
   3332            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   \                     ??HAL_TIM_IRQHandler_10: (+1)
   \      0x122   0x6820             LDR      R0,[R4, #+0]
   \      0x124   0x6901             LDR      R1,[R0, #+16]
   \      0x126   0x068A             LSLS     R2,R1,#+26
   \      0x128   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_11
   3333            {
   3334              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
   \      0x12A   0x68C1             LDR      R1,[R0, #+12]
   \      0x12C   0x068A             LSLS     R2,R1,#+26
   \      0x12E   0xD507             BPL.N    ??HAL_TIM_IRQHandler_11
   3335              {
   3336                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   \      0x130   0xF06F 0x0120      MVN      R1,#+32
   \      0x134   0x6101             STR      R1,[R0, #+16]
   3337          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3338                htim->CommutationCallback(htim);
   3339          #else
   3340                HAL_TIMEx_CommutCallback(htim);
   \      0x136   0x4620             MOV      R0,R4
   \      0x138   0xE8BD 0x4010      POP      {R4,LR}
   \      0x13C   0x....'....        B.W      HAL_TIMEx_CommutCallback
   3341          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3342              }
   3343            }
   3344          }
   \                     ??HAL_TIM_IRQHandler_11: (+1)
   \      0x140   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine26: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x....'....        B.W      HAL_TIM_PWM_PulseFinishedCallback
   3345          
   3346          /**
   3347            * @}
   3348            */
   3349          
   3350          /** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
   3351            *  @brief    TIM Peripheral Control functions
   3352            *
   3353          @verbatim
   3354            ==============================================================================
   3355                             ##### Peripheral Control functions #####
   3356            ==============================================================================
   3357           [..]
   3358             This section provides functions allowing to:
   3359                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
   3360                (+) Configure External Clock source.
   3361                (+) Configure Complementary channels, break features and dead time.
   3362                (+) Configure Master and the Slave synchronization.
   3363                (+) Configure the DMA Burst Mode.
   3364          
   3365          @endverbatim
   3366            * @{
   3367            */
   3368          
   3369          /**
   3370            * @brief  Initializes the TIM Output Compare Channels according to the specified
   3371            *         parameters in the TIM_OC_InitTypeDef.
   3372            * @param  htim TIM Output Compare handle
   3373            * @param  sConfig TIM Output Compare configuration structure
   3374            * @param  Channel TIM Channels to configure
   3375            *          This parameter can be one of the following values:
   3376            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3377            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3378            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3379            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3380            * @retval HAL status
   3381            */

   \                                 In section .text, align 2, keep-with-next
   3382          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
   3383                                                     TIM_OC_InitTypeDef *sConfig,
   3384                                                     uint32_t Channel)
   3385          {
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   3386            /* Check the parameters */
   3387            assert_param(IS_TIM_CHANNELS(Channel));
   3388            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   3389            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3390          
   3391            /* Process Locked */
   3392            __HAL_LOCK(htim);
   \        0x2   0xF100 0x043C      ADD      R4,R0,#+60
   \        0x6   0x7823             LDRB     R3,[R4, #+0]
   \        0x8   0x2B01             CMP      R3,#+1
   \        0xA   0xD101             BNE.N    ??HAL_TIM_OC_ConfigChannel_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_TIM_OC_ConfigChannel_0: (+1)
   \       0x10   0x2301             MOVS     R3,#+1
   \       0x12   0x7023             STRB     R3,[R4, #+0]
   3393          
   3394            htim->State = HAL_TIM_STATE_BUSY;
   \       0x14   0x2502             MOVS     R5,#+2
   \       0x16   0x7065             STRB     R5,[R4, #+1]
   3395          
   3396            switch (Channel)
   \       0x18   0xB14A             CBZ.N    R2,??HAL_TIM_OC_ConfigChannel_1
   \       0x1A   0x2A04             CMP      R2,#+4
   \       0x1C   0xD00B             BEQ.N    ??HAL_TIM_OC_ConfigChannel_2
   \       0x1E   0x2A08             CMP      R2,#+8
   \       0x20   0xD00D             BEQ.N    ??HAL_TIM_OC_ConfigChannel_3
   \       0x22   0x2A0C             CMP      R2,#+12
   \       0x24   0xBF04             ITT      EQ
   3397            {
   3398              case TIM_CHANNEL_1:
   3399              {
   3400                /* Check the parameters */
   3401                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3402          
   3403                /* Configure the TIM Channel 1 in Output Compare */
   3404                TIM_OC1_SetConfig(htim->Instance, sConfig);
   3405                break;
   3406              }
   3407          
   3408              case TIM_CHANNEL_2:
   3409              {
   3410                /* Check the parameters */
   3411                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3412          
   3413                /* Configure the TIM Channel 2 in Output Compare */
   3414                TIM_OC2_SetConfig(htim->Instance, sConfig);
   3415                break;
   3416              }
   3417          
   3418              case TIM_CHANNEL_3:
   3419              {
   3420                /* Check the parameters */
   3421                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3422          
   3423                /* Configure the TIM Channel 3 in Output Compare */
   3424                TIM_OC3_SetConfig(htim->Instance, sConfig);
   3425                break;
   3426              }
   3427          
   3428              case TIM_CHANNEL_4:
   3429              {
   3430                /* Check the parameters */
   3431                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3432          
   3433                /* Configure the TIM Channel 4 in Output Compare */
   3434                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \       0x26   0x6800             LDREQ    R0,[R0, #+0]
   \       0x28   0x....'....        BLEQ     TIM_OC4_SetConfig
   \       0x2C   0xE00A             B.N      ??HAL_TIM_OC_ConfigChannel_4
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \       0x2E   0x6800             LDR      R0,[R0, #+0]
   \       0x30   0x....'....        BL       TIM_OC1_SetConfig
   \       0x34   0xE006             B.N      ??HAL_TIM_OC_ConfigChannel_4
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0x....'....        BL       TIM_OC2_SetConfig
   \       0x3C   0xE002             B.N      ??HAL_TIM_OC_ConfigChannel_4
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \       0x3E   0x6800             LDR      R0,[R0, #+0]
   \       0x40   0x....'....        BL       TIM_OC3_SetConfig
   3435                break;
   3436              }
   3437          
   3438              default:
   3439                break;
   3440            }
   3441          
   3442            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \       0x44   0x....'....        B.W      ??Subroutine78_0
   3443          
   3444            __HAL_UNLOCK(htim);
   3445          
   3446            return HAL_OK;
   3447          }

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine78_0: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x7060             STRB     R0,[R4, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x7021             STRB     R1,[R4, #+0]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3448          
   3449          /**
   3450            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3451            *         parameters in the TIM_IC_InitTypeDef.
   3452            * @param  htim TIM IC handle
   3453            * @param  sConfig TIM Input Capture configuration structure
   3454            * @param  Channel TIM Channel to configure
   3455            *          This parameter can be one of the following values:
   3456            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3457            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3458            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3459            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3460            * @retval HAL status
   3461            */

   \                                 In section .text, align 2, keep-with-next
   3462          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel)
   3463          {
   \                     HAL_TIM_IC_ConfigChannel: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine65
   3464            /* Check the parameters */
   3465            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3466            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3467            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3468            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3469            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3470          
   3471            /* Process Locked */
   3472            __HAL_LOCK(htim);
   \                     ??CrossCallReturnLabel_187: (+1)
   \        0x6   0xD101             BNE.N    ??HAL_TIM_IC_ConfigChannel_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_TIM_IC_ConfigChannel_0: (+1)
   \        0xC   0x....'....        BL       ?Subroutine22
   3473          
   3474            htim->State = HAL_TIM_STATE_BUSY;
   3475          
   3476            if (Channel == TIM_CHANNEL_1)
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0x10   0xB982             CBNZ.N   R2,??HAL_TIM_IC_ConfigChannel_1
   3477            {
   3478              /* TI1 Configuration */
   3479              TIM_TI1_SetConfig(htim->Instance,
   3480                                sConfig->ICPolarity,
   3481                                sConfig->ICSelection,
   3482                                sConfig->ICFilter);
   \       0x12   0x68EB             LDR      R3,[R5, #+12]
   \       0x14   0x686A             LDR      R2,[R5, #+4]
   \       0x16   0x6829             LDR      R1,[R5, #+0]
   \       0x18   0x6830             LDR      R0,[R6, #+0]
   \       0x1A   0x....'....        BL       TIM_TI1_SetConfig
   3483          
   3484              /* Reset the IC1PSC Bits */
   3485              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0x6981             LDR      R1,[R0, #+24]
   \       0x22   0xF021 0x010C      BIC      R1,R1,#0xC
   \       0x26   0x6181             STR      R1,[R0, #+24]
   3486          
   3487              /* Set the IC1PSC value */
   3488              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \       0x28   0x6831             LDR      R1,[R6, #+0]
   \       0x2A   0x698A             LDR      R2,[R1, #+24]
   \       0x2C   0x68A8             LDR      R0,[R5, #+8]
   \       0x2E   0x4302             ORRS     R2,R0,R2
   \       0x30   0x618A             STR      R2,[R1, #+24]
   \       0x32   0xE05C             B.N      ??HAL_TIM_IC_ConfigChannel_2
   3489            }
   3490            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_1: (+1)
   \       0x34   0x2A04             CMP      R2,#+4
   \       0x36   0xD110             BNE.N    ??HAL_TIM_IC_ConfigChannel_3
   3491            {
   3492              /* TI2 Configuration */
   3493              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3494          
   3495              TIM_TI2_SetConfig(htim->Instance,
   3496                                sConfig->ICPolarity,
   3497                                sConfig->ICSelection,
   3498                                sConfig->ICFilter);
   \       0x38   0x68EB             LDR      R3,[R5, #+12]
   \       0x3A   0x686A             LDR      R2,[R5, #+4]
   \       0x3C   0x6829             LDR      R1,[R5, #+0]
   \       0x3E   0x6830             LDR      R0,[R6, #+0]
   \       0x40   0x....'....        BL       TIM_TI2_SetConfig
   3499          
   3500              /* Reset the IC2PSC Bits */
   3501              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \       0x44   0x6830             LDR      R0,[R6, #+0]
   \       0x46   0x6981             LDR      R1,[R0, #+24]
   \       0x48   0xF421 0x6140      BIC      R1,R1,#0xC00
   \       0x4C   0x....'....        BL       ?Subroutine69
   3502          
   3503              /* Set the IC2PSC value */
   3504              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
   3505            }
   \                     ??CrossCallReturnLabel_198: (+1)
   \       0x50   0x68AA             LDR      R2,[R5, #+8]
   \       0x52   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \       0x56   0x6181             STR      R1,[R0, #+24]
   \       0x58   0xE049             B.N      ??HAL_TIM_IC_ConfigChannel_2
   3506            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_3: (+1)
   \       0x5A   0x2A08             CMP      R2,#+8
   \       0x5C   0x68E9             LDR      R1,[R5, #+12]
   \       0x5E   0x686A             LDR      R2,[R5, #+4]
   \       0x60   0x682B             LDR      R3,[R5, #+0]
   \       0x62   0xD123             BNE.N    ??HAL_TIM_IC_ConfigChannel_4
   3507            {
   3508              /* TI3 Configuration */
   3509              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3510          
   3511              TIM_TI3_SetConfig(htim->Instance,
   3512                                sConfig->ICPolarity,
   3513                                sConfig->ICSelection,
   3514                                sConfig->ICFilter);
   \       0x64   0x6837             LDR      R7,[R6, #+0]
   \       0x66   0x6A38             LDR      R0,[R7, #+32]
   \       0x68   0xF420 0x7080      BIC      R0,R0,#0x100
   \       0x6C   0x6238             STR      R0,[R7, #+32]
   \       0x6E   0x021B             LSLS     R3,R3,#+8
   \       0x70   0xF107 0x001C      ADD      R0,R7,#+28
   \       0x74   0xF403 0x6320      AND      R3,R3,#0xA00
   \       0x78   0xF8D0 0xC000      LDR      R12,[R0, #+0]
   \       0x7C   0xF8D7 0xE020      LDR      LR,[R7, #+32]
   \       0x80   0xEA4F 0x0C9C      LSR      R12,R12,#+2
   \       0x84   0xEA42 0x028C      ORR      R2,R2,R12, LSL #+2
   \       0x88   0xF361 0x1207      BFI      R2,R1,#+4,#+4
   \       0x8C   0x6002             STR      R2,[R0, #+0]
   \       0x8E   0xF42E 0x6020      BIC      R0,LR,#0xA00
   \       0x92   0x4303             ORRS     R3,R3,R0
   \       0x94   0x623B             STR      R3,[R7, #+32]
   3515          
   3516              /* Reset the IC3PSC Bits */
   3517              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \       0x96   0x6830             LDR      R0,[R6, #+0]
   \       0x98   0x69C1             LDR      R1,[R0, #+28]
   \       0x9A   0xF021 0x010C      BIC      R1,R1,#0xC
   \       0x9E   0x61C1             STR      R1,[R0, #+28]
   3518          
   3519              /* Set the IC3PSC value */
   3520              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \       0xA0   0x6831             LDR      R1,[R6, #+0]
   \       0xA2   0x69CA             LDR      R2,[R1, #+28]
   \       0xA4   0x68A8             LDR      R0,[R5, #+8]
   \       0xA6   0x4302             ORRS     R2,R0,R2
   \       0xA8   0x61CA             STR      R2,[R1, #+28]
   \       0xAA   0xE020             B.N      ??HAL_TIM_IC_ConfigChannel_2
   3521            }
   3522            else
   3523            {
   3524              /* TI4 Configuration */
   3525              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3526          
   3527              TIM_TI4_SetConfig(htim->Instance,
   3528                                sConfig->ICPolarity,
   3529                                sConfig->ICSelection,
   3530                                sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_4: (+1)
   \       0xAC   0x6830             LDR      R0,[R6, #+0]
   \       0xAE   0x301C             ADDS     R0,R0,#+28
   \       0xB0   0x031B             LSLS     R3,R3,#+12
   \       0xB2   0x6847             LDR      R7,[R0, #+4]
   \       0xB4   0xF427 0x5780      BIC      R7,R7,#0x1000
   \       0xB8   0x6047             STR      R7,[R0, #+4]
   \       0xBA   0xF403 0x4320      AND      R3,R3,#0xA000
   \       0xBE   0x6807             LDR      R7,[R0, #+0]
   \       0xC0   0xF8D0 0xC004      LDR      R12,[R0, #+4]
   \       0xC4   0xF427 0x7740      BIC      R7,R7,#0x300
   \       0xC8   0xEA47 0x2702      ORR      R7,R7,R2, LSL #+8
   \       0xCC   0xF361 0x370F      BFI      R7,R1,#+12,#+4
   \       0xD0   0xF42C 0x4120      BIC      R1,R12,#0xA000
   \       0xD4   0x6007             STR      R7,[R0, #+0]
   \       0xD6   0x430B             ORRS     R3,R3,R1
   \       0xD8   0x6043             STR      R3,[R0, #+4]
   3531          
   3532              /* Reset the IC4PSC Bits */
   3533              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \       0xDA   0x6830             LDR      R0,[R6, #+0]
   \       0xDC   0x69C1             LDR      R1,[R0, #+28]
   \       0xDE   0xF421 0x6140      BIC      R1,R1,#0xC00
   \       0xE2   0x....'....        BL       ?Subroutine71
   3534          
   3535              /* Set the IC4PSC value */
   3536              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
   3537            }
   \                     ??CrossCallReturnLabel_205: (+1)
   \       0xE6   0x68AA             LDR      R2,[R5, #+8]
   \       0xE8   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \       0xEC   0x61C1             STR      R1,[R0, #+28]
   3538          
   3539            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_2: (+1)
   \       0xEE   0x....'....        BL       ?Subroutine23
   3540          
   3541            __HAL_UNLOCK(htim);
   3542          
   3543            return HAL_OK;
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0xF2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3544          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine71: (+1)
   \        0x0   0x61C1             STR      R1,[R0, #+28]
   \        0x2   0x6830             LDR      R0,[R6, #+0]
   \        0x4   0x69C1             LDR      R1,[R0, #+28]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine69: (+1)
   \        0x0   0x6181             STR      R1,[R0, #+24]
   \        0x2   0x6830             LDR      R0,[R6, #+0]
   \        0x4   0x6981             LDR      R1,[R0, #+24]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine65: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \        0x2   0xF106 0x043C      ADD      R4,R6,#+60
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x7820             LDRB     R0,[R4, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine23: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x7060             STRB     R0,[R4, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x7021             STRB     R1,[R4, #+0]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine22: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x7020             STRB     R0,[R4, #+0]
   \        0x4   0x2102             MOVS     R1,#+2
   \        0x6   0x7061             STRB     R1,[R4, #+1]
   \        0x8   0x4770             BX       LR
   3545          
   3546          /**
   3547            * @brief  Initializes the TIM PWM  channels according to the specified
   3548            *         parameters in the TIM_OC_InitTypeDef.
   3549            * @param  htim TIM PWM handle
   3550            * @param  sConfig TIM PWM configuration structure
   3551            * @param  Channel TIM Channels to be configured
   3552            *          This parameter can be one of the following values:
   3553            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3554            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3555            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3556            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3557            * @retval HAL status
   3558            */

   \                                 In section .text, align 2, keep-with-next
   3559          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
   3560                                                      TIM_OC_InitTypeDef *sConfig,
   3561                                                      uint32_t Channel)
   3562          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x....'....        BL       ?Subroutine65
   3563            /* Check the parameters */
   3564            assert_param(IS_TIM_CHANNELS(Channel));
   3565            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3566            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3567            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   3568          
   3569            /* Process Locked */
   3570            __HAL_LOCK(htim);
   \                     ??CrossCallReturnLabel_188: (+1)
   \        0x6   0xD101             BNE.N    ??HAL_TIM_PWM_ConfigChannel_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_TIM_PWM_ConfigChannel_0: (+1)
   \        0xC   0x....'....        BL       ?Subroutine22
   3571          
   3572            htim->State = HAL_TIM_STATE_BUSY;
   3573          
   3574            switch (Channel)
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0x10   0xB132             CBZ.N    R2,??HAL_TIM_PWM_ConfigChannel_1
   \       0x12   0x2A04             CMP      R2,#+4
   \       0x14   0xD017             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_2
   \       0x16   0x2A08             CMP      R2,#+8
   \       0x18   0xD028             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_3
   \       0x1A   0x2A0C             CMP      R2,#+12
   \       0x1C   0xD039             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_4
   \       0x1E   0xE04A             B.N      ??HAL_TIM_PWM_ConfigChannel_5
   3575            {
   3576              case TIM_CHANNEL_1:
   3577              {
   3578                /* Check the parameters */
   3579                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3580          
   3581                /* Configure the Channel 1 in PWM mode */
   3582                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \       0x20   0x6830             LDR      R0,[R6, #+0]
   \       0x22   0x4629             MOV      R1,R5
   \       0x24   0x....'....        BL       TIM_OC1_SetConfig
   3583          
   3584                /* Set the Preload enable bit for channel1 */
   3585                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \       0x28   0x6830             LDR      R0,[R6, #+0]
   \       0x2A   0x6981             LDR      R1,[R0, #+24]
   \       0x2C   0xF041 0x0108      ORR      R1,R1,#0x8
   \       0x30   0x....'....        BL       ?Subroutine69
   3586          
   3587                /* Configure the Output Fast mode */
   3588                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \                     ??CrossCallReturnLabel_199: (+1)
   \       0x34   0xF021 0x0104      BIC      R1,R1,#0x4
   \       0x38   0x6181             STR      R1,[R0, #+24]
   3589                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \       0x3A   0x6831             LDR      R1,[R6, #+0]
   \       0x3C   0x698A             LDR      R2,[R1, #+24]
   \       0x3E   0x6928             LDR      R0,[R5, #+16]
   \       0x40   0x4302             ORRS     R2,R0,R2
   \       0x42   0x618A             STR      R2,[R1, #+24]
   3590                break;
   \       0x44   0xE037             B.N      ??HAL_TIM_PWM_ConfigChannel_5
   3591              }
   3592          
   3593              case TIM_CHANNEL_2:
   3594              {
   3595                /* Check the parameters */
   3596                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3597          
   3598                /* Configure the Channel 2 in PWM mode */
   3599                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \       0x46   0x6830             LDR      R0,[R6, #+0]
   \       0x48   0x4629             MOV      R1,R5
   \       0x4A   0x....'....        BL       TIM_OC2_SetConfig
   3600          
   3601                /* Set the Preload enable bit for channel2 */
   3602                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   \       0x4E   0x6830             LDR      R0,[R6, #+0]
   \       0x50   0x6981             LDR      R1,[R0, #+24]
   \       0x52   0xF441 0x6100      ORR      R1,R1,#0x800
   \       0x56   0x....'....        BL       ?Subroutine69
   3603          
   3604                /* Configure the Output Fast mode */
   3605                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   \                     ??CrossCallReturnLabel_200: (+1)
   \       0x5A   0xF421 0x6180      BIC      R1,R1,#0x400
   \       0x5E   0x....'....        BL       ?Subroutine69
   3606                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   \                     ??CrossCallReturnLabel_201: (+1)
   \       0x62   0x692A             LDR      R2,[R5, #+16]
   \       0x64   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \       0x68   0x6181             STR      R1,[R0, #+24]
   3607                break;
   \       0x6A   0xE024             B.N      ??HAL_TIM_PWM_ConfigChannel_5
   3608              }
   3609          
   3610              case TIM_CHANNEL_3:
   3611              {
   3612                /* Check the parameters */
   3613                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3614          
   3615                /* Configure the Channel 3 in PWM mode */
   3616                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \       0x6C   0x6830             LDR      R0,[R6, #+0]
   \       0x6E   0x4629             MOV      R1,R5
   \       0x70   0x....'....        BL       TIM_OC3_SetConfig
   3617          
   3618                /* Set the Preload enable bit for channel3 */
   3619                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \       0x74   0x6830             LDR      R0,[R6, #+0]
   \       0x76   0x69C1             LDR      R1,[R0, #+28]
   \       0x78   0xF041 0x0108      ORR      R1,R1,#0x8
   \       0x7C   0x....'....        BL       ?Subroutine71
   3620          
   3621                /* Configure the Output Fast mode */
   3622                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \                     ??CrossCallReturnLabel_206: (+1)
   \       0x80   0xF021 0x0104      BIC      R1,R1,#0x4
   \       0x84   0x61C1             STR      R1,[R0, #+28]
   3623                htim->Instance->CCMR2 |= sConfig->OCFastMode;
   \       0x86   0x6831             LDR      R1,[R6, #+0]
   \       0x88   0x69CA             LDR      R2,[R1, #+28]
   \       0x8A   0x6928             LDR      R0,[R5, #+16]
   \       0x8C   0x4302             ORRS     R2,R0,R2
   \       0x8E   0x61CA             STR      R2,[R1, #+28]
   3624                break;
   \       0x90   0xE011             B.N      ??HAL_TIM_PWM_ConfigChannel_5
   3625              }
   3626          
   3627              case TIM_CHANNEL_4:
   3628              {
   3629                /* Check the parameters */
   3630                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3631          
   3632                /* Configure the Channel 4 in PWM mode */
   3633                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \       0x92   0x6830             LDR      R0,[R6, #+0]
   \       0x94   0x4629             MOV      R1,R5
   \       0x96   0x....'....        BL       TIM_OC4_SetConfig
   3634          
   3635                /* Set the Preload enable bit for channel4 */
   3636                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \       0x9A   0x6830             LDR      R0,[R6, #+0]
   \       0x9C   0x69C1             LDR      R1,[R0, #+28]
   \       0x9E   0xF441 0x6100      ORR      R1,R1,#0x800
   \       0xA2   0x....'....        BL       ?Subroutine71
   3637          
   3638                /* Configure the Output Fast mode */
   3639                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   \                     ??CrossCallReturnLabel_207: (+1)
   \       0xA6   0xF421 0x6180      BIC      R1,R1,#0x400
   \       0xAA   0x....'....        BL       ?Subroutine71
   3640                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
   \                     ??CrossCallReturnLabel_208: (+1)
   \       0xAE   0x692A             LDR      R2,[R5, #+16]
   \       0xB0   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \       0xB4   0x61C1             STR      R1,[R0, #+28]
   3641                break;
   3642              }
   3643          
   3644              default:
   3645                break;
   3646            }
   3647          
   3648            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_5: (+1)
   \       0xB6   0x....'....        BL       ?Subroutine23
   3649          
   3650            __HAL_UNLOCK(htim);
   3651          
   3652            return HAL_OK;
   \                     ??CrossCallReturnLabel_44: (+1)
   \       0xBA   0xBD70             POP      {R4-R6,PC}       ;; return
   3653          }
   3654          
   3655          /**
   3656            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3657            *         parameters in the TIM_OnePulse_InitTypeDef.
   3658            * @param  htim TIM One Pulse handle
   3659            * @param  sConfig TIM One Pulse configuration structure
   3660            * @param  OutputChannel TIM output channel to configure
   3661            *          This parameter can be one of the following values:
   3662            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3663            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3664            * @param  InputChannel TIM input Channel to configure
   3665            *          This parameter can be one of the following values:
   3666            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3667            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3668            * @note  To output a waveform with a minimum delay user can enable the fast
   3669            *        mode by calling the @ref __HAL_TIM_ENABLE_OCxFAST macro. Then CCx
   3670            *        output is forced in response to the edge detection on TIx input,
   3671            *        without taking in account the comparison.
   3672            * @retval HAL status
   3673            */

   \                                 In section .text, align 2, keep-with-next
   3674          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig,
   3675                                                           uint32_t OutputChannel,  uint32_t InputChannel)
   3676          {
   \                     HAL_TIM_OnePulse_ConfigChannel: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x461C             MOV      R4,R3
   3677            TIM_OC_InitTypeDef temp1;
   3678          
   3679            /* Check the parameters */
   3680            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3681            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3682          
   3683            if (OutputChannel != InputChannel)
   \        0x4   0x42A2             CMP      R2,R4
   \        0x6   0xB087             SUB      SP,SP,#+28
   \        0x8   0x4606             MOV      R6,R0
   \        0xA   0x460F             MOV      R7,R1
   \        0xC   0xD054             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_0
   3684            {
   3685              /* Process Locked */
   3686              __HAL_LOCK(htim);
   \        0xE   0xF106 0x053C      ADD      R5,R6,#+60
   \       0x12   0x7828             LDRB     R0,[R5, #+0]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xBF08             IT       EQ
   \       0x18   0x2002             MOVEQ    R0,#+2
   \       0x1A   0xD04E             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_1
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0x7028             STRB     R0,[R5, #+0]
   3687          
   3688              htim->State = HAL_TIM_STATE_BUSY;
   \       0x20   0x2102             MOVS     R1,#+2
   \       0x22   0x7069             STRB     R1,[R5, #+1]
   3689          
   3690              /* Extract the Output compare configuration from sConfig structure */
   3691              temp1.OCMode = sConfig->OCMode;
   \       0x24   0x683B             LDR      R3,[R7, #+0]
   \       0x26   0x9300             STR      R3,[SP, #+0]
   3692              temp1.Pulse = sConfig->Pulse;
   \       0x28   0x6878             LDR      R0,[R7, #+4]
   \       0x2A   0x9001             STR      R0,[SP, #+4]
   3693              temp1.OCPolarity = sConfig->OCPolarity;
   \       0x2C   0x68B8             LDR      R0,[R7, #+8]
   \       0x2E   0x9002             STR      R0,[SP, #+8]
   3694              temp1.OCNPolarity = sConfig->OCNPolarity;
   \       0x30   0x68F8             LDR      R0,[R7, #+12]
   \       0x32   0x9003             STR      R0,[SP, #+12]
   3695              temp1.OCIdleState = sConfig->OCIdleState;
   \       0x34   0x6938             LDR      R0,[R7, #+16]
   \       0x36   0x9005             STR      R0,[SP, #+20]
   3696              temp1.OCNIdleState = sConfig->OCNIdleState;
   \       0x38   0x6978             LDR      R0,[R7, #+20]
   \       0x3A   0x9006             STR      R0,[SP, #+24]
   3697          
   3698              switch (OutputChannel)
   \       0x3C   0xB132             CBZ.N    R2,??HAL_TIM_OnePulse_ConfigChannel_2
   \       0x3E   0x2A04             CMP      R2,#+4
   \       0x40   0xBF02             ITTT     EQ
   3699              {
   3700                case TIM_CHANNEL_1:
   3701                {
   3702                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3703          
   3704                  TIM_OC1_SetConfig(htim->Instance, &temp1);
   3705                  break;
   3706                }
   3707                case TIM_CHANNEL_2:
   3708                {
   3709                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3710          
   3711                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   \       0x42   0x4669             MOVEQ    R1,SP
   \       0x44   0x6830             LDREQ    R0,[R6, #+0]
   \       0x46   0x....'....        BLEQ     TIM_OC2_SetConfig
   \       0x4A   0xE003             B.N      ??HAL_TIM_OnePulse_ConfigChannel_3
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2: (+1)
   \       0x4C   0x6830             LDR      R0,[R6, #+0]
   \       0x4E   0x4669             MOV      R1,SP
   \       0x50   0x....'....        BL       TIM_OC1_SetConfig
   3712                  break;
   3713                }
   3714                default:
   3715                  break;
   3716              }
   3717          
   3718              switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3: (+1)
   \       0x54   0xB114             CBZ.N    R4,??HAL_TIM_OnePulse_ConfigChannel_4
   \       0x56   0x2C04             CMP      R4,#+4
   \       0x58   0xD00F             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_5
   \       0x5A   0xE027             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3719              {
   3720                case TIM_CHANNEL_1:
   3721                {
   3722                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3723          
   3724                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3725                                    sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4: (+1)
   \       0x5C   0x6A3B             LDR      R3,[R7, #+32]
   \       0x5E   0x69FA             LDR      R2,[R7, #+28]
   \       0x60   0x69B9             LDR      R1,[R7, #+24]
   \       0x62   0x6830             LDR      R0,[R6, #+0]
   \       0x64   0x....'....        BL       TIM_TI1_SetConfig
   3726          
   3727                  /* Reset the IC1PSC Bits */
   3728                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \       0x68   0x6830             LDR      R0,[R6, #+0]
   \       0x6A   0x6981             LDR      R1,[R0, #+24]
   \       0x6C   0xF021 0x010C      BIC      R1,R1,#0xC
   \       0x70   0x....'....        BL       ?Subroutine66
   3729          
   3730                  /* Select the Trigger source */
   3731                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3732                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   3733          
   3734                  /* Select the Slave Mode */
   3735                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3736                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3737                  break;
   3738                }
   \                     ??CrossCallReturnLabel_190: (+1)
   \       0x74   0xF041 0x0150      ORR      R1,R1,#0x50
   \       0x78   0xE00D             B.N      ??HAL_TIM_OnePulse_ConfigChannel_7
   3739                case TIM_CHANNEL_2:
   3740                {
   3741                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3742          
   3743                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3744                                    sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5: (+1)
   \       0x7A   0x6A3B             LDR      R3,[R7, #+32]
   \       0x7C   0x69FA             LDR      R2,[R7, #+28]
   \       0x7E   0x69B9             LDR      R1,[R7, #+24]
   \       0x80   0x6830             LDR      R0,[R6, #+0]
   \       0x82   0x....'....        BL       TIM_TI2_SetConfig
   3745          
   3746                  /* Reset the IC2PSC Bits */
   3747                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \       0x86   0x6830             LDR      R0,[R6, #+0]
   \       0x88   0x6981             LDR      R1,[R0, #+24]
   \       0x8A   0xF421 0x6140      BIC      R1,R1,#0xC00
   \       0x8E   0x....'....        BL       ?Subroutine66
   3748          
   3749                  /* Select the Trigger source */
   3750                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3751                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \                     ??CrossCallReturnLabel_191: (+1)
   \       0x92   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7: (+1)
   \       0x96   0x6081             STR      R1,[R0, #+8]
   3752          
   3753                  /* Select the Slave Mode */
   3754                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \       0x98   0x6830             LDR      R0,[R6, #+0]
   \       0x9A   0x6881             LDR      R1,[R0, #+8]
   \       0x9C   0x08C9             LSRS     R1,R1,#+3
   \       0x9E   0x00C9             LSLS     R1,R1,#+3
   \       0xA0   0x6081             STR      R1,[R0, #+8]
   3755                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \       0xA2   0x6830             LDR      R0,[R6, #+0]
   \       0xA4   0x6881             LDR      R1,[R0, #+8]
   \       0xA6   0xF041 0x0106      ORR      R1,R1,#0x6
   \       0xAA   0x6081             STR      R1,[R0, #+8]
   3756                  break;
   3757                }
   3758          
   3759                default:
   3760                  break;
   3761              }
   3762          
   3763              htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6: (+1)
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0x7068             STRB     R0,[R5, #+1]
   3764          
   3765              __HAL_UNLOCK(htim);
   \       0xB0   0x2100             MOVS     R1,#+0
   \       0xB2   0x7029             STRB     R1,[R5, #+0]
   3766          
   3767              return HAL_OK;
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0xE000             B.N      ??HAL_TIM_OnePulse_ConfigChannel_1
   3768            }
   3769            else
   3770            {
   3771              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0: (+1)
   \       0xB8   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1: (+1)
   \       0xBA   0xB007             ADD      SP,SP,#+28
   \       0xBC   0xBDF0             POP      {R4-R7,PC}       ;; return
   3772            }
   3773          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine66: (+1)
   \        0x0   0x6181             STR      R1,[R0, #+24]
   \        0x2   0x6830             LDR      R0,[R6, #+0]
   \        0x4   0x6881             LDR      R1,[R0, #+8]
   \        0x6   0xF021 0x0170      BIC      R1,R1,#0x70
   \        0xA   0x6081             STR      R1,[R0, #+8]
   \        0xC   0x6830             LDR      R0,[R6, #+0]
   \        0xE   0x6881             LDR      R1,[R0, #+8]
   \       0x10   0x4770             BX       LR
   3774          
   3775          /**
   3776            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral
   3777            * @param  htim TIM handle
   3778            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write
   3779            *         This parameter can be one of the following values:
   3780            *            @arg TIM_DMABASE_CR1
   3781            *            @arg TIM_DMABASE_CR2
   3782            *            @arg TIM_DMABASE_SMCR
   3783            *            @arg TIM_DMABASE_DIER
   3784            *            @arg TIM_DMABASE_SR
   3785            *            @arg TIM_DMABASE_EGR
   3786            *            @arg TIM_DMABASE_CCMR1
   3787            *            @arg TIM_DMABASE_CCMR2
   3788            *            @arg TIM_DMABASE_CCER
   3789            *            @arg TIM_DMABASE_CNT
   3790            *            @arg TIM_DMABASE_PSC
   3791            *            @arg TIM_DMABASE_ARR
   3792            *            @arg TIM_DMABASE_RCR
   3793            *            @arg TIM_DMABASE_CCR1
   3794            *            @arg TIM_DMABASE_CCR2
   3795            *            @arg TIM_DMABASE_CCR3
   3796            *            @arg TIM_DMABASE_CCR4
   3797            *            @arg TIM_DMABASE_BDTR
   3798            * @param  BurstRequestSrc TIM DMA Request sources
   3799            *         This parameter can be one of the following values:
   3800            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3801            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3802            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3803            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3804            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3805            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3806            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3807            * @param  BurstBuffer The Buffer address.
   3808            * @param  BurstLength DMA Burst length. This parameter can be one value
   3809            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3810            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   3811            * @retval HAL status
   3812            */

   \                                 In section .text, align 2, keep-with-next
   3813          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3814                                                        uint32_t *BurstBuffer, uint32_t  BurstLength)
   3815          {
   \                     HAL_TIM_DMABurst_WriteStart: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   3816            /* Check the parameters */
   3817            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3818            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3819            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3820            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3821          
   3822            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0x6   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0x4617             MOV      R7,R2
   \        0xE   0x4619             MOV      R1,R3
   \       0x10   0xD03E             BEQ.N    ??CrossCallReturnLabel_153
   \       0x12   0x9C06             LDR      R4,[SP, #+24]
   3823            {
   3824              return HAL_BUSY;
   3825            }
   3826            else if (htim->State == HAL_TIM_STATE_READY)
   \       0x14   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD105             BNE.N    ??HAL_TIM_DMABurst_WriteStart_0
   3827            {
   3828              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   \       0x1C   0xB909             CBNZ.N   R1,??HAL_TIM_DMABurst_WriteStart_1
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD133             BNE.N    ??HAL_TIM_DMABurst_WriteStart_2
   3829              {
   3830                return HAL_ERROR;
   3831              }
   3832              else
   3833              {
   3834                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_1: (+1)
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0xF885 0x003D      STRB     R0,[R5, #+61]
   3835              }
   3836            }
   3837            else
   3838            {
   3839              /* nothing to do */
   3840            }
   3841            switch (BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_WriteStart_0: (+1)
   \       0x28   0x0A23             LSRS     R3,R4,#+8
   \       0x2A   0x1C5B             ADDS     R3,R3,#+1
   \       0x2C   0xF5B7 0x7F80      CMP      R7,#+256
   \       0x30   0x....'....        ADR.W    R2,TIM_DMADelayPulseHalfCplt
   \       0x34   0x....'....        ADR.W    R12,TIM_DMADelayPulseCplt
   \       0x38   0x....'....        ADR.W    R0,TIM_DMAError
   \       0x3C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_3
   \       0x3E   0xF5B7 0x7F00      CMP      R7,#+512
   \       0x42   0xD026             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_4
   \       0x44   0xF5B7 0x6F80      CMP      R7,#+1024
   \       0x48   0xD034             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_5
   \       0x4A   0xF5B7 0x6F00      CMP      R7,#+2048
   \       0x4E   0xD03E             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_6
   \       0x50   0xF5B7 0x5F80      CMP      R7,#+4096
   \       0x54   0xD048             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_7
   \       0x56   0xF5B7 0x5F00      CMP      R7,#+8192
   \       0x5A   0xD052             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_8
   \       0x5C   0xF5B7 0x4F80      CMP      R7,#+16384
   \       0x60   0xD060             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_9
   \       0x62   0xE013             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3842            {
   3843              case TIM_DMA_UPDATE:
   3844              {
   3845                /* Set the DMA Period elapsed callbacks */
   3846                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_3: (+1)
   \       0x64   0xF8D5 0xC020      LDR      R12,[R5, #+32]
   \       0x68   0x....'....        ADR.W    R2,TIM_DMAPeriodElapsedCplt
   \       0x6C   0xF8CC 0x203C      STR      R2,[R12, #+60]
   3847                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x70   0xF8D5 0xC020      LDR      R12,[R5, #+32]
   \       0x74   0x....'....        ADR.W    R2,TIM_DMAPeriodElapsedHalfCplt
   \       0x78   0xF8CC 0x2040      STR      R2,[R12, #+64]
   3848          
   3849                /* Set the DMA error callback */
   3850                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x7C   0x6A2A             LDR      R2,[R5, #+32]
   \       0x7E   0x....'....        BL       ?Subroutine62
   3851          
   3852                /* Enable the DMA stream */
   3853                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3854                {
   3855                  return HAL_ERROR;
   3856                }
   3857                break;
   3858              }
   \                     ??CrossCallReturnLabel_169: (+1)
   \       0x82   0x6A28             LDR      R0,[R5, #+32]
   \       0x84   0x....'....        BL       HAL_DMA_Start_IT
   \       0x88   0x2800             CMP      R0,#+0
   \                     ??HAL_TIM_DMABurst_WriteStart_2: (+1)
   \       0x8A   0xD15F             BNE.N    ??HAL_TIM_DMABurst_WriteStart_11
   3859              case TIM_DMA_CC1:
   3860              {
   3861                /* Set the DMA compare callbacks */
   3862                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3863                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3864          
   3865                /* Set the DMA error callback */
   3866                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3867          
   3868                /* Enable the DMA stream */
   3869                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,
   3870                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3871                {
   3872                  return HAL_ERROR;
   3873                }
   3874                break;
   3875              }
   3876              case TIM_DMA_CC2:
   3877              {
   3878                /* Set the DMA compare callbacks */
   3879                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3880                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3881          
   3882                /* Set the DMA error callback */
   3883                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3884          
   3885                /* Enable the DMA stream */
   3886                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,
   3887                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3888                {
   3889                  return HAL_ERROR;
   3890                }
   3891                break;
   3892              }
   3893              case TIM_DMA_CC3:
   3894              {
   3895                /* Set the DMA compare callbacks */
   3896                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3897                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3898          
   3899                /* Set the DMA error callback */
   3900                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   3901          
   3902                /* Enable the DMA stream */
   3903                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,
   3904                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3905                {
   3906                  return HAL_ERROR;
   3907                }
   3908                break;
   3909              }
   3910              case TIM_DMA_CC4:
   3911              {
   3912                /* Set the DMA compare callbacks */
   3913                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3914                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   3915          
   3916                /* Set the DMA error callback */
   3917                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   3918          
   3919                /* Enable the DMA stream */
   3920                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,
   3921                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3922                {
   3923                  return HAL_ERROR;
   3924                }
   3925                break;
   3926              }
   3927              case TIM_DMA_COM:
   3928              {
   3929                /* Set the DMA commutation callbacks */
   3930                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   3931                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   3932          
   3933                /* Set the DMA error callback */
   3934                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   3935          
   3936                /* Enable the DMA stream */
   3937                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,
   3938                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3939                {
   3940                  return HAL_ERROR;
   3941                }
   3942                break;
   3943              }
   3944              case TIM_DMA_TRIGGER:
   3945              {
   3946                /* Set the DMA trigger callbacks */
   3947                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   3948                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   3949          
   3950                /* Set the DMA error callback */
   3951                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   3952          
   3953                /* Enable the DMA stream */
   3954                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
   3955                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   3956                {
   3957                  return HAL_ERROR;
   3958                }
   3959                break;
   3960              }
   3961              default:
   3962                break;
   3963            }
   3964            /* configure the DMA Burst Mode */
   3965            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   \                     ??HAL_TIM_DMABurst_WriteStart_10: (+1)
   \       0x8C   0x....'....        BL       ?Subroutine58
   3966          
   3967            /* Enable the TIM DMA Request */
   3968            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   3969          
   3970            htim->State = HAL_TIM_STATE_READY;
   3971          
   3972            /* Return function status */
   3973            return HAL_OK;
   \                     ??CrossCallReturnLabel_153: (+1)
   \       0x90   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??HAL_TIM_DMABurst_WriteStart_4: (+1)
   \       0x92   0xF8D5 0xE024      LDR      LR,[R5, #+36]
   \       0x96   0xF8CE 0xC03C      STR      R12,[LR, #+60]
   \       0x9A   0xF8D5 0xC024      LDR      R12,[R5, #+36]
   \       0x9E   0xF8CC 0x2040      STR      R2,[R12, #+64]
   \       0xA2   0x6A6A             LDR      R2,[R5, #+36]
   \       0xA4   0x....'....        BL       ?Subroutine62
   \                     ??CrossCallReturnLabel_170: (+1)
   \       0xA8   0x6A68             LDR      R0,[R5, #+36]
   \                     ??HAL_TIM_DMABurst_WriteStart_12: (+1)
   \       0xAA   0x....'....        BL       HAL_DMA_Start_IT
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD14C             BNE.N    ??HAL_TIM_DMABurst_WriteStart_11
   \       0xB2   0xE7EB             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   \                     ??HAL_TIM_DMABurst_WriteStart_5: (+1)
   \       0xB4   0xF8D5 0xE028      LDR      LR,[R5, #+40]
   \       0xB8   0xF8CE 0xC03C      STR      R12,[LR, #+60]
   \       0xBC   0xF8D5 0xC028      LDR      R12,[R5, #+40]
   \       0xC0   0xF8CC 0x2040      STR      R2,[R12, #+64]
   \       0xC4   0x6AAA             LDR      R2,[R5, #+40]
   \       0xC6   0x....'....        BL       ?Subroutine62
   \                     ??CrossCallReturnLabel_171: (+1)
   \       0xCA   0x6AA8             LDR      R0,[R5, #+40]
   \       0xCC   0xE7ED             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   \                     ??HAL_TIM_DMABurst_WriteStart_6: (+1)
   \       0xCE   0xF8D5 0xE02C      LDR      LR,[R5, #+44]
   \       0xD2   0xF8CE 0xC03C      STR      R12,[LR, #+60]
   \       0xD6   0xF8D5 0xC02C      LDR      R12,[R5, #+44]
   \       0xDA   0xF8CC 0x2040      STR      R2,[R12, #+64]
   \       0xDE   0x6AEA             LDR      R2,[R5, #+44]
   \       0xE0   0x....'....        BL       ?Subroutine62
   \                     ??CrossCallReturnLabel_172: (+1)
   \       0xE4   0x6AE8             LDR      R0,[R5, #+44]
   \       0xE6   0xE7E0             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   \                     ??HAL_TIM_DMABurst_WriteStart_7: (+1)
   \       0xE8   0xF8D5 0xE030      LDR      LR,[R5, #+48]
   \       0xEC   0xF8CE 0xC03C      STR      R12,[LR, #+60]
   \       0xF0   0xF8D5 0xC030      LDR      R12,[R5, #+48]
   \       0xF4   0xF8CC 0x2040      STR      R2,[R12, #+64]
   \       0xF8   0x6B2A             LDR      R2,[R5, #+48]
   \       0xFA   0x....'....        BL       ?Subroutine62
   \                     ??CrossCallReturnLabel_173: (+1)
   \       0xFE   0x6B28             LDR      R0,[R5, #+48]
   \      0x100   0xE7D3             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   \                     ??HAL_TIM_DMABurst_WriteStart_8: (+1)
   \      0x102   0xF8D5 0xC034      LDR      R12,[R5, #+52]
   \      0x106   0x....'....        LDR.W    R2,??DataTable31
   \      0x10A   0xF8CC 0x203C      STR      R2,[R12, #+60]
   \      0x10E   0xF8D5 0xC034      LDR      R12,[R5, #+52]
   \      0x112   0x....'....        LDR.W    R2,??DataTable31_1
   \      0x116   0xF8CC 0x2040      STR      R2,[R12, #+64]
   \      0x11A   0x6B6A             LDR      R2,[R5, #+52]
   \      0x11C   0x....'....        BL       ?Subroutine62
   \                     ??CrossCallReturnLabel_174: (+1)
   \      0x120   0x6B68             LDR      R0,[R5, #+52]
   \      0x122   0xE7C2             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   \                     ??HAL_TIM_DMABurst_WriteStart_9: (+1)
   \      0x124   0xF8D5 0xC038      LDR      R12,[R5, #+56]
   \      0x128   0x....'....        ADR.W    R2,TIM_DMATriggerCplt
   \      0x12C   0xF8CC 0x203C      STR      R2,[R12, #+60]
   \      0x130   0xF8D5 0xC038      LDR      R12,[R5, #+56]
   \      0x134   0x....'....        ADR.W    R2,TIM_DMATriggerHalfCplt
   \      0x138   0xF8CC 0x2040      STR      R2,[R12, #+64]
   \      0x13C   0x6BAA             LDR      R2,[R5, #+56]
   \      0x13E   0x....'....        BL       ?Subroutine62
   \                     ??CrossCallReturnLabel_175: (+1)
   \      0x142   0x6BA8             LDR      R0,[R5, #+56]
   \      0x144   0x....'....        BL       HAL_DMA_Start_IT
   \      0x148   0x2800             CMP      R0,#+0
   \      0x14A   0xD09F             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_10
   \                     ??HAL_TIM_DMABurst_WriteStart_11: (+1)
   \      0x14C   0x2001             MOVS     R0,#+1
   \      0x14E   0xBDF2             POP      {R1,R4-R7,PC}
   3974          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine62: (+1)
   \        0x0   0x64D0             STR      R0,[R2, #+76]
   \        0x2   0x6828             LDR      R0,[R5, #+0]
   \        0x4   0xF100 0x024C      ADD      R2,R0,#+76
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine58: (+1)
   \        0x0   0x6828             LDR      R0,[R5, #+0]
   \        0x2   0x4326             ORRS     R6,R4,R6
   \        0x4   0x6486             STR      R6,[R0, #+72]
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x68C1             LDR      R1,[R0, #+12]
   \        0xA   0x430F             ORRS     R7,R7,R1
   \        0xC   0x60C7             STR      R7,[R0, #+12]
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF885 0x003D      STRB     R0,[R5, #+61]
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x4770             BX       LR
   3975          
   3976          /**
   3977            * @brief  Stops the TIM DMA Burst mode
   3978            * @param  htim TIM handle
   3979            * @param  BurstRequestSrc TIM DMA Request sources to disable
   3980            * @retval HAL status
   3981            */

   \                                 In section .text, align 2, keep-with-next
   3982          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3983          {
   \                     HAL_TIM_DMABurst_WriteStop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....             B.N      ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x4604             MOV      R4,R0
   3984            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2000             MOVS     R0,#+0
   3985            /* Check the parameters */
   3986            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3987          
   3988            /* Abort the DMA transfer (at least disable the DMA stream) */
   3989            switch (BurstRequestSrc)
   \        0x4   0xF5B1 0x7F80      CMP      R1,#+256
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0xD012             BEQ.N    ??Subroutine0_0
   \        0xC   0xF5B1 0x7F00      CMP      R1,#+512
   \       0x10   0xD011             BEQ.N    ??Subroutine0_1
   \       0x12   0xF5B1 0x6F80      CMP      R1,#+1024
   \       0x16   0xD010             BEQ.N    ??Subroutine0_2
   \       0x18   0xF5B1 0x6F00      CMP      R1,#+2048
   \       0x1C   0xD00F             BEQ.N    ??Subroutine0_3
   \       0x1E   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x22   0xD00E             BEQ.N    ??Subroutine0_4
   \       0x24   0xF5B1 0x5F00      CMP      R1,#+8192
   \       0x28   0xD00D             BEQ.N    ??Subroutine0_5
   \       0x2A   0xF5B1 0x4F80      CMP      R1,#+16384
   \       0x2E   0xD00C             BEQ.N    ??Subroutine0_6
   \       0x30   0xE00E             B.N      ??Subroutine0_7
   3990            {
   3991              case TIM_DMA_UPDATE:
   3992              {
   3993                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??Subroutine0_0: (+1)
   \       0x32   0x6A20             LDR      R0,[R4, #+32]
   \       0x34   0xE00A             B.N      ??Subroutine0_8
   3994                break;
   3995              }
   3996              case TIM_DMA_CC1:
   3997              {
   3998                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??Subroutine0_1: (+1)
   \       0x36   0x6A60             LDR      R0,[R4, #+36]
   \       0x38   0xE008             B.N      ??Subroutine0_8
   3999                break;
   4000              }
   4001              case TIM_DMA_CC2:
   4002              {
   4003                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??Subroutine0_2: (+1)
   \       0x3A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x3C   0xE006             B.N      ??Subroutine0_8
   4004                break;
   4005              }
   4006              case TIM_DMA_CC3:
   4007              {
   4008                status =  HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??Subroutine0_3: (+1)
   \       0x3E   0x6AE0             LDR      R0,[R4, #+44]
   \       0x40   0xE004             B.N      ??Subroutine0_8
   4009                break;
   4010              }
   4011              case TIM_DMA_CC4:
   4012              {
   4013                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??Subroutine0_4: (+1)
   \       0x42   0x6B20             LDR      R0,[R4, #+48]
   \       0x44   0xE002             B.N      ??Subroutine0_8
   4014                break;
   4015              }
   4016              case TIM_DMA_COM:
   4017              {
   4018                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??Subroutine0_5: (+1)
   \       0x46   0x6B60             LDR      R0,[R4, #+52]
   \       0x48   0xE000             B.N      ??Subroutine0_8
   4019                break;
   4020              }
   4021              case TIM_DMA_TRIGGER:
   4022              {
   4023                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??Subroutine0_6: (+1)
   \       0x4A   0x6BA0             LDR      R0,[R4, #+56]
   \                     ??Subroutine0_8: (+1)
   \       0x4C   0x....'....        BL       HAL_DMA_Abort_IT
   4024                break;
   4025              }
   4026              default:
   4027                break;
   4028            }
   4029          
   4030            if (HAL_OK == status)
   \                     ??Subroutine0_7: (+1)
   \       0x50   0x0001             MOVS     R1,R0
   \       0x52   0xD104             BNE.N    ??Subroutine0_9
   4031            {
   4032              /* Disable the TIM Update DMA request */
   4033              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \       0x54   0x6821             LDR      R1,[R4, #+0]
   \       0x56   0x68CA             LDR      R2,[R1, #+12]
   \       0x58   0xEA22 0x0505      BIC      R5,R2,R5
   \       0x5C   0x60CD             STR      R5,[R1, #+12]
   4034            }
   4035          
   4036            /* Return function status */
   4037            return status;
   \                     ??Subroutine0_9: (+1)
   \       0x5E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   4038          }
   4039          
   4040          /**
   4041            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
   4042            * @param  htim TIM handle
   4043            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
   4044            *         This parameter can be one of the following values:
   4045            *            @arg TIM_DMABASE_CR1
   4046            *            @arg TIM_DMABASE_CR2
   4047            *            @arg TIM_DMABASE_SMCR
   4048            *            @arg TIM_DMABASE_DIER
   4049            *            @arg TIM_DMABASE_SR
   4050            *            @arg TIM_DMABASE_EGR
   4051            *            @arg TIM_DMABASE_CCMR1
   4052            *            @arg TIM_DMABASE_CCMR2
   4053            *            @arg TIM_DMABASE_CCER
   4054            *            @arg TIM_DMABASE_CNT
   4055            *            @arg TIM_DMABASE_PSC
   4056            *            @arg TIM_DMABASE_ARR
   4057            *            @arg TIM_DMABASE_RCR
   4058            *            @arg TIM_DMABASE_CCR1
   4059            *            @arg TIM_DMABASE_CCR2
   4060            *            @arg TIM_DMABASE_CCR3
   4061            *            @arg TIM_DMABASE_CCR4
   4062            *            @arg TIM_DMABASE_BDTR
   4063            * @param  BurstRequestSrc TIM DMA Request sources
   4064            *         This parameter can be one of the following values:
   4065            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   4066            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   4067            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   4068            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   4069            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   4070            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   4071            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   4072            * @param  BurstBuffer The Buffer address.
   4073            * @param  BurstLength DMA Burst length. This parameter can be one value
   4074            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   4075            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   4076            * @retval HAL status
   4077            */

   \                                 In section .text, align 2, keep-with-next
   4078          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   4079                                                       uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength)
   4080          {
   \                     HAL_TIM_DMABurst_ReadStart: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x4617             MOV      R7,R2
   4081            /* Check the parameters */
   4082            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   4083            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   4084            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4085            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   4086          
   4087            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0x6   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0x460E             MOV      R6,R1
   \        0xE   0x461A             MOV      R2,R3
   \       0x10   0xD03E             BEQ.N    ??CrossCallReturnLabel_154
   \       0x12   0x9C06             LDR      R4,[SP, #+24]
   4088            {
   4089              return HAL_BUSY;
   4090            }
   4091            else if (htim->State == HAL_TIM_STATE_READY)
   \       0x14   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD105             BNE.N    ??HAL_TIM_DMABurst_ReadStart_0
   4092            {
   4093              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   \       0x1C   0xB90A             CBNZ.N   R2,??HAL_TIM_DMABurst_ReadStart_1
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD133             BNE.N    ??HAL_TIM_DMABurst_ReadStart_2
   4094              {
   4095                return HAL_ERROR;
   4096              }
   4097              else
   4098              {
   4099                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_1: (+1)
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0xF885 0x003D      STRB     R0,[R5, #+61]
   4100              }
   4101            }
   4102            else
   4103            {
   4104              /* nothing to do */
   4105            }
   4106            switch (BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_ReadStart_0: (+1)
   \       0x28   0x0A23             LSRS     R3,R4,#+8
   \       0x2A   0x1C5B             ADDS     R3,R3,#+1
   \       0x2C   0xF5B7 0x7F80      CMP      R7,#+256
   \       0x30   0x....'....        ADR.W    R1,TIM_DMACaptureHalfCplt
   \       0x34   0x....'....        ADR.W    R12,TIM_DMACaptureCplt
   \       0x38   0x....'....        ADR.W    R0,TIM_DMAError
   \       0x3C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_3
   \       0x3E   0xF5B7 0x7F00      CMP      R7,#+512
   \       0x42   0xD026             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_4
   \       0x44   0xF5B7 0x6F80      CMP      R7,#+1024
   \       0x48   0xD034             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_5
   \       0x4A   0xF5B7 0x6F00      CMP      R7,#+2048
   \       0x4E   0xD03E             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_6
   \       0x50   0xF5B7 0x5F80      CMP      R7,#+4096
   \       0x54   0xD048             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_7
   \       0x56   0xF5B7 0x5F00      CMP      R7,#+8192
   \       0x5A   0xD052             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_8
   \       0x5C   0xF5B7 0x4F80      CMP      R7,#+16384
   \       0x60   0xD060             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_9
   \       0x62   0xE013             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   4107            {
   4108              case TIM_DMA_UPDATE:
   4109              {
   4110                /* Set the DMA Period elapsed callbacks */
   4111                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_3: (+1)
   \       0x64   0xF8D5 0xC020      LDR      R12,[R5, #+32]
   \       0x68   0x....'....        ADR.W    R1,TIM_DMAPeriodElapsedCplt
   \       0x6C   0xF8CC 0x103C      STR      R1,[R12, #+60]
   4112                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x70   0xF8D5 0xC020      LDR      R12,[R5, #+32]
   \       0x74   0x....'....        ADR.W    R1,TIM_DMAPeriodElapsedHalfCplt
   \       0x78   0xF8CC 0x1040      STR      R1,[R12, #+64]
   4113          
   4114                /* Set the DMA error callback */
   4115                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x7C   0x6A29             LDR      R1,[R5, #+32]
   \       0x7E   0x....'....        BL       ?Subroutine63
   4116          
   4117                /* Enable the DMA stream */
   4118                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4119                {
   4120                  return HAL_ERROR;
   4121                }
   4122                break;
   4123              }
   \                     ??CrossCallReturnLabel_176: (+1)
   \       0x82   0x6A28             LDR      R0,[R5, #+32]
   \       0x84   0x....'....        BL       HAL_DMA_Start_IT
   \       0x88   0x2800             CMP      R0,#+0
   \                     ??HAL_TIM_DMABurst_ReadStart_2: (+1)
   \       0x8A   0xD15F             BNE.N    ??HAL_TIM_DMABurst_ReadStart_11
   4124              case TIM_DMA_CC1:
   4125              {
   4126                /* Set the DMA capture callbacks */
   4127                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   4128                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4129          
   4130                /* Set the DMA error callback */
   4131                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   4132          
   4133                /* Enable the DMA stream */
   4134                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4135                {
   4136                  return HAL_ERROR;
   4137                }
   4138                break;
   4139              }
   4140              case TIM_DMA_CC2:
   4141              {
   4142                /* Set the DMA capture/compare callbacks */
   4143                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   4144                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4145          
   4146                /* Set the DMA error callback */
   4147                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   4148          
   4149                /* Enable the DMA stream */
   4150                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4151                {
   4152                  return HAL_ERROR;
   4153                }
   4154                break;
   4155              }
   4156              case TIM_DMA_CC3:
   4157              {
   4158                /* Set the DMA capture callbacks */
   4159                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   4160                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4161          
   4162                /* Set the DMA error callback */
   4163                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   4164          
   4165                /* Enable the DMA stream */
   4166                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4167                {
   4168                  return HAL_ERROR;
   4169                }
   4170                break;
   4171              }
   4172              case TIM_DMA_CC4:
   4173              {
   4174                /* Set the DMA capture callbacks */
   4175                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   4176                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4177          
   4178                /* Set the DMA error callback */
   4179                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   4180          
   4181                /* Enable the DMA stream */
   4182                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4183                {
   4184                  return HAL_ERROR;
   4185                }
   4186                break;
   4187              }
   4188              case TIM_DMA_COM:
   4189              {
   4190                /* Set the DMA commutation callbacks */
   4191                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   4192                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   4193          
   4194                /* Set the DMA error callback */
   4195                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   4196          
   4197                /* Enable the DMA stream */
   4198                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4199                {
   4200                  return HAL_ERROR;
   4201                }
   4202                break;
   4203              }
   4204              case TIM_DMA_TRIGGER:
   4205              {
   4206                /* Set the DMA trigger callbacks */
   4207                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   4208                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   4209          
   4210                /* Set the DMA error callback */
   4211                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   4212          
   4213                /* Enable the DMA stream */
   4214                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   4215                {
   4216                  return HAL_ERROR;
   4217                }
   4218                break;
   4219              }
   4220              default:
   4221                break;
   4222            }
   4223          
   4224            /* configure the DMA Burst Mode */
   4225            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   \                     ??HAL_TIM_DMABurst_ReadStart_10: (+1)
   \       0x8C   0x....'....        BL       ?Subroutine58
   4226          
   4227            /* Enable the TIM DMA Request */
   4228            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   4229          
   4230            htim->State = HAL_TIM_STATE_READY;
   4231          
   4232            /* Return function status */
   4233            return HAL_OK;
   \                     ??CrossCallReturnLabel_154: (+1)
   \       0x90   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??HAL_TIM_DMABurst_ReadStart_4: (+1)
   \       0x92   0xF8D5 0xE024      LDR      LR,[R5, #+36]
   \       0x96   0xF8CE 0xC03C      STR      R12,[LR, #+60]
   \       0x9A   0xF8D5 0xC024      LDR      R12,[R5, #+36]
   \       0x9E   0xF8CC 0x1040      STR      R1,[R12, #+64]
   \       0xA2   0x6A69             LDR      R1,[R5, #+36]
   \       0xA4   0x....'....        BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_177: (+1)
   \       0xA8   0x6A68             LDR      R0,[R5, #+36]
   \                     ??HAL_TIM_DMABurst_ReadStart_12: (+1)
   \       0xAA   0x....'....        BL       HAL_DMA_Start_IT
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD14C             BNE.N    ??HAL_TIM_DMABurst_ReadStart_11
   \       0xB2   0xE7EB             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   \                     ??HAL_TIM_DMABurst_ReadStart_5: (+1)
   \       0xB4   0xF8D5 0xE028      LDR      LR,[R5, #+40]
   \       0xB8   0xF8CE 0xC03C      STR      R12,[LR, #+60]
   \       0xBC   0xF8D5 0xC028      LDR      R12,[R5, #+40]
   \       0xC0   0xF8CC 0x1040      STR      R1,[R12, #+64]
   \       0xC4   0x6AA9             LDR      R1,[R5, #+40]
   \       0xC6   0x....'....        BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_178: (+1)
   \       0xCA   0x6AA8             LDR      R0,[R5, #+40]
   \       0xCC   0xE7ED             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   \                     ??HAL_TIM_DMABurst_ReadStart_6: (+1)
   \       0xCE   0xF8D5 0xE02C      LDR      LR,[R5, #+44]
   \       0xD2   0xF8CE 0xC03C      STR      R12,[LR, #+60]
   \       0xD6   0xF8D5 0xC02C      LDR      R12,[R5, #+44]
   \       0xDA   0xF8CC 0x1040      STR      R1,[R12, #+64]
   \       0xDE   0x6AE9             LDR      R1,[R5, #+44]
   \       0xE0   0x....'....        BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_179: (+1)
   \       0xE4   0x6AE8             LDR      R0,[R5, #+44]
   \       0xE6   0xE7E0             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   \                     ??HAL_TIM_DMABurst_ReadStart_7: (+1)
   \       0xE8   0xF8D5 0xE030      LDR      LR,[R5, #+48]
   \       0xEC   0xF8CE 0xC03C      STR      R12,[LR, #+60]
   \       0xF0   0xF8D5 0xC030      LDR      R12,[R5, #+48]
   \       0xF4   0xF8CC 0x1040      STR      R1,[R12, #+64]
   \       0xF8   0x6B29             LDR      R1,[R5, #+48]
   \       0xFA   0x....'....        BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_180: (+1)
   \       0xFE   0x6B28             LDR      R0,[R5, #+48]
   \      0x100   0xE7D3             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   \                     ??HAL_TIM_DMABurst_ReadStart_8: (+1)
   \      0x102   0xF8D5 0xC034      LDR      R12,[R5, #+52]
   \      0x106   0x....'....        LDR.W    R1,??DataTable31
   \      0x10A   0xF8CC 0x103C      STR      R1,[R12, #+60]
   \      0x10E   0xF8D5 0xC034      LDR      R12,[R5, #+52]
   \      0x112   0x....'....        LDR.W    R1,??DataTable31_1
   \      0x116   0xF8CC 0x1040      STR      R1,[R12, #+64]
   \      0x11A   0x6B69             LDR      R1,[R5, #+52]
   \      0x11C   0x....'....        BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_181: (+1)
   \      0x120   0x6B68             LDR      R0,[R5, #+52]
   \      0x122   0xE7C2             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   \                     ??HAL_TIM_DMABurst_ReadStart_9: (+1)
   \      0x124   0xF8D5 0xC038      LDR      R12,[R5, #+56]
   \      0x128   0x....'....        ADR.W    R1,TIM_DMATriggerCplt
   \      0x12C   0xF8CC 0x103C      STR      R1,[R12, #+60]
   \      0x130   0xF8D5 0xC038      LDR      R12,[R5, #+56]
   \      0x134   0x....'....        ADR.W    R1,TIM_DMATriggerHalfCplt
   \      0x138   0xF8CC 0x1040      STR      R1,[R12, #+64]
   \      0x13C   0x6BA9             LDR      R1,[R5, #+56]
   \      0x13E   0x....'....        BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_182: (+1)
   \      0x142   0x6BA8             LDR      R0,[R5, #+56]
   \      0x144   0x....'....        BL       HAL_DMA_Start_IT
   \      0x148   0x2800             CMP      R0,#+0
   \      0x14A   0xD09F             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_10
   \                     ??HAL_TIM_DMABurst_ReadStart_11: (+1)
   \      0x14C   0x2001             MOVS     R0,#+1
   \      0x14E   0xBDF2             POP      {R1,R4-R7,PC}
   4234          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine63: (+1)
   \        0x0   0x64C8             STR      R0,[R1, #+76]
   \        0x2   0x6828             LDR      R0,[R5, #+0]
   \        0x4   0xF100 0x014C      ADD      R1,R0,#+76
   \        0x8   0x4770             BX       LR
   4235          
   4236          /**
   4237            * @brief  Stop the DMA burst reading
   4238            * @param  htim TIM handle
   4239            * @param  BurstRequestSrc TIM DMA Request sources to disable.
   4240            * @retval HAL status
   4241            */

   \                                 In section .text, align 2, keep-with-next
   4242          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   4243          {
   \                     HAL_TIM_DMABurst_ReadStop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2                      REQUIRE ?Subroutine0
   \        0x2                      ;; // Fall through to label ?Subroutine0
   4244            HAL_StatusTypeDef status = HAL_OK;
   4245            /* Check the parameters */
   4246            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4247          
   4248            /* Abort the DMA transfer (at least disable the DMA stream) */
   4249            switch (BurstRequestSrc)
   4250            {
   4251              case TIM_DMA_UPDATE:
   4252              {
   4253                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   4254                break;
   4255              }
   4256              case TIM_DMA_CC1:
   4257              {
   4258                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   4259                break;
   4260              }
   4261              case TIM_DMA_CC2:
   4262              {
   4263                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   4264                break;
   4265              }
   4266              case TIM_DMA_CC3:
   4267              {
   4268                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   4269                break;
   4270              }
   4271              case TIM_DMA_CC4:
   4272              {
   4273                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   4274                break;
   4275              }
   4276              case TIM_DMA_COM:
   4277              {
   4278                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   4279                break;
   4280              }
   4281              case TIM_DMA_TRIGGER:
   4282              {
   4283                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   4284                break;
   4285              }
   4286              default:
   4287                break;
   4288            }
   4289          
   4290            if (HAL_OK == status)
   4291            {
   4292              /* Disable the TIM Update DMA request */
   4293              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   4294            }
   4295          
   4296            /* Return function status */
   4297            return status;
   4298          }
   4299          
   4300          /**
   4301            * @brief  Generate a software event
   4302            * @param  htim TIM handle
   4303            * @param  EventSource specifies the event source.
   4304            *          This parameter can be one of the following values:
   4305            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   4306            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   4307            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   4308            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   4309            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   4310            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source
   4311            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   4312            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   4313            * @note   Basic timers can only generate an update event.
   4314            * @note   TIM_EVENTSOURCE_COM is relevant only with advanced timer instances.
   4315            * @note   TIM_EVENTSOURCE_BREAK are relevant only for timer instances
   4316            *         supporting a break input.
   4317            * @retval HAL status
   4318            */
   4319          

   \                                 In section .text, align 2, keep-with-next
   4320          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   4321          {
   \                     HAL_TIM_GenerateEvent: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   4322            /* Check the parameters */
   4323            assert_param(IS_TIM_INSTANCE(htim->Instance));
   4324            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   4325          
   4326            /* Process Locked */
   4327            __HAL_LOCK(htim);
   \        0x2   0xF100 0x023C      ADD      R2,R0,#+60
   \        0x6   0x7813             LDRB     R3,[R2, #+0]
   \        0x8   0x2B01             CMP      R3,#+1
   \        0xA   0xD101             BNE.N    ??HAL_TIM_GenerateEvent_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xBD10             POP      {R4,PC}
   \                     ??HAL_TIM_GenerateEvent_0: (+1)
   \       0x10   0x2301             MOVS     R3,#+1
   \       0x12   0x7013             STRB     R3,[R2, #+0]
   4328          
   4329            /* Change the TIM state */
   4330            htim->State = HAL_TIM_STATE_BUSY;
   \       0x14   0x2402             MOVS     R4,#+2
   \       0x16   0x7054             STRB     R4,[R2, #+1]
   4331          
   4332            /* Set the event sources */
   4333            htim->Instance->EGR = EventSource;
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x6141             STR      R1,[R0, #+20]
   4334          
   4335            /* Change the TIM state */
   4336            htim->State = HAL_TIM_STATE_READY;
   \       0x1C   0x7053             STRB     R3,[R2, #+1]
   4337          
   4338            __HAL_UNLOCK(htim);
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x7010             STRB     R0,[R2, #+0]
   4339          
   4340            /* Return function status */
   4341            return HAL_OK;
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
   4342          }
   4343          
   4344          /**
   4345            * @brief  Configures the OCRef clear feature
   4346            * @param  htim TIM handle
   4347            * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that
   4348            *         contains the OCREF clear feature and parameters for the TIM peripheral.
   4349            * @param  Channel specifies the TIM Channel
   4350            *          This parameter can be one of the following values:
   4351            *            @arg TIM_CHANNEL_1: TIM Channel 1
   4352            *            @arg TIM_CHANNEL_2: TIM Channel 2
   4353            *            @arg TIM_CHANNEL_3: TIM Channel 3
   4354            *            @arg TIM_CHANNEL_4: TIM Channel 4
   4355            * @retval HAL status
   4356            */

   \                                 In section .text, align 2, keep-with-next
   4357          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
   4358                                                     TIM_ClearInputConfigTypeDef *sClearInputConfig,
   4359                                                     uint32_t Channel)
   4360          {
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine65
   4361            /* Check the parameters */
   4362            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   4363            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   4364          
   4365            /* Process Locked */
   4366            __HAL_LOCK(htim);
   \                     ??CrossCallReturnLabel_189: (+1)
   \        0x6   0x4617             MOV      R7,R2
   \        0x8   0xD101             BNE.N    ??HAL_TIM_ConfigOCrefClear_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_TIM_ConfigOCrefClear_0: (+1)
   \        0xE   0x....'....        BL       ?Subroutine22
   4367          
   4368            htim->State = HAL_TIM_STATE_BUSY;
   4369          
   4370            switch (sClearInputConfig->ClearInputSource)
   \                     ??CrossCallReturnLabel_42: (+1)
   \       0x12   0x6868             LDR      R0,[R5, #+4]
   \       0x14   0xB110             CBZ.N    R0,??HAL_TIM_ConfigOCrefClear_1
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_2
   \       0x1A   0xE012             B.N      ??HAL_TIM_ConfigOCrefClear_3
   4371            {
   4372              case TIM_CLEARINPUTSOURCE_NONE:
   4373              {
   4374                /* Clear the OCREF clear selection bit and the the ETR Bits */
   4375                CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \       0x1C   0x6830             LDR      R0,[R6, #+0]
   \       0x1E   0x6881             LDR      R1,[R0, #+8]
   \       0x20   0xF421 0x417F      BIC      R1,R1,#0xFF00
   \       0x24   0x6081             STR      R1,[R0, #+8]
   4376                break;
   \       0x26   0xE00C             B.N      ??HAL_TIM_ConfigOCrefClear_3
   4377              }
   4378          
   4379              case TIM_CLEARINPUTSOURCE_ETR:
   4380              {
   4381                /* Check the parameters */
   4382                assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   4383                assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   4384                assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   4385          
   4386                /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */
   4387                if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \       0x28   0x68E8             LDR      R0,[R5, #+12]
   \       0x2A   0xB120             CBZ.N    R0,??HAL_TIM_ConfigOCrefClear_4
   4388                {
   4389                  htim->State = HAL_TIM_STATE_READY;
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x7061             STRB     R1,[R4, #+1]
   4390                  __HAL_UNLOCK(htim);
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x7020             STRB     R0,[R4, #+0]
   4391                  return HAL_ERROR;
   \       0x34   0xE036             B.N      ??HAL_TIM_ConfigOCrefClear_5
   4392                }
   4393          
   4394                TIM_ETR_SetConfig(htim->Instance,
   4395                                  sClearInputConfig->ClearInputPrescaler,
   4396                                  sClearInputConfig->ClearInputPolarity,
   4397                                  sClearInputConfig->ClearInputFilter);
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \       0x36   0x692B             LDR      R3,[R5, #+16]
   \       0x38   0x68AA             LDR      R2,[R5, #+8]
   \       0x3A   0x6830             LDR      R0,[R6, #+0]
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0x....'....        BL       TIM_ETR_SetConfig
   4398                break;
   4399              }
   4400          
   4401              default:
   4402                break;
   4403            }
   4404          
   4405            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \       0x42   0xB137             CBZ.N    R7,??HAL_TIM_ConfigOCrefClear_6
   \       0x44   0x2F04             CMP      R7,#+4
   \       0x46   0xD00D             BEQ.N    ??HAL_TIM_ConfigOCrefClear_7
   \       0x48   0x2F08             CMP      R7,#+8
   \       0x4A   0xD015             BEQ.N    ??HAL_TIM_ConfigOCrefClear_8
   \       0x4C   0x2F0C             CMP      R7,#+12
   \       0x4E   0xD01C             BEQ.N    ??HAL_TIM_ConfigOCrefClear_9
   \       0x50   0xE024             B.N      ??HAL_TIM_ConfigOCrefClear_10
   4406            {
   4407              case TIM_CHANNEL_1:
   4408              {
   4409                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \       0x52   0x....'....        BL       ?Subroutine68
   \                     ??CrossCallReturnLabel_194: (+1)
   \       0x56   0x6988             LDR      R0,[R1, #+24]
   \       0x58   0xBF0C             ITE      EQ
   \       0x5A   0xF020 0x0080      BICEQ    R0,R0,#0x80
   \       0x5E   0xF040 0x0080      ORRNE    R0,R0,#0x80
   4410                {
   4411                  /* Enable the OCREF clear feature for Channel 1 */
   4412                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   4413                }
   4414                else
   4415                {
   4416                  /* Disable the OCREF clear feature for Channel 1 */
   4417                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   \       0x62   0xE007             B.N      ??HAL_TIM_ConfigOCrefClear_11
   4418                }
   4419                break;
   4420              }
   4421              case TIM_CHANNEL_2:
   4422              {
   4423                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \       0x64   0x....'....        BL       ?Subroutine68
   \                     ??CrossCallReturnLabel_195: (+1)
   \       0x68   0x6988             LDR      R0,[R1, #+24]
   \       0x6A   0xBF14             ITE      NE
   \       0x6C   0xF440 0x4000      ORRNE    R0,R0,#0x8000
   \       0x70   0xF420 0x4000      BICEQ    R0,R0,#0x8000
   4424                {
   4425                  /* Enable the OCREF clear feature for Channel 2 */
   4426                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   4427                }
   4428                else
   4429                {
   4430                  /* Disable the OCREF clear feature for Channel 2 */
   4431                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   \                     ??HAL_TIM_ConfigOCrefClear_11: (+1)
   \       0x74   0x6188             STR      R0,[R1, #+24]
   \       0x76   0xE011             B.N      ??HAL_TIM_ConfigOCrefClear_10
   4432                }
   4433                break;
   4434              }
   4435              case TIM_CHANNEL_3:
   4436              {
   4437                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \       0x78   0x....'....        BL       ?Subroutine68
   \                     ??CrossCallReturnLabel_196: (+1)
   \       0x7C   0x69C8             LDR      R0,[R1, #+28]
   \       0x7E   0xBF0C             ITE      EQ
   \       0x80   0xF020 0x0080      BICEQ    R0,R0,#0x80
   \       0x84   0xF040 0x0080      ORRNE    R0,R0,#0x80
   4438                {
   4439                  /* Enable the OCREF clear feature for Channel 3 */
   4440                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   4441                }
   4442                else
   4443                {
   4444                  /* Disable the OCREF clear feature for Channel 3 */
   4445                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   \       0x88   0xE007             B.N      ??HAL_TIM_ConfigOCrefClear_12
   4446                }
   4447                break;
   4448              }
   4449              case TIM_CHANNEL_4:
   4450              {
   4451                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_9: (+1)
   \       0x8A   0x....'....        BL       ?Subroutine68
   \                     ??CrossCallReturnLabel_197: (+1)
   \       0x8E   0x69C8             LDR      R0,[R1, #+28]
   \       0x90   0xBF14             ITE      NE
   \       0x92   0xF440 0x4000      ORRNE    R0,R0,#0x8000
   \       0x96   0xF420 0x4000      BICEQ    R0,R0,#0x8000
   4452                {
   4453                  /* Enable the OCREF clear feature for Channel 4 */
   4454                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   4455                }
   4456                else
   4457                {
   4458                  /* Disable the OCREF clear feature for Channel 4 */
   4459                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   \                     ??HAL_TIM_ConfigOCrefClear_12: (+1)
   \       0x9A   0x61C8             STR      R0,[R1, #+28]
   4460                }
   4461                break;
   4462              }
   4463              default:
   4464                break;
   4465            }
   4466          
   4467            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_10: (+1)
   \       0x9C   0x2001             MOVS     R0,#+1
   \       0x9E   0x7060             STRB     R0,[R4, #+1]
   4468          
   4469            __HAL_UNLOCK(htim);
   \       0xA0   0x2100             MOVS     R1,#+0
   \       0xA2   0x7021             STRB     R1,[R4, #+0]
   4470          
   4471            return HAL_OK;
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \       0xA4   0x4608             MOV      R0,R1
   \       0xA6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4472          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine68: (+1)
   \        0x0   0x6831             LDR      R1,[R6, #+0]
   \        0x2   0x6828             LDR      R0,[R5, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0x4770             BX       LR
   4473          
   4474          /**
   4475            * @brief   Configures the clock source to be used
   4476            * @param  htim TIM handle
   4477            * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
   4478            *         contains the clock source information for the TIM peripheral.
   4479            * @retval HAL status
   4480            */

   \                                 In section .text, align 2, keep-with-next
   4481          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
   4482          {
   \                     HAL_TIM_ConfigClockSource: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....'....        BL       ?Subroutine70
   4483            uint32_t tmpsmcr;
   4484          
   4485            /* Process Locked */
   4486            __HAL_LOCK(htim);
   \                     ??CrossCallReturnLabel_202: (+1)
   \        0x6   0xD101             BNE.N    ??HAL_TIM_ConfigClockSource_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_TIM_ConfigClockSource_0: (+1)
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x7020             STRB     R0,[R4, #+0]
   4487          
   4488            htim->State = HAL_TIM_STATE_BUSY;
   \       0x10   0x2202             MOVS     R2,#+2
   \       0x12   0x7062             STRB     R2,[R4, #+1]
   4489          
   4490            /* Check the parameters */
   4491            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   4492          
   4493            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   4494            tmpsmcr = htim->Instance->SMCR;
   4495            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   4496            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   4497            htim->Instance->SMCR = tmpsmcr;
   \       0x14   0x....'....        LDR.W    R0,??DataTable31_2  ;; 0xffff0088
   \       0x18   0x682A             LDR      R2,[R5, #+0]
   \       0x1A   0x6893             LDR      R3,[R2, #+8]
   \       0x1C   0x4003             ANDS     R3,R0,R3
   \       0x1E   0x6093             STR      R3,[R2, #+8]
   4498          
   4499            switch (sClockSourceConfig->ClockSource)
   \       0x20   0x6808             LDR      R0,[R1, #+0]
   \       0x22   0x0002             MOVS     R2,R0
   \       0x24   0xBF18             IT       NE
   \       0x26   0x2810             CMPNE    R0,#+16
   \       0x28   0xD02D             BEQ.N    ??HAL_TIM_ConfigClockSource_1
   \       0x2A   0x2820             CMP      R0,#+32
   \       0x2C   0xBF18             IT       NE
   \       0x2E   0x2830             CMPNE    R0,#+48
   \       0x30   0xD029             BEQ.N    ??HAL_TIM_ConfigClockSource_1
   \       0x32   0x2840             CMP      R0,#+64
   \       0x34   0xD023             BEQ.N    ??HAL_TIM_ConfigClockSource_2
   \       0x36   0x2850             CMP      R0,#+80
   \       0x38   0xD016             BEQ.N    ??HAL_TIM_ConfigClockSource_3
   \       0x3A   0x2860             CMP      R0,#+96
   \       0x3C   0xD018             BEQ.N    ??HAL_TIM_ConfigClockSource_4
   \       0x3E   0x2870             CMP      R0,#+112
   \       0x40   0xD003             BEQ.N    ??HAL_TIM_ConfigClockSource_5
   \       0x42   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x46   0xD007             BEQ.N    ??HAL_TIM_ConfigClockSource_6
   \       0x48   0xE021             B.N      ??HAL_TIM_ConfigClockSource_7
   4500            {
   4501              case TIM_CLOCKSOURCE_INTERNAL:
   4502              {
   4503                assert_param(IS_TIM_INSTANCE(htim->Instance));
   4504                break;
   4505              }
   4506          
   4507              case TIM_CLOCKSOURCE_ETRMODE1:
   4508              {
   4509                /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
   4510                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   4511          
   4512                /* Check ETR input conditioning related parameters */
   4513                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4514                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4515                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4516          
   4517                /* Configure the ETR Clock source */
   4518                TIM_ETR_SetConfig(htim->Instance,
   4519                                  sClockSourceConfig->ClockPrescaler,
   4520                                  sClockSourceConfig->ClockPolarity,
   4521                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_5: (+1)
   \       0x4A   0x....'....        BL       ?Subroutine72
   4522          
   4523                /* Select the External clock mode1 and the ETRF trigger */
   4524                tmpsmcr = htim->Instance->SMCR;
   \                     ??CrossCallReturnLabel_210: (+1)
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0x6881             LDR      R1,[R0, #+8]
   4525                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   4526                /* Write to TIMx SMCR */
   4527                htim->Instance->SMCR = tmpsmcr;
   \       0x52   0xF041 0x0177      ORR      R1,R1,#0x77
   \       0x56   0xE005             B.N      ??HAL_TIM_ConfigClockSource_8
   4528                break;
   4529              }
   4530          
   4531              case TIM_CLOCKSOURCE_ETRMODE2:
   4532              {
   4533                /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
   4534                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   4535          
   4536                /* Check ETR input conditioning related parameters */
   4537                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4538                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4539                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4540          
   4541                /* Configure the ETR Clock source */
   4542                TIM_ETR_SetConfig(htim->Instance,
   4543                                  sClockSourceConfig->ClockPrescaler,
   4544                                  sClockSourceConfig->ClockPolarity,
   4545                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6: (+1)
   \       0x58   0x....'....        BL       ?Subroutine72
   4546                /* Enable the External clock mode2 */
   4547                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \                     ??CrossCallReturnLabel_209: (+1)
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0x6881             LDR      R1,[R0, #+8]
   \       0x60   0xF441 0x4180      ORR      R1,R1,#0x4000
   \                     ??HAL_TIM_ConfigClockSource_8: (+1)
   \       0x64   0x6081             STR      R1,[R0, #+8]
   4548                break;
   \       0x66   0xE012             B.N      ??HAL_TIM_ConfigClockSource_7
   4549              }
   4550          
   4551              case TIM_CLOCKSOURCE_TI1:
   4552              {
   4553                /* Check whether or not the timer instance supports external clock mode 1 */
   4554                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4555          
   4556                /* Check TI1 input conditioning related parameters */
   4557                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4558                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4559          
   4560                TIM_TI1_ConfigInputStage(htim->Instance,
   4561                                         sClockSourceConfig->ClockPolarity,
   4562                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_3: (+1)
   \       0x68   0x....'....        BL       ?Subroutine73
   4563                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \                     ??CrossCallReturnLabel_212: (+1)
   \       0x6C   0x2150             MOVS     R1,#+80
   \       0x6E   0xE00B             B.N      ??HAL_TIM_ConfigClockSource_9
   4564                break;
   4565              }
   4566          
   4567              case TIM_CLOCKSOURCE_TI2:
   4568              {
   4569                /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
   4570                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4571          
   4572                /* Check TI2 input conditioning related parameters */
   4573                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4574                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4575          
   4576                TIM_TI2_ConfigInputStage(htim->Instance,
   4577                                         sClockSourceConfig->ClockPolarity,
   4578                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_4: (+1)
   \       0x70   0x68CA             LDR      R2,[R1, #+12]
   \       0x72   0x6849             LDR      R1,[R1, #+4]
   \       0x74   0x6828             LDR      R0,[R5, #+0]
   \       0x76   0x....'....        BL       TIM_TI2_ConfigInputStage
   4579                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \       0x7A   0x2160             MOVS     R1,#+96
   \       0x7C   0xE004             B.N      ??HAL_TIM_ConfigClockSource_9
   4580                break;
   4581              }
   4582          
   4583              case TIM_CLOCKSOURCE_TI1ED:
   4584              {
   4585                /* Check whether or not the timer instance supports external clock mode 1 */
   4586                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4587          
   4588                /* Check TI1 input conditioning related parameters */
   4589                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4590                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4591          
   4592                TIM_TI1_ConfigInputStage(htim->Instance,
   4593                                         sClockSourceConfig->ClockPolarity,
   4594                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_2: (+1)
   \       0x7E   0x....'....        BL       ?Subroutine73
   4595                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \                     ??CrossCallReturnLabel_211: (+1)
   \       0x82   0x2140             MOVS     R1,#+64
   \       0x84   0xE000             B.N      ??HAL_TIM_ConfigClockSource_9
   4596                break;
   4597              }
   4598          
   4599              case TIM_CLOCKSOURCE_ITR0:
   4600              case TIM_CLOCKSOURCE_ITR1:
   4601              case TIM_CLOCKSOURCE_ITR2:
   4602              case TIM_CLOCKSOURCE_ITR3:
   4603              {
   4604                /* Check whether or not the timer instance supports internal trigger input */
   4605                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4606          
   4607                TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
   \                     ??HAL_TIM_ConfigClockSource_1: (+1)
   \       0x86   0x4601             MOV      R1,R0
   \                     ??HAL_TIM_ConfigClockSource_9: (+1)
   \       0x88   0x6828             LDR      R0,[R5, #+0]
   \       0x8A   0x....'....        BL       TIM_ITRx_SetConfig
   4608                break;
   4609              }
   4610          
   4611              default:
   4612                break;
   4613            }
   4614            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_7: (+1)
   \       0x8E   0x....             B.N      ??Subroutine78_0
   4615          
   4616            __HAL_UNLOCK(htim);
   4617          
   4618            return HAL_OK;
   4619          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine73: (+1)
   \        0x0   0x68CA             LDR      R2,[R1, #+12]
   \        0x2   0x6849             LDR      R1,[R1, #+4]
   \        0x4   0x6828             LDR      R0,[R5, #+0]
   \        0x6   0x....             B.N      TIM_TI1_ConfigInputStage

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine72: (+1)
   \        0x0   0x68CB             LDR      R3,[R1, #+12]
   \        0x2   0x684A             LDR      R2,[R1, #+4]
   \        0x4   0x6889             LDR      R1,[R1, #+8]
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x....             B.N      TIM_ETR_SetConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine70: (+1)
   \        0x0   0x4605             MOV      R5,R0
   \        0x2   0xF105 0x043C      ADD      R4,R5,#+60
   \        0x6   0x7820             LDRB     R0,[R4, #+0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0x4770             BX       LR
   4620          
   4621          /**
   4622            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4623            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4624            * @param  htim TIM handle.
   4625            * @param  TI1_Selection Indicate whether or not channel 1 is connected to the
   4626            *         output of a XOR gate.
   4627            *          This parameter can be one of the following values:
   4628            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4629            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4630            *            pins are connected to the TI1 input (XOR combination)
   4631            * @retval HAL status
   4632            */

   \                                 In section .text, align 2, keep-with-next
   4633          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4634          {
   4635            uint32_t tmpcr2;
   4636          
   4637            /* Check the parameters */
   4638            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
   4639            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4640          
   4641            /* Get the TIMx CR2 register value */
   4642            tmpcr2 = htim->Instance->CR2;
   \                     HAL_TIM_ConfigTI1Input: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x6842             LDR      R2,[R0, #+4]
   4643          
   4644            /* Reset the TI1 selection */
   4645            tmpcr2 &= ~TIM_CR2_TI1S;
   4646          
   4647            /* Set the TI1 selection */
   4648            tmpcr2 |= TI1_Selection;
   4649          
   4650            /* Write to TIMxCR2 */
   4651            htim->Instance->CR2 = tmpcr2;
   \        0x4   0xF022 0x0280      BIC      R2,R2,#0x80
   \        0x8   0x4311             ORRS     R1,R1,R2
   \        0xA   0x6041             STR      R1,[R0, #+4]
   4652          
   4653            return HAL_OK;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return
   4654          }
   4655          
   4656          /**
   4657            * @brief  Configures the TIM in Slave mode
   4658            * @param  htim TIM handle.
   4659            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4660            *         contains the selected trigger (internal trigger input, filtered
   4661            *         timer input or external trigger input) and the Slave mode
   4662            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4663            * @retval HAL status
   4664            */

   \                                 In section .text, align 2, keep-with-next
   4665          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)
   4666          {
   \                     HAL_TIM_SlaveConfigSynchro: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....'....        BL       ?Subroutine70
   4667            /* Check the parameters */
   4668            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4669            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4670            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4671          
   4672            __HAL_LOCK(htim);
   \                     ??CrossCallReturnLabel_203: (+1)
   \        0x6   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchro_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_TIM_SlaveConfigSynchro_0: (+1)
   \        0xC   0x....'....        BL       ?Subroutine19
   4673          
   4674            htim->State = HAL_TIM_STATE_BUSY;
   4675          
   4676            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x10   0xB100             CBZ.N    R0,??HAL_TIM_SlaveConfigSynchro_1
   4677            {
   4678              htim->State = HAL_TIM_STATE_READY;
   \       0x12   0x....             B.N      ?Subroutine4
   4679              __HAL_UNLOCK(htim);
   4680              return HAL_ERROR;
   4681            }
   4682          
   4683            /* Disable Trigger Interrupt */
   4684            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   \                     ??HAL_TIM_SlaveConfigSynchro_1: (+1)
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x68C1             LDR      R1,[R0, #+12]
   \       0x18   0xF021 0x0140      BIC      R1,R1,#0x40
   \       0x1C   0x....             B.N      ?Subroutine1
   4685          
   4686            /* Disable Trigger DMA request */
   4687            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   4688          
   4689            htim->State = HAL_TIM_STATE_READY;
   4690          
   4691            __HAL_UNLOCK(htim);
   4692          
   4693            return HAL_OK;
   4694          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x7020             STRB     R0,[R4, #+0]
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x7062             STRB     R2,[R4, #+1]
   \        0x8   0x4628             MOV      R0,R5
   \        0xA   0x....             B.N      TIM_SlaveTimer_SetConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x7060             STRB     R0,[R4, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x7021             STRB     R1,[R4, #+0]
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x60C1             STR      R1,[R0, #+12]
   \        0x2   0x6828             LDR      R0,[R5, #+0]
   \        0x4   0x68C1             LDR      R1,[R0, #+12]
   \        0x6   0xF421 0x4180      BIC      R1,R1,#0x4000
   \        0xA   0x60C1             STR      R1,[R0, #+12]
   \        0xC                      REQUIRE ??Subroutine78_0
   \        0xC                      ;; // Fall through to label ??Subroutine78_0
   4695          
   4696          /**
   4697            * @brief  Configures the TIM in Slave mode in interrupt mode
   4698            * @param  htim TIM handle.
   4699            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4700            *         contains the selected trigger (internal trigger input, filtered
   4701            *         timer input or external trigger input) and the Slave mode
   4702            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4703            * @retval HAL status
   4704            */

   \                                 In section .text, align 2, keep-with-next
   4705          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,
   4706                                                          TIM_SlaveConfigTypeDef *sSlaveConfig)
   4707          {
   \                     HAL_TIM_SlaveConfigSynchro_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....'....        BL       ?Subroutine70
   4708            /* Check the parameters */
   4709            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4710            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4711            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4712          
   4713            __HAL_LOCK(htim);
   \                     ??CrossCallReturnLabel_204: (+1)
   \        0x6   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchro_IT_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_TIM_SlaveConfigSynchro_IT_0: (+1)
   \        0xC   0x....'....        BL       ?Subroutine19
   4714          
   4715            htim->State = HAL_TIM_STATE_BUSY;
   4716          
   4717            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x10   0xB100             CBZ.N    R0,??HAL_TIM_SlaveConfigSynchro_IT_1
   4718            {
   4719              htim->State = HAL_TIM_STATE_READY;
   \       0x12   0x....             B.N      ?Subroutine4
   4720              __HAL_UNLOCK(htim);
   4721              return HAL_ERROR;
   4722            }
   4723          
   4724            /* Enable Trigger Interrupt */
   4725            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \                     ??HAL_TIM_SlaveConfigSynchro_IT_1: (+1)
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x68C1             LDR      R1,[R0, #+12]
   \       0x18   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x1C   0x....             B.N      ?Subroutine1
   4726          
   4727            /* Disable Trigger DMA request */
   4728            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   4729          
   4730            htim->State = HAL_TIM_STATE_READY;
   4731          
   4732            __HAL_UNLOCK(htim);
   4733          
   4734            return HAL_OK;
   4735          }
   4736          
   4737          /**
   4738            * @brief  Read the captured value from Capture Compare unit
   4739            * @param  htim TIM handle.
   4740            * @param  Channel TIM Channels to be enabled
   4741            *          This parameter can be one of the following values:
   4742            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4743            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4744            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4745            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4746            * @retval Captured value
   4747            */

   \                                 In section .text, align 2, keep-with-next
   4748          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4749          {
   \                     HAL_TIM_ReadCapturedValue: (+1)
   \        0x0   0x4602             MOV      R2,R0
   4750            uint32_t tmpreg = 0U;
   \        0x2   0x2000             MOVS     R0,#+0
   4751          
   4752            switch (Channel)
   \        0x4   0xB131             CBZ.N    R1,??HAL_TIM_ReadCapturedValue_0
   \        0x6   0x2904             CMP      R1,#+4
   \        0x8   0xD007             BEQ.N    ??HAL_TIM_ReadCapturedValue_1
   \        0xA   0x2908             CMP      R1,#+8
   \        0xC   0xD008             BEQ.N    ??HAL_TIM_ReadCapturedValue_2
   \        0xE   0x290C             CMP      R1,#+12
   \       0x10   0xD009             BEQ.N    ??HAL_TIM_ReadCapturedValue_3
   \       0x12   0x4770             BX       LR
   4753            {
   4754              case TIM_CHANNEL_1:
   4755              {
   4756                /* Check the parameters */
   4757                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4758          
   4759                /* Return the capture 1 value */
   4760                tmpreg =  htim->Instance->CCR1;
   \                     ??HAL_TIM_ReadCapturedValue_0: (+1)
   \       0x14   0x6810             LDR      R0,[R2, #+0]
   \       0x16   0x6B40             LDR      R0,[R0, #+52]
   4761          
   4762                break;
   \       0x18   0x4770             BX       LR
   4763              }
   4764              case TIM_CHANNEL_2:
   4765              {
   4766                /* Check the parameters */
   4767                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4768          
   4769                /* Return the capture 2 value */
   4770                tmpreg =   htim->Instance->CCR2;
   \                     ??HAL_TIM_ReadCapturedValue_1: (+1)
   \       0x1A   0x6810             LDR      R0,[R2, #+0]
   \       0x1C   0x6B80             LDR      R0,[R0, #+56]
   4771          
   4772                break;
   \       0x1E   0x4770             BX       LR
   4773              }
   4774          
   4775              case TIM_CHANNEL_3:
   4776              {
   4777                /* Check the parameters */
   4778                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4779          
   4780                /* Return the capture 3 value */
   4781                tmpreg =   htim->Instance->CCR3;
   \                     ??HAL_TIM_ReadCapturedValue_2: (+1)
   \       0x20   0x6810             LDR      R0,[R2, #+0]
   \       0x22   0x6BC0             LDR      R0,[R0, #+60]
   4782          
   4783                break;
   \       0x24   0x4770             BX       LR
   4784              }
   4785          
   4786              case TIM_CHANNEL_4:
   4787              {
   4788                /* Check the parameters */
   4789                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4790          
   4791                /* Return the capture 4 value */
   4792                tmpreg =   htim->Instance->CCR4;
   \                     ??HAL_TIM_ReadCapturedValue_3: (+1)
   \       0x26   0x6810             LDR      R0,[R2, #+0]
   \       0x28   0x6C00             LDR      R0,[R0, #+64]
   4793          
   4794                break;
   4795              }
   4796          
   4797              default:
   4798                break;
   4799            }
   4800          
   4801            return tmpreg;
   \       0x2A   0x4770             BX       LR               ;; return
   4802          }
   4803          
   4804          /**
   4805            * @}
   4806            */
   4807          
   4808          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4809            *  @brief    TIM Callbacks functions
   4810            *
   4811          @verbatim
   4812            ==============================================================================
   4813                                  ##### TIM Callbacks functions #####
   4814            ==============================================================================
   4815           [..]
   4816             This section provides TIM callback functions:
   4817             (+) TIM Period elapsed callback
   4818             (+) TIM Output Compare callback
   4819             (+) TIM Input capture callback
   4820             (+) TIM Trigger callback
   4821             (+) TIM Error callback
   4822          
   4823          @endverbatim
   4824            * @{
   4825            */
   4826          
   4827          /**
   4828            * @brief  Period elapsed callback in non-blocking mode
   4829            * @param  htim TIM handle
   4830            * @retval None
   4831            */

   \                                 In section .text, align 2
   4832          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4833          {
   4834            /* Prevent unused argument(s) compilation warning */
   4835            UNUSED(htim);
   4836          
   4837            /* NOTE : This function should not be modified, when the callback is needed,
   4838                      the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4839             */
   4840          }
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4841          
   4842          /**
   4843            * @brief  Period elapsed half complete callback in non-blocking mode
   4844            * @param  htim TIM handle
   4845            * @retval None
   4846            */

   \                                 In section .text, align 2
   4847          __weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)
   4848          {
   4849            /* Prevent unused argument(s) compilation warning */
   4850            UNUSED(htim);
   4851          
   4852            /* NOTE : This function should not be modified, when the callback is needed,
   4853                      the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
   4854             */
   4855          }
   \                     HAL_TIM_PeriodElapsedHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4856          
   4857          /**
   4858            * @brief  Output Compare callback in non-blocking mode
   4859            * @param  htim TIM OC handle
   4860            * @retval None
   4861            */

   \                                 In section .text, align 2
   4862          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4863          {
   4864            /* Prevent unused argument(s) compilation warning */
   4865            UNUSED(htim);
   4866          
   4867            /* NOTE : This function should not be modified, when the callback is needed,
   4868                      the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4869             */
   4870          }
   \                     HAL_TIM_OC_DelayElapsedCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4871          
   4872          /**
   4873            * @brief  Input Capture callback in non-blocking mode
   4874            * @param  htim TIM IC handle
   4875            * @retval None
   4876            */

   \                                 In section .text, align 2
   4877          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4878          {
   4879            /* Prevent unused argument(s) compilation warning */
   4880            UNUSED(htim);
   4881          
   4882            /* NOTE : This function should not be modified, when the callback is needed,
   4883                      the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4884             */
   4885          }
   \                     HAL_TIM_IC_CaptureCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4886          
   4887          /**
   4888            * @brief  Input Capture half complete callback in non-blocking mode
   4889            * @param  htim TIM IC handle
   4890            * @retval None
   4891            */

   \                                 In section .text, align 2
   4892          __weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)
   4893          {
   4894            /* Prevent unused argument(s) compilation warning */
   4895            UNUSED(htim);
   4896          
   4897            /* NOTE : This function should not be modified, when the callback is needed,
   4898                      the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
   4899             */
   4900          }
   \                     HAL_TIM_IC_CaptureHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4901          
   4902          /**
   4903            * @brief  PWM Pulse finished callback in non-blocking mode
   4904            * @param  htim TIM handle
   4905            * @retval None
   4906            */

   \                                 In section .text, align 2
   4907          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4908          {
   4909            /* Prevent unused argument(s) compilation warning */
   4910            UNUSED(htim);
   4911          
   4912            /* NOTE : This function should not be modified, when the callback is needed,
   4913                      the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4914             */
   4915          }
   \                     HAL_TIM_PWM_PulseFinishedCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4916          
   4917          /**
   4918            * @brief  PWM Pulse finished half complete callback in non-blocking mode
   4919            * @param  htim TIM handle
   4920            * @retval None
   4921            */

   \                                 In section .text, align 2
   4922          __weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)
   4923          {
   4924            /* Prevent unused argument(s) compilation warning */
   4925            UNUSED(htim);
   4926          
   4927            /* NOTE : This function should not be modified, when the callback is needed,
   4928                      the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
   4929             */
   4930          }
   \                     HAL_TIM_PWM_PulseFinishedHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4931          
   4932          /**
   4933            * @brief  Hall Trigger detection callback in non-blocking mode
   4934            * @param  htim TIM handle
   4935            * @retval None
   4936            */

   \                                 In section .text, align 2
   4937          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4938          {
   4939            /* Prevent unused argument(s) compilation warning */
   4940            UNUSED(htim);
   4941          
   4942            /* NOTE : This function should not be modified, when the callback is needed,
   4943                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4944             */
   4945          }
   \                     HAL_TIM_TriggerCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4946          
   4947          /**
   4948            * @brief  Hall Trigger detection half complete callback in non-blocking mode
   4949            * @param  htim TIM handle
   4950            * @retval None
   4951            */

   \                                 In section .text, align 2
   4952          __weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)
   4953          {
   4954            /* Prevent unused argument(s) compilation warning */
   4955            UNUSED(htim);
   4956          
   4957            /* NOTE : This function should not be modified, when the callback is needed,
   4958                      the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
   4959             */
   4960          }
   \                     HAL_TIM_TriggerHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4961          
   4962          /**
   4963            * @brief  Timer error callback in non-blocking mode
   4964            * @param  htim TIM handle
   4965            * @retval None
   4966            */

   \                                 In section .text, align 2
   4967          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4968          {
   4969            /* Prevent unused argument(s) compilation warning */
   4970            UNUSED(htim);
   4971          
   4972            /* NOTE : This function should not be modified, when the callback is needed,
   4973                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4974             */
   4975          }
   \                     HAL_TIM_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4976          
   4977          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   4978          /**
   4979            * @brief  Register a User TIM callback to be used instead of the weak predefined callback
   4980            * @param htim tim handle
   4981            * @param CallbackID ID of the callback to be registered
   4982            *        This parameter can be one of the following values:
   4983            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   4984            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   4985            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   4986            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   4987            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   4988            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   4989            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   4990            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   4991            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   4992            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   4993            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   4994            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   4995            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   4996            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   4997            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   4998            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   4999            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   5000            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   5001            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   5002            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   5003            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   5004            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   5005            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   5006            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   5007            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   5008            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   5009            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   5010            *          @param pCallback pointer to the callback function
   5011            *          @retval status
   5012            */
   5013          HAL_StatusTypeDef HAL_TIM_RegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID,
   5014                                                     pTIM_CallbackTypeDef pCallback)
   5015          {
   5016            HAL_StatusTypeDef status = HAL_OK;
   5017          
   5018            if (pCallback == NULL)
   5019            {
   5020              return HAL_ERROR;
   5021            }
   5022            /* Process locked */
   5023            __HAL_LOCK(htim);
   5024          
   5025            if (htim->State == HAL_TIM_STATE_READY)
   5026            {
   5027              switch (CallbackID)
   5028              {
   5029                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5030                  htim->Base_MspInitCallback                 = pCallback;
   5031                  break;
   5032          
   5033                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5034                  htim->Base_MspDeInitCallback               = pCallback;
   5035                  break;
   5036          
   5037                case HAL_TIM_IC_MSPINIT_CB_ID :
   5038                  htim->IC_MspInitCallback                   = pCallback;
   5039                  break;
   5040          
   5041                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5042                  htim->IC_MspDeInitCallback                 = pCallback;
   5043                  break;
   5044          
   5045                case HAL_TIM_OC_MSPINIT_CB_ID :
   5046                  htim->OC_MspInitCallback                   = pCallback;
   5047                  break;
   5048          
   5049                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5050                  htim->OC_MspDeInitCallback                 = pCallback;
   5051                  break;
   5052          
   5053                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5054                  htim->PWM_MspInitCallback                  = pCallback;
   5055                  break;
   5056          
   5057                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5058                  htim->PWM_MspDeInitCallback                = pCallback;
   5059                  break;
   5060          
   5061                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5062                  htim->OnePulse_MspInitCallback             = pCallback;
   5063                  break;
   5064          
   5065                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5066                  htim->OnePulse_MspDeInitCallback           = pCallback;
   5067                  break;
   5068          
   5069                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5070                  htim->Encoder_MspInitCallback              = pCallback;
   5071                  break;
   5072          
   5073                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5074                  htim->Encoder_MspDeInitCallback            = pCallback;
   5075                  break;
   5076          
   5077                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5078                  htim->HallSensor_MspInitCallback           = pCallback;
   5079                  break;
   5080          
   5081                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5082                  htim->HallSensor_MspDeInitCallback         = pCallback;
   5083                  break;
   5084          
   5085                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   5086                  htim->PeriodElapsedCallback                = pCallback;
   5087                  break;
   5088          
   5089                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   5090                  htim->PeriodElapsedHalfCpltCallback        = pCallback;
   5091                  break;
   5092          
   5093                case HAL_TIM_TRIGGER_CB_ID :
   5094                  htim->TriggerCallback                      = pCallback;
   5095                  break;
   5096          
   5097                case HAL_TIM_TRIGGER_HALF_CB_ID :
   5098                  htim->TriggerHalfCpltCallback              = pCallback;
   5099                  break;
   5100          
   5101                case HAL_TIM_IC_CAPTURE_CB_ID :
   5102                  htim->IC_CaptureCallback                   = pCallback;
   5103                  break;
   5104          
   5105                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   5106                  htim->IC_CaptureHalfCpltCallback           = pCallback;
   5107                  break;
   5108          
   5109                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   5110                  htim->OC_DelayElapsedCallback              = pCallback;
   5111                  break;
   5112          
   5113                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   5114                  htim->PWM_PulseFinishedCallback            = pCallback;
   5115                  break;
   5116          
   5117                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   5118                  htim->PWM_PulseFinishedHalfCpltCallback    = pCallback;
   5119                  break;
   5120          
   5121                case HAL_TIM_ERROR_CB_ID :
   5122                  htim->ErrorCallback                        = pCallback;
   5123                  break;
   5124          
   5125                case HAL_TIM_COMMUTATION_CB_ID :
   5126                  htim->CommutationCallback                  = pCallback;
   5127                  break;
   5128          
   5129                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   5130                  htim->CommutationHalfCpltCallback          = pCallback;
   5131                  break;
   5132          
   5133                case HAL_TIM_BREAK_CB_ID :
   5134                  htim->BreakCallback                        = pCallback;
   5135                  break;
   5136          
   5137                default :
   5138                  /* Return error status */
   5139                  status =  HAL_ERROR;
   5140                  break;
   5141              }
   5142            }
   5143            else if (htim->State == HAL_TIM_STATE_RESET)
   5144            {
   5145              switch (CallbackID)
   5146              {
   5147                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5148                  htim->Base_MspInitCallback         = pCallback;
   5149                  break;
   5150          
   5151                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5152                  htim->Base_MspDeInitCallback       = pCallback;
   5153                  break;
   5154          
   5155                case HAL_TIM_IC_MSPINIT_CB_ID :
   5156                  htim->IC_MspInitCallback           = pCallback;
   5157                  break;
   5158          
   5159                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5160                  htim->IC_MspDeInitCallback         = pCallback;
   5161                  break;
   5162          
   5163                case HAL_TIM_OC_MSPINIT_CB_ID :
   5164                  htim->OC_MspInitCallback           = pCallback;
   5165                  break;
   5166          
   5167                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5168                  htim->OC_MspDeInitCallback         = pCallback;
   5169                  break;
   5170          
   5171                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5172                  htim->PWM_MspInitCallback          = pCallback;
   5173                  break;
   5174          
   5175                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5176                  htim->PWM_MspDeInitCallback        = pCallback;
   5177                  break;
   5178          
   5179                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5180                  htim->OnePulse_MspInitCallback     = pCallback;
   5181                  break;
   5182          
   5183                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5184                  htim->OnePulse_MspDeInitCallback   = pCallback;
   5185                  break;
   5186          
   5187                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5188                  htim->Encoder_MspInitCallback      = pCallback;
   5189                  break;
   5190          
   5191                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5192                  htim->Encoder_MspDeInitCallback    = pCallback;
   5193                  break;
   5194          
   5195                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5196                  htim->HallSensor_MspInitCallback   = pCallback;
   5197                  break;
   5198          
   5199                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5200                  htim->HallSensor_MspDeInitCallback = pCallback;
   5201                  break;
   5202          
   5203                default :
   5204                  /* Return error status */
   5205                  status =  HAL_ERROR;
   5206                  break;
   5207              }
   5208            }
   5209            else
   5210            {
   5211              /* Return error status */
   5212              status =  HAL_ERROR;
   5213            }
   5214          
   5215            /* Release Lock */
   5216            __HAL_UNLOCK(htim);
   5217          
   5218            return status;
   5219          }
   5220          
   5221          /**
   5222            * @brief  Unregister a TIM callback
   5223            *         TIM callback is redirected to the weak predefined callback
   5224            * @param htim tim handle
   5225            * @param CallbackID ID of the callback to be unregistered
   5226            *        This parameter can be one of the following values:
   5227            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   5228            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   5229            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   5230            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   5231            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   5232            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   5233            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   5234            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   5235            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   5236            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   5237            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   5238            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   5239            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   5240            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   5241            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   5242            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   5243            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   5244            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   5245            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   5246            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   5247            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   5248            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   5249            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   5250            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   5251            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   5252            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   5253            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   5254            *          @retval status
   5255            */
   5256          HAL_StatusTypeDef HAL_TIM_UnRegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID)
   5257          {
   5258            HAL_StatusTypeDef status = HAL_OK;
   5259          
   5260            /* Process locked */
   5261            __HAL_LOCK(htim);
   5262          
   5263            if (htim->State == HAL_TIM_STATE_READY)
   5264            {
   5265              switch (CallbackID)
   5266              {
   5267                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5268                  htim->Base_MspInitCallback              = HAL_TIM_Base_MspInit;                      /* Legacy weak Base MspInit Callback */
   5269                  break;
   5270          
   5271                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5272                  htim->Base_MspDeInitCallback            = HAL_TIM_Base_MspDeInit;                    /* Legacy weak Base Msp DeInit Callback */
   5273                  break;
   5274          
   5275                case HAL_TIM_IC_MSPINIT_CB_ID :
   5276                  htim->IC_MspInitCallback                = HAL_TIM_IC_MspInit;                        /* Legacy weak IC Msp Init Callback */
   5277                  break;
   5278          
   5279                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5280                  htim->IC_MspDeInitCallback              = HAL_TIM_IC_MspDeInit;                      /* Legacy weak IC Msp DeInit Callback */
   5281                  break;
   5282          
   5283                case HAL_TIM_OC_MSPINIT_CB_ID :
   5284                  htim->OC_MspInitCallback                = HAL_TIM_OC_MspInit;                        /* Legacy weak OC Msp Init Callback */
   5285                  break;
   5286          
   5287                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5288                  htim->OC_MspDeInitCallback              = HAL_TIM_OC_MspDeInit;                      /* Legacy weak OC Msp DeInit Callback */
   5289                  break;
   5290          
   5291                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5292                  htim->PWM_MspInitCallback               = HAL_TIM_PWM_MspInit;                       /* Legacy weak PWM Msp Init Callback */
   5293                  break;
   5294          
   5295                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5296                  htim->PWM_MspDeInitCallback             = HAL_TIM_PWM_MspDeInit;                     /* Legacy weak PWM Msp DeInit Callback */
   5297                  break;
   5298          
   5299                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5300                  htim->OnePulse_MspInitCallback          = HAL_TIM_OnePulse_MspInit;                  /* Legacy weak One Pulse Msp Init Callback */
   5301                  break;
   5302          
   5303                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5304                  htim->OnePulse_MspDeInitCallback        = HAL_TIM_OnePulse_MspDeInit;                /* Legacy weak One Pulse Msp DeInit Callback */
   5305                  break;
   5306          
   5307                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5308                  htim->Encoder_MspInitCallback           = HAL_TIM_Encoder_MspInit;                   /* Legacy weak Encoder Msp Init Callback */
   5309                  break;
   5310          
   5311                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5312                  htim->Encoder_MspDeInitCallback         = HAL_TIM_Encoder_MspDeInit;                 /* Legacy weak Encoder Msp DeInit Callback */
   5313                  break;
   5314          
   5315                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5316                  htim->HallSensor_MspInitCallback        = HAL_TIMEx_HallSensor_MspInit;              /* Legacy weak Hall Sensor Msp Init Callback */
   5317                  break;
   5318          
   5319                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5320                  htim->HallSensor_MspDeInitCallback      = HAL_TIMEx_HallSensor_MspDeInit;            /* Legacy weak Hall Sensor Msp DeInit Callback */
   5321                  break;
   5322          
   5323                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   5324                  htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak Period Elapsed Callback */
   5325                  break;
   5326          
   5327                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   5328                  htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak Period Elapsed half complete Callback */
   5329                  break;
   5330          
   5331                case HAL_TIM_TRIGGER_CB_ID :
   5332                  htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak Trigger Callback */
   5333                  break;
   5334          
   5335                case HAL_TIM_TRIGGER_HALF_CB_ID :
   5336                  htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak Trigger half complete Callback */
   5337                  break;
   5338          
   5339                case HAL_TIM_IC_CAPTURE_CB_ID :
   5340                  htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC Capture Callback */
   5341                  break;
   5342          
   5343                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   5344                  htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC Capture half complete Callback */
   5345                  break;
   5346          
   5347                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   5348                  htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC Delay Elapsed Callback */
   5349                  break;
   5350          
   5351                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   5352                  htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM Pulse Finished Callback */
   5353                  break;
   5354          
   5355                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   5356                  htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM Pulse Finished half complete Callback */
   5357                  break;
   5358          
   5359                case HAL_TIM_ERROR_CB_ID :
   5360                  htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak Error Callback */
   5361                  break;
   5362          
   5363                case HAL_TIM_COMMUTATION_CB_ID :
   5364                  htim->CommutationCallback               = HAL_TIMEx_CommutCallback;                  /* Legacy weak Commutation Callback */
   5365                  break;
   5366          
   5367                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   5368                  htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;          /* Legacy weak Commutation half complete Callback */
   5369                  break;
   5370          
   5371                case HAL_TIM_BREAK_CB_ID :
   5372                  htim->BreakCallback                     = HAL_TIMEx_BreakCallback;                   /* Legacy weak Break Callback */
   5373                  break;
   5374          
   5375                default :
   5376                  /* Return error status */
   5377                  status =  HAL_ERROR;
   5378                  break;
   5379              }
   5380            }
   5381            else if (htim->State == HAL_TIM_STATE_RESET)
   5382            {
   5383              switch (CallbackID)
   5384              {
   5385                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5386                  htim->Base_MspInitCallback         = HAL_TIM_Base_MspInit;              /* Legacy weak Base MspInit Callback */
   5387                  break;
   5388          
   5389                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5390                  htim->Base_MspDeInitCallback       = HAL_TIM_Base_MspDeInit;            /* Legacy weak Base Msp DeInit Callback */
   5391                  break;
   5392          
   5393                case HAL_TIM_IC_MSPINIT_CB_ID :
   5394                  htim->IC_MspInitCallback           = HAL_TIM_IC_MspInit;                /* Legacy weak IC Msp Init Callback */
   5395                  break;
   5396          
   5397                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5398                  htim->IC_MspDeInitCallback         = HAL_TIM_IC_MspDeInit;              /* Legacy weak IC Msp DeInit Callback */
   5399                  break;
   5400          
   5401                case HAL_TIM_OC_MSPINIT_CB_ID :
   5402                  htim->OC_MspInitCallback           = HAL_TIM_OC_MspInit;                /* Legacy weak OC Msp Init Callback */
   5403                  break;
   5404          
   5405                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5406                  htim->OC_MspDeInitCallback         = HAL_TIM_OC_MspDeInit;              /* Legacy weak OC Msp DeInit Callback */
   5407                  break;
   5408          
   5409                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5410                  htim->PWM_MspInitCallback          = HAL_TIM_PWM_MspInit;               /* Legacy weak PWM Msp Init Callback */
   5411                  break;
   5412          
   5413                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5414                  htim->PWM_MspDeInitCallback        = HAL_TIM_PWM_MspDeInit;             /* Legacy weak PWM Msp DeInit Callback */
   5415                  break;
   5416          
   5417                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5418                  htim->OnePulse_MspInitCallback     = HAL_TIM_OnePulse_MspInit;          /* Legacy weak One Pulse Msp Init Callback */
   5419                  break;
   5420          
   5421                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5422                  htim->OnePulse_MspDeInitCallback   = HAL_TIM_OnePulse_MspDeInit;        /* Legacy weak One Pulse Msp DeInit Callback */
   5423                  break;
   5424          
   5425                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5426                  htim->Encoder_MspInitCallback      = HAL_TIM_Encoder_MspInit;           /* Legacy weak Encoder Msp Init Callback */
   5427                  break;
   5428          
   5429                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5430                  htim->Encoder_MspDeInitCallback    = HAL_TIM_Encoder_MspDeInit;         /* Legacy weak Encoder Msp DeInit Callback */
   5431                  break;
   5432          
   5433                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5434                  htim->HallSensor_MspInitCallback   = HAL_TIMEx_HallSensor_MspInit;      /* Legacy weak Hall Sensor Msp Init Callback */
   5435                  break;
   5436          
   5437                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5438                  htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;    /* Legacy weak Hall Sensor Msp DeInit Callback */
   5439                  break;
   5440          
   5441                default :
   5442                  /* Return error status */
   5443                  status =  HAL_ERROR;
   5444                  break;
   5445              }
   5446            }
   5447            else
   5448            {
   5449              /* Return error status */
   5450              status =  HAL_ERROR;
   5451            }
   5452          
   5453            /* Release Lock */
   5454            __HAL_UNLOCK(htim);
   5455          
   5456            return status;
   5457          }
   5458          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5459          
   5460          /**
   5461            * @}
   5462            */
   5463          
   5464          /** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
   5465            *  @brief   TIM Peripheral State functions
   5466            *
   5467          @verbatim
   5468            ==============================================================================
   5469                                  ##### Peripheral State functions #####
   5470            ==============================================================================
   5471              [..]
   5472              This subsection permits to get in run-time the status of the peripheral
   5473              and the data flow.
   5474          
   5475          @endverbatim
   5476            * @{
   5477            */
   5478          
   5479          /**
   5480            * @brief  Return the TIM Base handle state.
   5481            * @param  htim TIM Base handle
   5482            * @retval HAL state
   5483            */

   \                                 In section .text, align 2, keep-with-next
   5484          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   5485          {
   5486            return htim->State;
   \                     HAL_TIM_Base_GetState: (+1)
   \        0x0   0x....             B.N      ?Subroutine14
   5487          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \        0x4   0x4770             BX       LR               ;; return
   5488          
   5489          /**
   5490            * @brief  Return the TIM OC handle state.
   5491            * @param  htim TIM Output Compare handle
   5492            * @retval HAL state
   5493            */

   \                                 In section .text, align 4, keep-with-next
   5494          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   5495          {
   5496            return htim->State;
   \                     HAL_TIM_OC_GetState: (+1)
   \        0x0   0xBF00             Nop
   \        0x2                      REQUIRE ?Subroutine14
   \        0x2                      ;; // Fall through to label ?Subroutine14
   5497          }
   5498          
   5499          /**
   5500            * @brief  Return the TIM PWM handle state.
   5501            * @param  htim TIM handle
   5502            * @retval HAL state
   5503            */

   \                                 In section .text, align 2, keep-with-next
   5504          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   5505          {
   5506            return htim->State;
   \                     HAL_TIM_PWM_GetState: (+1)
   \        0x0   0x....             B.N      ?Subroutine14
   5507          }
   5508          
   5509          /**
   5510            * @brief  Return the TIM Input Capture handle state.
   5511            * @param  htim TIM IC handle
   5512            * @retval HAL state
   5513            */

   \                                 In section .text, align 2, keep-with-next
   5514          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   5515          {
   5516            return htim->State;
   \                     HAL_TIM_IC_GetState: (+1)
   \        0x0   0x....             B.N      ?Subroutine14
   5517          }
   5518          
   5519          /**
   5520            * @brief  Return the TIM One Pulse Mode handle state.
   5521            * @param  htim TIM OPM handle
   5522            * @retval HAL state
   5523            */

   \                                 In section .text, align 2, keep-with-next
   5524          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   5525          {
   5526            return htim->State;
   \                     HAL_TIM_OnePulse_GetState: (+1)
   \        0x0   0x....             B.N      ?Subroutine14
   5527          }
   5528          
   5529          /**
   5530            * @brief  Return the TIM Encoder Mode handle state.
   5531            * @param  htim TIM Encoder Interface handle
   5532            * @retval HAL state
   5533            */

   \                                 In section .text, align 2, keep-with-next
   5534          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   5535          {
   5536            return htim->State;
   \                     HAL_TIM_Encoder_GetState: (+1)
   \        0x0   0x....             B.N      ?Subroutine14
   5537          }
   5538          
   5539          /**
   5540            * @}
   5541            */
   5542          
   5543          /**
   5544            * @}
   5545            */
   5546          
   5547          /** @defgroup TIM_Private_Functions TIM Private Functions
   5548            * @{
   5549            */
   5550          
   5551          /**
   5552            * @brief  TIM DMA error callback
   5553            * @param  hdma pointer to DMA handle.
   5554            * @retval None
   5555            */

   \                                 In section .text, align 4, keep-with-next
   5556          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   5557          {
   5558            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \                     TIM_DMAError: (+1)
   \        0x0   0x6B80             LDR      R0,[R0, #+56]
   5559          
   5560            htim->State = HAL_TIM_STATE_READY;
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0xF880 0x103D      STRB     R1,[R0, #+61]
   5561          
   5562          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5563            htim->ErrorCallback(htim);
   5564          #else
   5565            HAL_TIM_ErrorCallback(htim);
   \        0x8   0x....'....        B.W      HAL_TIM_ErrorCallback
   5566          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5567          }
   5568          
   5569          /**
   5570            * @brief  TIM DMA Delay Pulse complete callback.
   5571            * @param  hdma pointer to DMA handle.
   5572            * @retval None
   5573            */

   \                                 In section .text, align 4, keep-with-next
   5574          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   5575          {
   \                     TIM_DMADelayPulseCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5576            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x....'....        BL       ?Subroutine64
   5577          
   5578            htim->State = HAL_TIM_STATE_READY;
   5579          
   5580            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \                     ??CrossCallReturnLabel_183: (+1)
   \        0x6   0xBF08             IT       EQ
   \        0x8   0x7721             STRBEQ   R1,[R4, #+28]
   5581            {
   5582              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \        0xA   0xD00E             BEQ.N    ??TIM_DMADelayPulseCplt_0
   5583            }
   5584            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \        0xC   0x6AA1             LDR      R1,[R4, #+40]
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xBF08             IT       EQ
   \       0x12   0x2002             MOVEQ    R0,#+2
   5585            {
   5586              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x14   0xD008             BEQ.N    ??TIM_DMADelayPulseCplt_1
   5587            }
   5588            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \       0x16   0x6AE1             LDR      R1,[R4, #+44]
   \       0x18   0x4288             CMP      R0,R1
   \       0x1A   0xBF08             IT       EQ
   \       0x1C   0x2004             MOVEQ    R0,#+4
   5589            {
   5590              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x1E   0xD003             BEQ.N    ??TIM_DMADelayPulseCplt_1
   5591            }
   5592            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \       0x20   0x6B21             LDR      R1,[R4, #+48]
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD101             BNE.N    ??TIM_DMADelayPulseCplt_0
   5593            {
   5594              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x26   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMADelayPulseCplt_1: (+1)
   \       0x28   0x7720             STRB     R0,[R4, #+28]
   5595            }
   5596            else
   5597            {
   5598              /* nothing to do */
   5599            }
   5600          
   5601          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5602            htim->PWM_PulseFinishedCallback(htim);
   5603          #else
   5604            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_0: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x....'....        BL       HAL_TIM_PWM_PulseFinishedCallback
   5605          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5606          
   5607            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x30   0x....             B.N      ?Subroutine11
   5608          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x7720             STRB     R0,[R4, #+28]
   \        0x4   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine64: (+1)
   \        0x0   0x6B84             LDR      R4,[R0, #+56]
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0xF884 0x103D      STRB     R1,[R4, #+61]
   \        0x8   0x6A62             LDR      R2,[R4, #+36]
   \        0xA   0x4290             CMP      R0,R2
   \        0xC   0x4770             BX       LR
   5609          
   5610          /**
   5611            * @brief  TIM DMA Delay Pulse half complete callback.
   5612            * @param  hdma pointer to DMA handle.
   5613            * @retval None
   5614            */

   \                                 In section .text, align 4, keep-with-next
   5615          void TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)
   5616          {
   \                     TIM_DMADelayPulseHalfCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5617            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x....'....        BL       ?Subroutine64
   5618          
   5619            htim->State = HAL_TIM_STATE_READY;
   5620          
   5621            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \                     ??CrossCallReturnLabel_184: (+1)
   \        0x6   0xBF08             IT       EQ
   \        0x8   0x7721             STRBEQ   R1,[R4, #+28]
   5622            {
   5623              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \        0xA   0xD00E             BEQ.N    ??TIM_DMADelayPulseHalfCplt_0
   5624            }
   5625            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \        0xC   0x6AA1             LDR      R1,[R4, #+40]
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xBF08             IT       EQ
   \       0x12   0x2002             MOVEQ    R0,#+2
   5626            {
   5627              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x14   0xD008             BEQ.N    ??TIM_DMADelayPulseHalfCplt_1
   5628            }
   5629            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \       0x16   0x6AE1             LDR      R1,[R4, #+44]
   \       0x18   0x4288             CMP      R0,R1
   \       0x1A   0xBF08             IT       EQ
   \       0x1C   0x2004             MOVEQ    R0,#+4
   5630            {
   5631              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x1E   0xD003             BEQ.N    ??TIM_DMADelayPulseHalfCplt_1
   5632            }
   5633            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \       0x20   0x6B21             LDR      R1,[R4, #+48]
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD101             BNE.N    ??TIM_DMADelayPulseHalfCplt_0
   5634            {
   5635              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x26   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMADelayPulseHalfCplt_1: (+1)
   \       0x28   0x7720             STRB     R0,[R4, #+28]
   5636            }
   5637            else
   5638            {
   5639              /* nothing to do */
   5640            }
   5641          
   5642          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5643            htim->PWM_PulseFinishedHalfCpltCallback(htim);
   5644          #else
   5645            HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
   \                     ??TIM_DMADelayPulseHalfCplt_0: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x....'....        BL       HAL_TIM_PWM_PulseFinishedHalfCpltCallback
   5646          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5647          
   5648            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x30                      REQUIRE ?Subroutine11
   \       0x30                      ;; // Fall through to label ?Subroutine11
   5649          }
   5650          
   5651          /**
   5652            * @brief  TIM DMA Capture complete callback.
   5653            * @param  hdma pointer to DMA handle.
   5654            * @retval None
   5655            */

   \                                 In section .text, align 4, keep-with-next
   5656          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   5657          {
   \                     TIM_DMACaptureCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5658            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x....'....        BL       ?Subroutine64
   5659          
   5660            htim->State = HAL_TIM_STATE_READY;
   5661          
   5662            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \                     ??CrossCallReturnLabel_185: (+1)
   \        0x6   0xBF08             IT       EQ
   \        0x8   0x7721             STRBEQ   R1,[R4, #+28]
   5663            {
   5664              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \        0xA   0xD00E             BEQ.N    ??TIM_DMACaptureCplt_0
   5665            }
   5666            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \        0xC   0x6AA1             LDR      R1,[R4, #+40]
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xBF08             IT       EQ
   \       0x12   0x2002             MOVEQ    R0,#+2
   5667            {
   5668              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x14   0xD008             BEQ.N    ??TIM_DMACaptureCplt_1
   5669            }
   5670            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \       0x16   0x6AE1             LDR      R1,[R4, #+44]
   \       0x18   0x4288             CMP      R0,R1
   \       0x1A   0xBF08             IT       EQ
   \       0x1C   0x2004             MOVEQ    R0,#+4
   5671            {
   5672              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x1E   0xD003             BEQ.N    ??TIM_DMACaptureCplt_1
   5673            }
   5674            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \       0x20   0x6B21             LDR      R1,[R4, #+48]
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD101             BNE.N    ??TIM_DMACaptureCplt_0
   5675            {
   5676              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x26   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMACaptureCplt_1: (+1)
   \       0x28   0x7720             STRB     R0,[R4, #+28]
   5677            }
   5678            else
   5679            {
   5680              /* nothing to do */
   5681            }
   5682          
   5683          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5684            htim->IC_CaptureCallback(htim);
   5685          #else
   5686            HAL_TIM_IC_CaptureCallback(htim);
   \                     ??TIM_DMACaptureCplt_0: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   5687          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5688          
   5689            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x30   0x....             B.N      ?Subroutine11
   5690          }
   5691          
   5692          /**
   5693            * @brief  TIM DMA Capture half complete callback.
   5694            * @param  hdma pointer to DMA handle.
   5695            * @retval None
   5696            */

   \                                 In section .text, align 4, keep-with-next
   5697          void TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)
   5698          {
   \                     TIM_DMACaptureHalfCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5699            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x....'....        BL       ?Subroutine64
   5700          
   5701            htim->State = HAL_TIM_STATE_READY;
   5702          
   5703            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \                     ??CrossCallReturnLabel_186: (+1)
   \        0x6   0xBF08             IT       EQ
   \        0x8   0x7721             STRBEQ   R1,[R4, #+28]
   5704            {
   5705              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \        0xA   0xD00E             BEQ.N    ??TIM_DMACaptureHalfCplt_0
   5706            }
   5707            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \        0xC   0x6AA1             LDR      R1,[R4, #+40]
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xBF08             IT       EQ
   \       0x12   0x2002             MOVEQ    R0,#+2
   5708            {
   5709              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x14   0xD008             BEQ.N    ??TIM_DMACaptureHalfCplt_1
   5710            }
   5711            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \       0x16   0x6AE1             LDR      R1,[R4, #+44]
   \       0x18   0x4288             CMP      R0,R1
   \       0x1A   0xBF08             IT       EQ
   \       0x1C   0x2004             MOVEQ    R0,#+4
   5712            {
   5713              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x1E   0xD003             BEQ.N    ??TIM_DMACaptureHalfCplt_1
   5714            }
   5715            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \       0x20   0x6B21             LDR      R1,[R4, #+48]
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD101             BNE.N    ??TIM_DMACaptureHalfCplt_0
   5716            {
   5717              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x26   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMACaptureHalfCplt_1: (+1)
   \       0x28   0x7720             STRB     R0,[R4, #+28]
   5718            }
   5719            else
   5720            {
   5721              /* nothing to do */
   5722            }
   5723          
   5724          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5725            htim->IC_CaptureHalfCpltCallback(htim);
   5726          #else
   5727            HAL_TIM_IC_CaptureHalfCpltCallback(htim);
   \                     ??TIM_DMACaptureHalfCplt_0: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x....'....        BL       HAL_TIM_IC_CaptureHalfCpltCallback
   5728          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5729          
   5730            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x30   0x....             B.N      ?Subroutine11
   5731          }
   5732          
   5733          /**
   5734            * @brief  TIM DMA Period Elapse complete callback.
   5735            * @param  hdma pointer to DMA handle.
   5736            * @retval None
   5737            */

   \                                 In section .text, align 4, keep-with-next
   5738          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   5739          {
   5740            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \                     TIM_DMAPeriodElapsedCplt: (+1)
   \        0x0   0x6B80             LDR      R0,[R0, #+56]
   5741          
   5742            htim->State = HAL_TIM_STATE_READY;
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0xF880 0x103D      STRB     R1,[R0, #+61]
   5743          
   5744          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5745            htim->PeriodElapsedCallback(htim);
   5746          #else
   5747            HAL_TIM_PeriodElapsedCallback(htim);
   \        0x8   0x....'....        B.W      HAL_TIM_PeriodElapsedCallback
   5748          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5749          }
   5750          
   5751          /**
   5752            * @brief  TIM DMA Period Elapse half complete callback.
   5753            * @param  hdma pointer to DMA handle.
   5754            * @retval None
   5755            */

   \                                 In section .text, align 4, keep-with-next
   5756          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)
   5757          {
   5758            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \                     TIM_DMAPeriodElapsedHalfCplt: (+1)
   \        0x0   0x6B80             LDR      R0,[R0, #+56]
   5759          
   5760            htim->State = HAL_TIM_STATE_READY;
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0xF880 0x103D      STRB     R1,[R0, #+61]
   5761          
   5762          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5763            htim->PeriodElapsedHalfCpltCallback(htim);
   5764          #else
   5765            HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
   \        0x8   0x....'....        B.W      HAL_TIM_PeriodElapsedHalfCpltCallback
   5766          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5767          }
   5768          
   5769          /**
   5770            * @brief  TIM DMA Trigger callback.
   5771            * @param  hdma pointer to DMA handle.
   5772            * @retval None
   5773            */

   \                                 In section .text, align 4, keep-with-next
   5774          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   5775          {
   5776            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \                     TIM_DMATriggerCplt: (+1)
   \        0x0   0x6B80             LDR      R0,[R0, #+56]
   5777          
   5778            htim->State = HAL_TIM_STATE_READY;
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0xF880 0x103D      STRB     R1,[R0, #+61]
   5779          
   5780          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5781            htim->TriggerCallback(htim);
   5782          #else
   5783            HAL_TIM_TriggerCallback(htim);
   \        0x8   0x....'....        B.W      HAL_TIM_TriggerCallback
   5784          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5785          }
   5786          
   5787          /**
   5788            * @brief  TIM DMA Trigger half complete callback.
   5789            * @param  hdma pointer to DMA handle.
   5790            * @retval None
   5791            */

   \                                 In section .text, align 4, keep-with-next
   5792          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)
   5793          {
   5794            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \                     TIM_DMATriggerHalfCplt: (+1)
   \        0x0   0x6B80             LDR      R0,[R0, #+56]
   5795          
   5796            htim->State = HAL_TIM_STATE_READY;
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0xF880 0x103D      STRB     R1,[R0, #+61]
   5797          
   5798          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5799            htim->TriggerHalfCpltCallback(htim);
   5800          #else
   5801            HAL_TIM_TriggerHalfCpltCallback(htim);
   \        0x8   0x....'....        B.W      HAL_TIM_TriggerHalfCpltCallback
   5802          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5803          }
   5804          
   5805          /**
   5806            * @brief  Time Base configuration
   5807            * @param  TIMx TIM peripheral
   5808            * @param  Structure TIM Base configuration structure
   5809            * @retval None
   5810            */

   \                                 In section .text, align 2, keep-with-next
   5811          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   5812          {
   \                     TIM_Base_SetConfig: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   5813            uint32_t tmpcr1;
   5814            tmpcr1 = TIMx->CR1;
   5815          
   5816            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   5817            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   \        0x2   0x....             LDR.N    R4,??DataTable31_3  ;; 0x40010000
   \        0x4   0x6805             LDR      R5,[R0, #+0]
   \        0x6   0x....             LDR.N    R3,??DataTable31_4  ;; 0x40010400
   \        0x8   0x....             LDR.N    R6,??DataTable31_5  ;; 0x40000c00
   \        0xA   0x....             LDR.N    R7,??DataTable31_6  ;; 0x40000800
   \        0xC   0x....'....        LDR.W    R12,??DataTable31_7  ;; 0x40000400
   \       0x10   0x42A0             CMP      R0,R4
   \       0x12   0xBF18             IT       NE
   \       0x14   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \       0x18   0xD007             BEQ.N    ??TIM_Base_SetConfig_0
   \       0x1A   0x4560             CMP      R0,R12
   \       0x1C   0xBF18             IT       NE
   \       0x1E   0x42B8             CMPNE    R0,R7
   \       0x20   0xD003             BEQ.N    ??TIM_Base_SetConfig_0
   \       0x22   0x42B0             CMP      R0,R6
   \       0x24   0xBF18             IT       NE
   \       0x26   0x4298             CMPNE    R0,R3
   \       0x28   0xD10D             BNE.N    ??TIM_Base_SetConfig_1
   5818            {
   5819              /* Select the Counter Mode */
   5820              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   5821              tmpcr1 |= Structure->CounterMode;
   \                     ??TIM_Base_SetConfig_0: (+1)
   \       0x2A   0x684A             LDR      R2,[R1, #+4]
   \       0x2C   0xF025 0x0570      BIC      R5,R5,#0x70
   \       0x30   0x4315             ORRS     R5,R2,R5
   5822            }
   5823          
   5824            if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   \       0x32   0x42A0             CMP      R0,R4
   \       0x34   0xBF18             IT       NE
   \       0x36   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \       0x3A   0xD017             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x3C   0x4560             CMP      R0,R12
   \       0x3E   0xBF1C             ITT      NE
   \       0x40   0x42B8             CMPNE    R0,R7
   \       0x42   0x42B0             CMPNE    R0,R6
   \       0x44   0xD012             BEQ.N    ??TIM_Base_SetConfig_2
   \                     ??TIM_Base_SetConfig_1: (+1)
   \       0x46   0x4298             CMP      R0,R3
   \       0x48   0xBF1C             ITT      NE
   \       0x4A   0x....             LDRNE.N  R2,??DataTable31_8  ;; 0x40014000
   \       0x4C   0x4290             CMPNE    R0,R2
   \       0x4E   0xD00D             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x50   0x....             LDR.N    R6,??DataTable31_9  ;; 0x40014400
   \       0x52   0x42B0             CMP      R0,R6
   \       0x54   0xBF1C             ITT      NE
   \       0x56   0x....             LDRNE.N  R2,??DataTable31_10  ;; 0x40014800
   \       0x58   0x4290             CMPNE    R0,R2
   \       0x5A   0xD007             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x5C   0x....             LDR.N    R6,??DataTable31_11  ;; 0x40001800
   \       0x5E   0x42B0             CMP      R0,R6
   \       0x60   0xBF1F             ITTTT    NE
   \       0x62   0x....             LDRNE.N  R2,??DataTable31_12  ;; 0x40001c00
   \       0x64   0x4290             CMPNE    R0,R2
   \       0x66   0x....             LDRNE.N  R6,??DataTable31_13  ;; 0x40002000
   \       0x68   0x42B0             CMPNE    R0,R6
   \       0x6A   0xD103             BNE.N    ??TIM_Base_SetConfig_3
   5825            {
   5826              /* Set the clock division */
   5827              tmpcr1 &= ~TIM_CR1_CKD;
   5828              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \                     ??TIM_Base_SetConfig_2: (+1)
   \       0x6C   0x68CA             LDR      R2,[R1, #+12]
   \       0x6E   0xF425 0x7540      BIC      R5,R5,#0x300
   \       0x72   0x4315             ORRS     R5,R2,R5
   5829            }
   5830          
   5831            /* Set the auto-reload preload */
   5832            MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   5833          
   5834            TIMx->CR1 = tmpcr1;
   \                     ??TIM_Base_SetConfig_3: (+1)
   \       0x74   0x694A             LDR      R2,[R1, #+20]
   \       0x76   0xF025 0x0580      BIC      R5,R5,#0x80
   \       0x7A   0x4315             ORRS     R5,R2,R5
   \       0x7C   0x6005             STR      R5,[R0, #+0]
   5835          
   5836            /* Set the Autoreload value */
   5837            TIMx->ARR = (uint32_t)Structure->Period ;
   5838          
   5839            /* Set the Prescaler value */
   5840            TIMx->PSC = Structure->Prescaler;
   5841          
   5842            if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   \       0x7E   0x42A0             CMP      R0,R4
   \       0x80   0x688D             LDR      R5,[R1, #+8]
   \       0x82   0x62C5             STR      R5,[R0, #+44]
   \       0x84   0x680A             LDR      R2,[R1, #+0]
   \       0x86   0x6282             STR      R2,[R0, #+40]
   \       0x88   0xBF12             ITEE     NE
   \       0x8A   0x4298             CMPNE    R0,R3
   \       0x8C   0x6909             LDREQ    R1,[R1, #+16]
   \       0x8E   0x6301             STREQ    R1,[R0, #+48]
   5843            {
   5844              /* Set the Repetition Counter value */
   5845              TIMx->RCR = Structure->RepetitionCounter;
   5846            }
   5847          
   5848            /* Generate an update event to reload the Prescaler
   5849               and the repetition counter (only for advanced timer) value immediately */
   5850            TIMx->EGR = TIM_EGR_UG;
   \       0x90   0x2201             MOVS     R2,#+1
   \       0x92   0x6142             STR      R2,[R0, #+20]
   5851          }
   \       0x94   0xBDF0             POP      {R4-R7,PC}       ;; return
   5852          
   5853          /**
   5854            * @brief  Timer Output Compare 1 configuration
   5855            * @param  TIMx to select the TIM peripheral
   5856            * @param  OC_Config The ouput configuration structure
   5857            * @retval None
   5858            */

   \                                 In section .text, align 2, keep-with-next
   5859          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   5860          {
   \                     TIM_OC1_SetConfig: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   5861            uint32_t tmpccmrx;
   5862            uint32_t tmpccer;
   5863            uint32_t tmpcr2;
   5864          
   5865            /* Disable the Channel 1: Reset the CC1E Bit */
   5866            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   5867          
   5868            /* Get the TIMx CCER register value */
   5869            tmpccer = TIMx->CCER;
   5870            /* Get the TIMx CR2 register value */
   5871            tmpcr2 =  TIMx->CR2;
   5872          
   5873            /* Get the TIMx CCMR1 register value */
   5874            tmpccmrx = TIMx->CCMR1;
   5875          
   5876            /* Reset the Output Compare Mode Bits */
   5877            tmpccmrx &= ~TIM_CCMR1_OC1M;
   5878            tmpccmrx &= ~TIM_CCMR1_CC1S;
   5879            /* Select the Output Compare Mode */
   5880            tmpccmrx |= OC_Config->OCMode;
   5881          
   5882            /* Reset the Output Polarity level */
   5883            tmpccer &= ~TIM_CCER_CC1P;
   5884            /* Set the Output Compare Polarity */
   5885            tmpccer |= OC_Config->OCPolarity;
   5886          
   5887            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   \        0x4   0x....             LDR.N    R7,??DataTable31_3  ;; 0x40010000
   \        0x6   0x0852             LSRS     R2,R2,#+1
   \        0x8   0x0052             LSLS     R2,R2,#+1
   \        0xA   0x6202             STR      R2,[R0, #+32]
   \        0xC   0x6A06             LDR      R6,[R0, #+32]
   \        0xE   0x6844             LDR      R4,[R0, #+4]
   \       0x10   0x6985             LDR      R5,[R0, #+24]
   \       0x12   0x680B             LDR      R3,[R1, #+0]
   \       0x14   0x688A             LDR      R2,[R1, #+8]
   \       0x16   0xF025 0x0573      BIC      R5,R5,#0x73
   \       0x1A   0xF026 0x0602      BIC      R6,R6,#0x2
   \       0x1E   0x431D             ORRS     R5,R3,R5
   \       0x20   0x4316             ORRS     R6,R2,R6
   \       0x22   0x....             LDR.N    R3,??DataTable31_4  ;; 0x40010400
   \       0x24   0x42B8             CMP      R0,R7
   \       0x26   0xBF18             IT       NE
   \       0x28   0x4298             CMPNE    R0,R3
   \       0x2A   0xD107             BNE.N    ??TIM_OC1_SetConfig_0
   5888            {
   5889              /* Check parameters */
   5890              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   5891          
   5892              /* Reset the Output N Polarity level */
   5893              tmpccer &= ~TIM_CCER_CC1NP;
   5894              /* Set the Output N Polarity */
   5895              tmpccer |= OC_Config->OCNPolarity;
   5896              /* Reset the Output N State */
   5897              tmpccer &= ~TIM_CCER_CC1NE;
   \       0x2C   0x68CA             LDR      R2,[R1, #+12]
   \       0x2E   0xF026 0x0608      BIC      R6,R6,#0x8
   \       0x32   0x4316             ORRS     R6,R2,R6
   5898            }
   5899          
   5900            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x34   0x42B8             CMP      R0,R7
   \       0x36   0xF026 0x0604      BIC      R6,R6,#0x4
   \       0x3A   0xD001             BEQ.N    ??TIM_OC1_SetConfig_1
   \                     ??TIM_OC1_SetConfig_0: (+1)
   \       0x3C   0x4298             CMP      R0,R3
   \       0x3E   0xD105             BNE.N    ??TIM_OC1_SetConfig_2
   5901            {
   5902              /* Check parameters */
   5903              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   5904              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   5905          
   5906              /* Reset the Output Compare and Output Compare N IDLE State */
   5907              tmpcr2 &= ~TIM_CR2_OIS1;
   5908              tmpcr2 &= ~TIM_CR2_OIS1N;
   5909              /* Set the Output Idle state */
   5910              tmpcr2 |= OC_Config->OCIdleState;
   5911              /* Set the Output N Idle state */
   5912              tmpcr2 |= OC_Config->OCNIdleState;
   \                     ??TIM_OC1_SetConfig_1: (+1)
   \       0x40   0x694B             LDR      R3,[R1, #+20]
   \       0x42   0x698A             LDR      R2,[R1, #+24]
   \       0x44   0xF424 0x7440      BIC      R4,R4,#0x300
   \       0x48   0x431C             ORRS     R4,R3,R4
   \       0x4A   0x4314             ORRS     R4,R2,R4
   5913            }
   5914          
   5915            /* Write to TIMx CR2 */
   5916            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1_SetConfig_2: (+1)
   \       0x4C   0x6044             STR      R4,[R0, #+4]
   5917          
   5918            /* Write to TIMx CCMR1 */
   5919            TIMx->CCMR1 = tmpccmrx;
   \       0x4E   0x6185             STR      R5,[R0, #+24]
   5920          
   5921            /* Set the Capture Compare Register value */
   5922            TIMx->CCR1 = OC_Config->Pulse;
   \       0x50   0x6849             LDR      R1,[R1, #+4]
   \       0x52   0x6341             STR      R1,[R0, #+52]
   5923          
   5924            /* Write to TIMx CCER */
   5925            TIMx->CCER = tmpccer;
   \       0x54   0x6206             STR      R6,[R0, #+32]
   5926          }
   \       0x56   0xBDF0             POP      {R4-R7,PC}       ;; return
   5927          
   5928          /**
   5929            * @brief  Timer Output Compare 2 configuration
   5930            * @param  TIMx to select the TIM peripheral
   5931            * @param  OC_Config The ouput configuration structure
   5932            * @retval None
   5933            */

   \                                 In section .text, align 2, keep-with-next
   5934          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   5935          {
   \                     TIM_OC2_SetConfig: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   5936            uint32_t tmpccmrx;
   5937            uint32_t tmpccer;
   5938            uint32_t tmpcr2;
   5939          
   5940            /* Disable the Channel 2: Reset the CC2E Bit */
   5941            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   5942          
   5943            /* Get the TIMx CCER register value */
   5944            tmpccer = TIMx->CCER;
   5945            /* Get the TIMx CR2 register value */
   5946            tmpcr2 =  TIMx->CR2;
   5947          
   5948            /* Get the TIMx CCMR1 register value */
   5949            tmpccmrx = TIMx->CCMR1;
   5950          
   5951            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   5952            tmpccmrx &= ~TIM_CCMR1_OC2M;
   5953            tmpccmrx &= ~TIM_CCMR1_CC2S;
   5954          
   5955            /* Select the Output Compare Mode */
   5956            tmpccmrx |= (OC_Config->OCMode << 8U);
   5957          
   5958            /* Reset the Output Polarity level */
   5959            tmpccer &= ~TIM_CCER_CC2P;
   5960            /* Set the Output Compare Polarity */
   5961            tmpccer |= (OC_Config->OCPolarity << 4U);
   5962          
   5963            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   \        0x4   0x....             LDR.N    R6,??DataTable31_3  ;; 0x40010000
   \        0x6   0xF022 0x0210      BIC      R2,R2,#0x10
   \        0xA   0x6202             STR      R2,[R0, #+32]
   \        0xC   0x42B0             CMP      R0,R6
   \        0xE   0x6A05             LDR      R5,[R0, #+32]
   \       0x10   0x6843             LDR      R3,[R0, #+4]
   \       0x12   0x6984             LDR      R4,[R0, #+24]
   \       0x14   0x680A             LDR      R2,[R1, #+0]
   \       0x16   0xF424 0x44E6      BIC      R4,R4,#0x7300
   \       0x1A   0xEA44 0x2402      ORR      R4,R4,R2, LSL #+8
   \       0x1E   0x688A             LDR      R2,[R1, #+8]
   \       0x20   0xF025 0x0520      BIC      R5,R5,#0x20
   \       0x24   0xEA45 0x1502      ORR      R5,R5,R2, LSL #+4
   \       0x28   0x....             LDR.N    R2,??DataTable31_4  ;; 0x40010400
   \       0x2A   0xBF18             IT       NE
   \       0x2C   0x4290             CMPNE    R0,R2
   \       0x2E   0xD108             BNE.N    ??TIM_OC2_SetConfig_0
   5964            {
   5965              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   5966          
   5967              /* Reset the Output N Polarity level */
   5968              tmpccer &= ~TIM_CCER_CC2NP;
   5969              /* Set the Output N Polarity */
   5970              tmpccer |= (OC_Config->OCNPolarity << 4U);
   5971              /* Reset the Output N State */
   5972              tmpccer &= ~TIM_CCER_CC2NE;
   \       0x30   0x68CF             LDR      R7,[R1, #+12]
   \       0x32   0xF025 0x0580      BIC      R5,R5,#0x80
   \       0x36   0xEA45 0x1507      ORR      R5,R5,R7, LSL #+4
   5973          
   5974            }
   5975          
   5976            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x3A   0x42B0             CMP      R0,R6
   \       0x3C   0xF025 0x0540      BIC      R5,R5,#0x40
   \       0x40   0xD001             BEQ.N    ??TIM_OC2_SetConfig_1
   \                     ??TIM_OC2_SetConfig_0: (+1)
   \       0x42   0x4290             CMP      R0,R2
   \       0x44   0xD106             BNE.N    ??TIM_OC2_SetConfig_2
   5977            {
   5978              /* Check parameters */
   5979              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   5980              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   5981          
   5982              /* Reset the Output Compare and Output Compare N IDLE State */
   5983              tmpcr2 &= ~TIM_CR2_OIS2;
   5984              tmpcr2 &= ~TIM_CR2_OIS2N;
   5985              /* Set the Output Idle state */
   5986              tmpcr2 |= (OC_Config->OCIdleState << 2U);
   5987              /* Set the Output N Idle state */
   5988              tmpcr2 |= (OC_Config->OCNIdleState << 2U);
   \                     ??TIM_OC2_SetConfig_1: (+1)
   \       0x46   0x694E             LDR      R6,[R1, #+20]
   \       0x48   0x698A             LDR      R2,[R1, #+24]
   \       0x4A   0xF423 0x6340      BIC      R3,R3,#0xC00
   \       0x4E   0x4316             ORRS     R6,R2,R6
   \       0x50   0xEA43 0x0386      ORR      R3,R3,R6, LSL #+2
   5989            }
   5990          
   5991            /* Write to TIMx CR2 */
   5992            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2_SetConfig_2: (+1)
   \       0x54   0x6043             STR      R3,[R0, #+4]
   5993          
   5994            /* Write to TIMx CCMR1 */
   5995            TIMx->CCMR1 = tmpccmrx;
   \       0x56   0x6184             STR      R4,[R0, #+24]
   5996          
   5997            /* Set the Capture Compare Register value */
   5998            TIMx->CCR2 = OC_Config->Pulse;
   \       0x58   0x6849             LDR      R1,[R1, #+4]
   \       0x5A   0x6381             STR      R1,[R0, #+56]
   5999          
   6000            /* Write to TIMx CCER */
   6001            TIMx->CCER = tmpccer;
   \       0x5C   0x6205             STR      R5,[R0, #+32]
   6002          }
   \       0x5E   0xBDF0             POP      {R4-R7,PC}       ;; return
   6003          
   6004          /**
   6005            * @brief  Timer Output Compare 3 configuration
   6006            * @param  TIMx to select the TIM peripheral
   6007            * @param  OC_Config The ouput configuration structure
   6008            * @retval None
   6009            */

   \                                 In section .text, align 2, keep-with-next
   6010          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6011          {
   \                     TIM_OC3_SetConfig: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   6012            uint32_t tmpccmrx;
   6013            uint32_t tmpccer;
   6014            uint32_t tmpcr2;
   6015          
   6016            /* Disable the Channel 3: Reset the CC2E Bit */
   6017            TIMx->CCER &= ~TIM_CCER_CC3E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0xF422 0x7280      BIC      R2,R2,#0x100
   \        0x8   0x6202             STR      R2,[R0, #+32]
   6018          
   6019            /* Get the TIMx CCER register value */
   6020            tmpccer = TIMx->CCER;
   \        0xA   0x6A05             LDR      R5,[R0, #+32]
   6021            /* Get the TIMx CR2 register value */
   6022            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6843             LDR      R3,[R0, #+4]
   6023          
   6024            /* Get the TIMx CCMR2 register value */
   6025            tmpccmrx = TIMx->CCMR2;
   6026          
   6027            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6028            tmpccmrx &= ~TIM_CCMR2_OC3M;
   6029            tmpccmrx &= ~TIM_CCMR2_CC3S;
   6030            /* Select the Output Compare Mode */
   6031            tmpccmrx |= OC_Config->OCMode;
   \        0xE   0x69C4             LDR      R4,[R0, #+28]
   6032          
   6033            /* Reset the Output Polarity level */
   6034            tmpccer &= ~TIM_CCER_CC3P;
   6035            /* Set the Output Compare Polarity */
   6036            tmpccer |= (OC_Config->OCPolarity << 8U);
   \       0x10   0x688E             LDR      R6,[R1, #+8]
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0xF425 0x7500      BIC      R5,R5,#0x200
   \       0x18   0xF024 0x0473      BIC      R4,R4,#0x73
   \       0x1C   0xEA45 0x2506      ORR      R5,R5,R6, LSL #+8
   \       0x20   0x4314             ORRS     R4,R2,R4
   6037          
   6038            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   \       0x22   0x....             LDR.N    R6,??DataTable31_3  ;; 0x40010000
   \       0x24   0x....             LDR.N    R2,??DataTable31_4  ;; 0x40010400
   \       0x26   0x42B0             CMP      R0,R6
   \       0x28   0xBF18             IT       NE
   \       0x2A   0x4290             CMPNE    R0,R2
   \       0x2C   0xD108             BNE.N    ??TIM_OC3_SetConfig_0
   6039            {
   6040              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   6041          
   6042              /* Reset the Output N Polarity level */
   6043              tmpccer &= ~TIM_CCER_CC3NP;
   6044              /* Set the Output N Polarity */
   6045              tmpccer |= (OC_Config->OCNPolarity << 8U);
   6046              /* Reset the Output N State */
   6047              tmpccer &= ~TIM_CCER_CC3NE;
   \       0x2E   0x68CF             LDR      R7,[R1, #+12]
   \       0x30   0xF425 0x6500      BIC      R5,R5,#0x800
   \       0x34   0xEA45 0x2507      ORR      R5,R5,R7, LSL #+8
   6048            }
   6049          
   6050            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x38   0x42B0             CMP      R0,R6
   \       0x3A   0xF425 0x6580      BIC      R5,R5,#0x400
   \       0x3E   0xD001             BEQ.N    ??TIM_OC3_SetConfig_1
   \                     ??TIM_OC3_SetConfig_0: (+1)
   \       0x40   0x4290             CMP      R0,R2
   \       0x42   0xD106             BNE.N    ??TIM_OC3_SetConfig_2
   6051            {
   6052              /* Check parameters */
   6053              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   6054              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6055          
   6056              /* Reset the Output Compare and Output Compare N IDLE State */
   6057              tmpcr2 &= ~TIM_CR2_OIS3;
   6058              tmpcr2 &= ~TIM_CR2_OIS3N;
   6059              /* Set the Output Idle state */
   6060              tmpcr2 |= (OC_Config->OCIdleState << 4U);
   6061              /* Set the Output N Idle state */
   6062              tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   \                     ??TIM_OC3_SetConfig_1: (+1)
   \       0x44   0x694E             LDR      R6,[R1, #+20]
   \       0x46   0x698A             LDR      R2,[R1, #+24]
   \       0x48   0xF423 0x5340      BIC      R3,R3,#0x3000
   \       0x4C   0x4316             ORRS     R6,R2,R6
   \       0x4E   0xEA43 0x1306      ORR      R3,R3,R6, LSL #+4
   6063            }
   6064          
   6065            /* Write to TIMx CR2 */
   6066            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3_SetConfig_2: (+1)
   \       0x52   0x6043             STR      R3,[R0, #+4]
   6067          
   6068            /* Write to TIMx CCMR2 */
   6069            TIMx->CCMR2 = tmpccmrx;
   \       0x54   0x61C4             STR      R4,[R0, #+28]
   6070          
   6071            /* Set the Capture Compare Register value */
   6072            TIMx->CCR3 = OC_Config->Pulse;
   \       0x56   0x6849             LDR      R1,[R1, #+4]
   \       0x58   0x63C1             STR      R1,[R0, #+60]
   6073          
   6074            /* Write to TIMx CCER */
   6075            TIMx->CCER = tmpccer;
   \       0x5A   0x6205             STR      R5,[R0, #+32]
   6076          }
   \       0x5C   0xBDF0             POP      {R4-R7,PC}       ;; return
   6077          
   6078          /**
   6079            * @brief  Timer Output Compare 4 configuration
   6080            * @param  TIMx to select the TIM peripheral
   6081            * @param  OC_Config The ouput configuration structure
   6082            * @retval None
   6083            */

   \                                 In section .text, align 2, keep-with-next
   6084          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6085          {
   \                     TIM_OC4_SetConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   6086            uint32_t tmpccmrx;
   6087            uint32_t tmpccer;
   6088            uint32_t tmpcr2;
   6089          
   6090            /* Disable the Channel 4: Reset the CC4E Bit */
   6091            TIMx->CCER &= ~TIM_CCER_CC4E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   6092          
   6093            /* Get the TIMx CCER register value */
   6094            tmpccer = TIMx->CCER;
   6095            /* Get the TIMx CR2 register value */
   6096            tmpcr2 =  TIMx->CR2;
   6097          
   6098            /* Get the TIMx CCMR2 register value */
   6099            tmpccmrx = TIMx->CCMR2;
   6100          
   6101            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6102            tmpccmrx &= ~TIM_CCMR2_OC4M;
   6103            tmpccmrx &= ~TIM_CCMR2_CC4S;
   6104          
   6105            /* Select the Output Compare Mode */
   6106            tmpccmrx |= (OC_Config->OCMode << 8U);
   6107          
   6108            /* Reset the Output Polarity level */
   6109            tmpccer &= ~TIM_CCER_CC4P;
   6110            /* Set the Output Compare Polarity */
   6111            tmpccer |= (OC_Config->OCPolarity << 12U);
   6112          
   6113            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \        0x4   0x....             LDR.N    R6,??DataTable31_3  ;; 0x40010000
   \        0x6   0xF422 0x5280      BIC      R2,R2,#0x1000
   \        0xA   0x6202             STR      R2,[R0, #+32]
   \        0xC   0x42B0             CMP      R0,R6
   \        0xE   0x6A04             LDR      R4,[R0, #+32]
   \       0x10   0x6842             LDR      R2,[R0, #+4]
   \       0x12   0x69C3             LDR      R3,[R0, #+28]
   \       0x14   0x680D             LDR      R5,[R1, #+0]
   \       0x16   0xF423 0x43E6      BIC      R3,R3,#0x7300
   \       0x1A   0xEA43 0x2305      ORR      R3,R3,R5, LSL #+8
   \       0x1E   0x688D             LDR      R5,[R1, #+8]
   \       0x20   0xF424 0x5400      BIC      R4,R4,#0x2000
   \       0x24   0xEA44 0x3405      ORR      R4,R4,R5, LSL #+12
   \       0x28   0xBF1C             ITT      NE
   \       0x2A   0x....             LDRNE.N  R5,??DataTable31_4  ;; 0x40010400
   \       0x2C   0x42A8             CMPNE    R0,R5
   \       0x2E   0xD104             BNE.N    ??TIM_OC4_SetConfig_0
   6114            {
   6115              /* Check parameters */
   6116              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6117          
   6118              /* Reset the Output Compare IDLE State */
   6119              tmpcr2 &= ~TIM_CR2_OIS4;
   6120          
   6121              /* Set the Output Idle state */
   6122              tmpcr2 |= (OC_Config->OCIdleState << 6U);
   \       0x30   0x694D             LDR      R5,[R1, #+20]
   \       0x32   0xF422 0x4280      BIC      R2,R2,#0x4000
   \       0x36   0xEA42 0x1285      ORR      R2,R2,R5, LSL #+6
   6123            }
   6124          
   6125            /* Write to TIMx CR2 */
   6126            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4_SetConfig_0: (+1)
   \       0x3A   0x6042             STR      R2,[R0, #+4]
   6127          
   6128            /* Write to TIMx CCMR2 */
   6129            TIMx->CCMR2 = tmpccmrx;
   \       0x3C   0x61C3             STR      R3,[R0, #+28]
   6130          
   6131            /* Set the Capture Compare Register value */
   6132            TIMx->CCR4 = OC_Config->Pulse;
   \       0x3E   0x6849             LDR      R1,[R1, #+4]
   \       0x40   0x6401             STR      R1,[R0, #+64]
   6133          
   6134            /* Write to TIMx CCER */
   6135            TIMx->CCER = tmpccer;
   \       0x42   0x6204             STR      R4,[R0, #+32]
   6136          }
   \       0x44   0xBD70             POP      {R4-R6,PC}       ;; return
   6137          
   6138          /**
   6139            * @brief  Slave Timer configuration function
   6140            * @param  htim TIM handle
   6141            * @param  sSlaveConfig Slave timer configuration
   6142            * @retval None
   6143            */

   \                                 In section .text, align 2, keep-with-next
   6144          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   6145                                                            TIM_SlaveConfigTypeDef *sSlaveConfig)
   6146          {
   \                     TIM_SlaveTimer_SetConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   6147            uint32_t tmpsmcr;
   6148            uint32_t tmpccmr1;
   6149            uint32_t tmpccer;
   6150          
   6151            /* Get the TIMx SMCR register value */
   6152            tmpsmcr = htim->Instance->SMCR;
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x6884             LDR      R4,[R0, #+8]
   6153          
   6154            /* Reset the Trigger Selection Bits */
   6155            tmpsmcr &= ~TIM_SMCR_TS;
   6156            /* Set the Input Trigger source */
   6157            tmpsmcr |= sSlaveConfig->InputTrigger;
   6158          
   6159            /* Reset the slave mode Bits */
   6160            tmpsmcr &= ~TIM_SMCR_SMS;
   6161            /* Set the slave mode */
   6162            tmpsmcr |= sSlaveConfig->SlaveMode;
   6163          
   6164            /* Write to TIMx SMCR */
   6165            htim->Instance->SMCR = tmpsmcr;
   \        0x6   0x684B             LDR      R3,[R1, #+4]
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0xF024 0x0470      BIC      R4,R4,#0x70
   \        0xE   0x431C             ORRS     R4,R3,R4
   \       0x10   0x08E4             LSRS     R4,R4,#+3
   \       0x12   0xEA42 0x04C4      ORR      R4,R2,R4, LSL #+3
   \       0x16   0x6084             STR      R4,[R0, #+8]
   6166          
   6167            /* Configure the trigger prescaler, filter, and polarity */
   6168            switch (sSlaveConfig->InputTrigger)
   \       0x18   0x684C             LDR      R4,[R1, #+4]
   \       0x1A   0x2C40             CMP      R4,#+64
   \       0x1C   0xD00B             BEQ.N    ??TIM_SlaveTimer_SetConfig_0
   \       0x1E   0x2C50             CMP      R4,#+80
   \       0x20   0xD01C             BEQ.N    ??TIM_SlaveTimer_SetConfig_1
   \       0x22   0x2C60             CMP      R4,#+96
   \       0x24   0xD01F             BEQ.N    ??TIM_SlaveTimer_SetConfig_2
   \       0x26   0x2C70             CMP      R4,#+112
   \       0x28   0xD121             BNE.N    ??TIM_SlaveTimer_SetConfig_3
   6169            {
   6170              case TIM_TS_ETRF:
   6171              {
   6172                /* Check the parameters */
   6173                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   6174                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   6175                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6176                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6177                /* Configure the ETR Trigger source */
   6178                TIM_ETR_SetConfig(htim->Instance,
   6179                                  sSlaveConfig->TriggerPrescaler,
   6180                                  sSlaveConfig->TriggerPolarity,
   6181                                  sSlaveConfig->TriggerFilter);
   \       0x2A   0x690B             LDR      R3,[R1, #+16]
   \       0x2C   0x688A             LDR      R2,[R1, #+8]
   \       0x2E   0x68C9             LDR      R1,[R1, #+12]
   \       0x30   0x....'....        BL       TIM_ETR_SetConfig
   6182                break;
   \       0x34   0xE01B             B.N      ??TIM_SlaveTimer_SetConfig_3
   6183              }
   6184          
   6185              case TIM_TS_TI1F_ED:
   6186              {
   6187                /* Check the parameters */
   6188                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   6189                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6190          
   6191                if(sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
   \                     ??TIM_SlaveTimer_SetConfig_0: (+1)
   \       0x36   0x680A             LDR      R2,[R1, #+0]
   \       0x38   0x2A05             CMP      R2,#+5
   \       0x3A   0xD101             BNE.N    ??TIM_SlaveTimer_SetConfig_4
   6192                {
   6193                  return HAL_ERROR;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xBD10             POP      {R4,PC}
   6194                }
   6195          
   6196                /* Disable the Channel 1: Reset the CC1E Bit */
   6197                tmpccer = htim->Instance->CCER;
   \                     ??TIM_SlaveTimer_SetConfig_4: (+1)
   \       0x40   0x6A02             LDR      R2,[R0, #+32]
   6198                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \       0x42   0x6A03             LDR      R3,[R0, #+32]
   \       0x44   0x085B             LSRS     R3,R3,#+1
   \       0x46   0x005B             LSLS     R3,R3,#+1
   \       0x48   0x6203             STR      R3,[R0, #+32]
   6199                tmpccmr1 = htim->Instance->CCMR1;
   \       0x4A   0x6983             LDR      R3,[R0, #+24]
   6200          
   6201                /* Set the filter */
   6202                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   6203                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
   6204          
   6205                /* Write to TIMx CCMR1 and CCER registers */
   6206                htim->Instance->CCMR1 = tmpccmr1;
   \       0x4C   0x6909             LDR      R1,[R1, #+16]
   \       0x4E   0xF023 0x03F0      BIC      R3,R3,#0xF0
   \       0x52   0xEA43 0x1301      ORR      R3,R3,R1, LSL #+4
   \       0x56   0x6183             STR      R3,[R0, #+24]
   6207                htim->Instance->CCER = tmpccer;
   \       0x58   0x6202             STR      R2,[R0, #+32]
   6208                break;
   \       0x5A   0xE008             B.N      ??TIM_SlaveTimer_SetConfig_3
   6209              }
   6210          
   6211              case TIM_TS_TI1FP1:
   6212              {
   6213                /* Check the parameters */
   6214                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   6215                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6216                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6217          
   6218                /* Configure TI1 Filter and Polarity */
   6219                TIM_TI1_ConfigInputStage(htim->Instance,
   6220                                         sSlaveConfig->TriggerPolarity,
   6221                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_1: (+1)
   \       0x5C   0x690A             LDR      R2,[R1, #+16]
   \       0x5E   0x6889             LDR      R1,[R1, #+8]
   \       0x60   0x....'....        BL       TIM_TI1_ConfigInputStage
   6222                break;
   \       0x64   0xE003             B.N      ??TIM_SlaveTimer_SetConfig_3
   6223              }
   6224          
   6225              case TIM_TS_TI2FP2:
   6226              {
   6227                /* Check the parameters */
   6228                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   6229                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6230                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6231          
   6232                /* Configure TI2 Filter and Polarity */
   6233                TIM_TI2_ConfigInputStage(htim->Instance,
   6234                                         sSlaveConfig->TriggerPolarity,
   6235                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_2: (+1)
   \       0x66   0x690A             LDR      R2,[R1, #+16]
   \       0x68   0x6889             LDR      R1,[R1, #+8]
   \       0x6A   0x....'....        BL       TIM_TI2_ConfigInputStage
   6236                break;
   6237              }
   6238          
   6239              case TIM_TS_ITR0:
   6240              case TIM_TS_ITR1:
   6241              case TIM_TS_ITR2:
   6242              case TIM_TS_ITR3:
   6243              {
   6244                /* Check the parameter */
   6245                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   6246                break;
   6247              }
   6248          
   6249              default:
   6250                break;
   6251            }
   6252            return HAL_OK;
   \                     ??TIM_SlaveTimer_SetConfig_3: (+1)
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xBD10             POP      {R4,PC}          ;; return
   6253          }
   6254          
   6255          /**
   6256            * @brief  Configure the TI1 as Input.
   6257            * @param  TIMx to select the TIM peripheral.
   6258            * @param  TIM_ICPolarity The Input Polarity.
   6259            *          This parameter can be one of the following values:
   6260            *            @arg TIM_ICPOLARITY_RISING
   6261            *            @arg TIM_ICPOLARITY_FALLING
   6262            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6263            * @param  TIM_ICSelection specifies the input to be used.
   6264            *          This parameter can be one of the following values:
   6265            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.
   6266            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.
   6267            *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.
   6268            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6269            *          This parameter must be a value between 0x00 and 0x0F.
   6270            * @retval None
   6271            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1
   6272            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be
   6273            *        protected against un-initialized filter and polarity values.
   6274            */

   \                                 In section .text, align 2, keep-with-next
   6275          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6276                                 uint32_t TIM_ICFilter)
   6277          {
   \                     TIM_TI1_SetConfig: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   6278            uint32_t tmpccmr1;
   6279            uint32_t tmpccer;
   6280          
   6281            /* Disable the Channel 1: Reset the CC1E Bit */
   6282            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   6283            tmpccmr1 = TIMx->CCMR1;
   6284            tmpccer = TIMx->CCER;
   6285          
   6286            /* Select the Input */
   6287            if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \        0x4   0x....             LDR.N    R6,??DataTable31_3  ;; 0x40010000
   \        0x6   0x0864             LSRS     R4,R4,#+1
   \        0x8   0x0064             LSLS     R4,R4,#+1
   \        0xA   0x6204             STR      R4,[R0, #+32]
   \        0xC   0x42B0             CMP      R0,R6
   \        0xE   0x6984             LDR      R4,[R0, #+24]
   \       0x10   0x6A05             LDR      R5,[R0, #+32]
   \       0x12   0xBF18             IT       NE
   \       0x14   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \       0x18   0xD011             BEQ.N    ??TIM_TI1_SetConfig_0
   \       0x1A   0x....             LDR.N    R6,??DataTable31_7  ;; 0x40000400
   \       0x1C   0x42B0             CMP      R0,R6
   \       0x1E   0xBF1C             ITT      NE
   \       0x20   0x....             LDRNE.N  R7,??DataTable31_6  ;; 0x40000800
   \       0x22   0x42B8             CMPNE    R0,R7
   \       0x24   0xD00B             BEQ.N    ??TIM_TI1_SetConfig_0
   \       0x26   0x....             LDR.N    R6,??DataTable31_5  ;; 0x40000c00
   \       0x28   0x42B0             CMP      R0,R6
   \       0x2A   0xBF1C             ITT      NE
   \       0x2C   0x....             LDRNE.N  R7,??DataTable31_4  ;; 0x40010400
   \       0x2E   0x42B8             CMPNE    R0,R7
   \       0x30   0xD005             BEQ.N    ??TIM_TI1_SetConfig_0
   \       0x32   0x....             LDR.N    R6,??DataTable31_8  ;; 0x40014000
   \       0x34   0x42B0             CMP      R0,R6
   \       0x36   0xBF1C             ITT      NE
   \       0x38   0x....             LDRNE.N  R7,??DataTable31_11  ;; 0x40001800
   \       0x3A   0x42B8             CMPNE    R0,R7
   \       0x3C   0xD103             BNE.N    ??TIM_TI1_SetConfig_1
   6288            {
   6289              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   6290              tmpccmr1 |= TIM_ICSelection;
   \                     ??TIM_TI1_SetConfig_0: (+1)
   \       0x3E   0x08A4             LSRS     R4,R4,#+2
   \       0x40   0xEA42 0x0284      ORR      R2,R2,R4, LSL #+2
   \       0x44   0xE001             B.N      ??TIM_TI1_SetConfig_2
   6291            }
   6292            else
   6293            {
   6294              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_1: (+1)
   \       0x46   0xF044 0x0201      ORR      R2,R4,#0x1
   6295            }
   6296          
   6297            /* Set the filter */
   6298            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   6299            tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
   6300          
   6301            /* Select the Polarity and set the CC1E Bit */
   6302            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   6303            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   6304          
   6305            /* Write to TIMx CCMR1 and CCER registers */
   6306            TIMx->CCMR1 = tmpccmr1;
   \                     ??TIM_TI1_SetConfig_2: (+1)
   \       0x4A   0xF363 0x1207      BFI      R2,R3,#+4,#+4
   6307            TIMx->CCER = tmpccer;
   \       0x4E   0xF025 0x050A      BIC      R5,R5,#0xA
   \       0x52   0xF001 0x010A      AND      R1,R1,#0xA
   \       0x56   0x6182             STR      R2,[R0, #+24]
   \       0x58   0x4329             ORRS     R1,R1,R5
   \       0x5A   0x6201             STR      R1,[R0, #+32]
   6308          }
   \       0x5C   0xBDF0             POP      {R4-R7,PC}       ;; return
   6309          
   6310          /**
   6311            * @brief  Configure the Polarity and Filter for TI1.
   6312            * @param  TIMx to select the TIM peripheral.
   6313            * @param  TIM_ICPolarity The Input Polarity.
   6314            *          This parameter can be one of the following values:
   6315            *            @arg TIM_ICPOLARITY_RISING
   6316            *            @arg TIM_ICPOLARITY_FALLING
   6317            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6318            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6319            *          This parameter must be a value between 0x00 and 0x0F.
   6320            * @retval None
   6321            */

   \                                 In section .text, align 2, keep-with-next
   6322          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   6323          {
   \                     TIM_TI1_ConfigInputStage: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   6324            uint32_t tmpccmr1;
   6325            uint32_t tmpccer;
   6326          
   6327            /* Disable the Channel 1: Reset the CC1E Bit */
   6328            tmpccer = TIMx->CCER;
   \        0x2   0x6A03             LDR      R3,[R0, #+32]
   6329            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x4   0x6A04             LDR      R4,[R0, #+32]
   \        0x6   0x0864             LSRS     R4,R4,#+1
   \        0x8   0x0064             LSLS     R4,R4,#+1
   \        0xA   0x6204             STR      R4,[R0, #+32]
   6330            tmpccmr1 = TIMx->CCMR1;
   6331          
   6332            /* Set the filter */
   6333            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   6334            tmpccmr1 |= (TIM_ICFilter << 4U);
   6335          
   6336            /* Select the Polarity and set the CC1E Bit */
   6337            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   6338            tmpccer |= TIM_ICPolarity;
   6339          
   6340            /* Write to TIMx CCMR1 and CCER registers */
   6341            TIMx->CCMR1 = tmpccmr1;
   6342            TIMx->CCER = tmpccer;
   \        0xC   0xF023 0x030A      BIC      R3,R3,#0xA
   \       0x10   0x6984             LDR      R4,[R0, #+24]
   \       0x12   0xF024 0x04F0      BIC      R4,R4,#0xF0
   \       0x16   0xEA44 0x1402      ORR      R4,R4,R2, LSL #+4
   \       0x1A   0x6184             STR      R4,[R0, #+24]
   \       0x1C   0x....             B.N      ?Subroutine12
   6343          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x4319             ORRS     R1,R1,R3
   \        0x2   0x6201             STR      R1,[R0, #+32]
   \        0x4   0xBD10             POP      {R4,PC}          ;; return
   6344          
   6345          /**
   6346            * @brief  Configure the TI2 as Input.
   6347            * @param  TIMx to select the TIM peripheral
   6348            * @param  TIM_ICPolarity The Input Polarity.
   6349            *          This parameter can be one of the following values:
   6350            *            @arg TIM_ICPOLARITY_RISING
   6351            *            @arg TIM_ICPOLARITY_FALLING
   6352            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6353            * @param  TIM_ICSelection specifies the input to be used.
   6354            *          This parameter can be one of the following values:
   6355            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.
   6356            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
   6357            *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.
   6358            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6359            *          This parameter must be a value between 0x00 and 0x0F.
   6360            * @retval None
   6361            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2
   6362            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
   6363            *        protected against un-initialized filter and polarity values.
   6364            */

   \                                 In section .text, align 2, keep-with-next
   6365          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6366                                        uint32_t TIM_ICFilter)
   6367          {
   \                     TIM_TI2_SetConfig: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   6368            uint32_t tmpccmr1;
   6369            uint32_t tmpccer;
   6370          
   6371            /* Disable the Channel 2: Reset the CC2E Bit */
   6372            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   \        0x4   0xF024 0x0410      BIC      R4,R4,#0x10
   \        0x8   0x6204             STR      R4,[R0, #+32]
   6373            tmpccmr1 = TIMx->CCMR1;
   6374            tmpccer = TIMx->CCER;
   6375          
   6376            /* Select the Input */
   6377            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   6378            tmpccmr1 |= (TIM_ICSelection << 8U);
   6379          
   6380            /* Set the filter */
   6381            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   6382            tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
   6383          
   6384            /* Select the Polarity and set the CC2E Bit */
   6385            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   6386            tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   6387          
   6388            /* Write to TIMx CCMR1 and CCER registers */
   6389            TIMx->CCMR1 = tmpccmr1 ;
   6390            TIMx->CCER = tmpccer;
   \        0xA   0x0109             LSLS     R1,R1,#+4
   \        0xC   0x6984             LDR      R4,[R0, #+24]
   \        0xE   0x6A05             LDR      R5,[R0, #+32]
   \       0x10   0xF424 0x7440      BIC      R4,R4,#0x300
   \       0x14   0xEA44 0x2402      ORR      R4,R4,R2, LSL #+8
   \       0x18   0xF363 0x340F      BFI      R4,R3,#+12,#+4
   \       0x1C   0xF025 0x05A0      BIC      R5,R5,#0xA0
   \       0x20   0xF001 0x01A0      AND      R1,R1,#0xA0
   \       0x24   0x6184             STR      R4,[R0, #+24]
   \       0x26   0x4329             ORRS     R1,R1,R5
   \       0x28   0x6201             STR      R1,[R0, #+32]
   6391          }
   \       0x2A   0xBD30             POP      {R4,R5,PC}       ;; return
   6392          
   6393          /**
   6394            * @brief  Configure the Polarity and Filter for TI2.
   6395            * @param  TIMx to select the TIM peripheral.
   6396            * @param  TIM_ICPolarity The Input Polarity.
   6397            *          This parameter can be one of the following values:
   6398            *            @arg TIM_ICPOLARITY_RISING
   6399            *            @arg TIM_ICPOLARITY_FALLING
   6400            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6401            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6402            *          This parameter must be a value between 0x00 and 0x0F.
   6403            * @retval None
   6404            */

   \                                 In section .text, align 2, keep-with-next
   6405          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   6406          {
   \                     TIM_TI2_ConfigInputStage: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   6407            uint32_t tmpccmr1;
   6408            uint32_t tmpccer;
   6409          
   6410            /* Disable the Channel 2: Reset the CC2E Bit */
   6411            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A03             LDR      R3,[R0, #+32]
   \        0x4   0xF023 0x0310      BIC      R3,R3,#0x10
   \        0x8   0x6203             STR      R3,[R0, #+32]
   6412            tmpccmr1 = TIMx->CCMR1;
   \        0xA   0x6983             LDR      R3,[R0, #+24]
   6413            tmpccer = TIMx->CCER;
   \        0xC   0x6A04             LDR      R4,[R0, #+32]
   6414          
   6415            /* Set the filter */
   6416            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   6417            tmpccmr1 |= (TIM_ICFilter << 12U);
   6418          
   6419            /* Select the Polarity and set the CC2E Bit */
   6420            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   6421            tmpccer |= (TIM_ICPolarity << 4U);
   6422          
   6423            /* Write to TIMx CCMR1 and CCER registers */
   6424            TIMx->CCMR1 = tmpccmr1 ;
   \        0xE   0xF423 0x4370      BIC      R3,R3,#0xF000
   \       0x12   0xEA43 0x3302      ORR      R3,R3,R2, LSL #+12
   6425            TIMx->CCER = tmpccer;
   \       0x16   0xF024 0x04A0      BIC      R4,R4,#0xA0
   \       0x1A   0x6183             STR      R3,[R0, #+24]
   \       0x1C   0xEA44 0x1401      ORR      R4,R4,R1, LSL #+4
   \       0x20   0x6204             STR      R4,[R0, #+32]
   6426          }
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
   6427          
   6428          /**
   6429            * @brief  Configure the TI3 as Input.
   6430            * @param  TIMx to select the TIM peripheral
   6431            * @param  TIM_ICPolarity The Input Polarity.
   6432            *          This parameter can be one of the following values:
   6433            *            @arg TIM_ICPOLARITY_RISING
   6434            *            @arg TIM_ICPOLARITY_FALLING
   6435            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6436            * @param  TIM_ICSelection specifies the input to be used.
   6437            *          This parameter can be one of the following values:
   6438            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.
   6439            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
   6440            *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.
   6441            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6442            *          This parameter must be a value between 0x00 and 0x0F.
   6443            * @retval None
   6444            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4
   6445            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6446            *        protected against un-initialized filter and polarity values.
   6447            */
   6448          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6449                                        uint32_t TIM_ICFilter)
   6450          {
   6451            uint32_t tmpccmr2;
   6452            uint32_t tmpccer;
   6453          
   6454            /* Disable the Channel 3: Reset the CC3E Bit */
   6455            TIMx->CCER &= ~TIM_CCER_CC3E;
   6456            tmpccmr2 = TIMx->CCMR2;
   6457            tmpccer = TIMx->CCER;
   6458          
   6459            /* Select the Input */
   6460            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   6461            tmpccmr2 |= TIM_ICSelection;
   6462          
   6463            /* Set the filter */
   6464            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   6465            tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
   6466          
   6467            /* Select the Polarity and set the CC3E Bit */
   6468            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   6469            tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   6470          
   6471            /* Write to TIMx CCMR2 and CCER registers */
   6472            TIMx->CCMR2 = tmpccmr2;
   6473            TIMx->CCER = tmpccer;
   6474          }
   6475          
   6476          /**
   6477            * @brief  Configure the TI4 as Input.
   6478            * @param  TIMx to select the TIM peripheral
   6479            * @param  TIM_ICPolarity The Input Polarity.
   6480            *          This parameter can be one of the following values:
   6481            *            @arg TIM_ICPOLARITY_RISING
   6482            *            @arg TIM_ICPOLARITY_FALLING
   6483            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6484            * @param  TIM_ICSelection specifies the input to be used.
   6485            *          This parameter can be one of the following values:
   6486            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.
   6487            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
   6488            *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.
   6489            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6490            *          This parameter must be a value between 0x00 and 0x0F.
   6491            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3
   6492            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6493            *        protected against un-initialized filter and polarity values.
   6494            * @retval None
   6495            */
   6496          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6497                                        uint32_t TIM_ICFilter)
   6498          {
   6499            uint32_t tmpccmr2;
   6500            uint32_t tmpccer;
   6501          
   6502            /* Disable the Channel 4: Reset the CC4E Bit */
   6503            TIMx->CCER &= ~TIM_CCER_CC4E;
   6504            tmpccmr2 = TIMx->CCMR2;
   6505            tmpccer = TIMx->CCER;
   6506          
   6507            /* Select the Input */
   6508            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   6509            tmpccmr2 |= (TIM_ICSelection << 8U);
   6510          
   6511            /* Set the filter */
   6512            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   6513            tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
   6514          
   6515            /* Select the Polarity and set the CC4E Bit */
   6516            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   6517            tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   6518          
   6519            /* Write to TIMx CCMR2 and CCER registers */
   6520            TIMx->CCMR2 = tmpccmr2;
   6521            TIMx->CCER = tmpccer ;
   6522          }
   6523          
   6524          /**
   6525            * @brief  Selects the Input Trigger source
   6526            * @param  TIMx to select the TIM peripheral
   6527            * @param  InputTriggerSource The Input Trigger source.
   6528            *          This parameter can be one of the following values:
   6529            *            @arg TIM_TS_ITR0: Internal Trigger 0
   6530            *            @arg TIM_TS_ITR1: Internal Trigger 1
   6531            *            @arg TIM_TS_ITR2: Internal Trigger 2
   6532            *            @arg TIM_TS_ITR3: Internal Trigger 3
   6533            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   6534            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   6535            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   6536            *            @arg TIM_TS_ETRF: External Trigger input
   6537            * @retval None
   6538            */

   \                                 In section .text, align 2, keep-with-next
   6539          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
   6540          {
   6541            uint32_t tmpsmcr;
   6542          
   6543            /* Get the TIMx SMCR register value */
   6544            tmpsmcr = TIMx->SMCR;
   6545            /* Reset the TS Bits */
   6546            tmpsmcr &= ~TIM_SMCR_TS;
   6547            /* Set the Input Trigger source and the slave mode*/
   6548            tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   6549            /* Write to TIMx SMCR */
   6550            TIMx->SMCR = tmpsmcr;
   \                     TIM_ITRx_SetConfig: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   \        0x2   0xF022 0x0270      BIC      R2,R2,#0x70
   \        0x6   0x4311             ORRS     R1,R1,R2
   \        0x8   0xF041 0x0107      ORR      R1,R1,#0x7
   \        0xC   0x6081             STR      R1,[R0, #+8]
   6551          }
   \        0xE   0x4770             BX       LR               ;; return
   6552          /**
   6553            * @brief  Configures the TIMx External Trigger (ETR).
   6554            * @param  TIMx to select the TIM peripheral
   6555            * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.
   6556            *          This parameter can be one of the following values:
   6557            *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
   6558            *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
   6559            *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
   6560            *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
   6561            * @param  TIM_ExtTRGPolarity The external Trigger Polarity.
   6562            *          This parameter can be one of the following values:
   6563            *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
   6564            *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
   6565            * @param  ExtTRGFilter External Trigger Filter.
   6566            *          This parameter must be a value between 0x00 and 0x0F
   6567            * @retval None
   6568            */

   \                                 In section .text, align 2, keep-with-next
   6569          void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
   6570                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   6571          {
   \                     TIM_ETR_SetConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   6572            uint32_t tmpsmcr;
   6573          
   6574            tmpsmcr = TIMx->SMCR;
   6575          
   6576            /* Reset the ETR Bits */
   6577            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   6578          
   6579            /* Set the Prescaler, the Filter value and the Polarity */
   6580            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   6581          
   6582            /* Write to TIMx SMCR */
   6583            TIMx->SMCR = tmpsmcr;
   \        0x2   0x6884             LDR      R4,[R0, #+8]
   \        0x4   0xF424 0x447F      BIC      R4,R4,#0xFF00
   \        0x8   0x4321             ORRS     R1,R1,R4
   \        0xA   0x4311             ORRS     R1,R2,R1
   \        0xC   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \       0x10   0x6081             STR      R1,[R0, #+8]
   6584          }
   \       0x12   0xBD10             POP      {R4,PC}          ;; return
   6585          
   6586          /**
   6587            * @brief  Enables or disables the TIM Capture Compare Channel x.
   6588            * @param  TIMx to select the TIM peripheral
   6589            * @param  Channel specifies the TIM Channel
   6590            *          This parameter can be one of the following values:
   6591            *            @arg TIM_CHANNEL_1: TIM Channel 1
   6592            *            @arg TIM_CHANNEL_2: TIM Channel 2
   6593            *            @arg TIM_CHANNEL_3: TIM Channel 3
   6594            *            @arg TIM_CHANNEL_4: TIM Channel 4
   6595            * @param  ChannelState specifies the TIM Channel CCxE bit new state.
   6596            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
   6597            * @retval None
   6598            */

   \                                 In section .text, align 2, keep-with-next
   6599          void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
   6600          {
   \                     TIM_CCxChannelCmd: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   6601            uint32_t tmp;
   6602          
   6603            /* Check the parameters */
   6604            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   6605            assert_param(IS_TIM_CHANNELS(Channel));
   6606          
   6607            tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   6608          
   6609            /* Reset the CCxE Bit */
   6610            TIMx->CCER &= ~tmp;
   \        0x2   0xF001 0x011F      AND      R1,R1,#0x1F
   \        0x6   0x6A03             LDR      R3,[R0, #+32]
   \        0x8   0x2401             MOVS     R4,#+1
   \        0xA   0x408C             LSLS     R4,R4,R1
   \        0xC   0x43A3             BICS     R3,R3,R4
   \        0xE   0x6203             STR      R3,[R0, #+32]
   6611          
   6612            /* Set or reset the CCxE Bit */
   6613            TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   \       0x10   0xFA02 0xF101      LSL      R1,R2,R1
   \       0x14   0x6A03             LDR      R3,[R0, #+32]
   \       0x16                      REQUIRE ?Subroutine12
   \       0x16                      ;; // Fall through to label ?Subroutine12
   6614          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \        0x0   0x4001'0000        DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     TIM_DMACaptureHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x....'....        DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0xFFFF'BFF8        DC32     0xffffbff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \        0x0   0xFFFF'FCFC        DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \        0x0   0xFFFF'0303        DC32     0xffff0303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0x....'....        DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \        0x0   0x....'....        DC32     TIMEx_DMACommutationHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \        0x0   0xFFFF'0088        DC32     0xffff0088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_3:
   \        0x0   0x4001'0000        DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_4:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_5:
   \        0x0   0x4000'0C00        DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_6:
   \        0x0   0x4000'0800        DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_7:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_8:
   \        0x0   0x4001'4000        DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_9:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_10:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_11:
   \        0x0   0x4000'1800        DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_12:
   \        0x0   0x4000'1C00        DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_13:
   \        0x0   0x4000'2000        DC32     0x40002000
   6615          
   6616          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6617          /**
   6618            * @brief  Reset interrupt callbacks to the legacy weak callbacks.
   6619            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   6620            *                the configuration information for TIM module.
   6621            * @retval None
   6622            */
   6623          void TIM_ResetCallback(TIM_HandleTypeDef *htim)
   6624          {
   6625            /* Reset the TIM callback to the legacy weak callbacks */
   6626            htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak PeriodElapsedCallback             */
   6627            htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak PeriodElapsedHalfCpltCallback     */
   6628            htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak TriggerCallback                   */
   6629            htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak TriggerHalfCpltCallback           */
   6630            htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC_CaptureCallback                */
   6631            htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC_CaptureHalfCpltCallback        */
   6632            htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC_DelayElapsedCallback           */
   6633            htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM_PulseFinishedCallback         */
   6634            htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM_PulseFinishedHalfCpltCallback */
   6635            htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak ErrorCallback                     */
   6636            htim->CommutationCallback               = HAL_TIMEx_CommutCallback;                  /* Legacy weak CommutationCallback               */
   6637            htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;          /* Legacy weak CommutationHalfCpltCallback       */
   6638            htim->BreakCallback                     = HAL_TIMEx_BreakCallback;                   /* Legacy weak BreakCallback                     */
   6639          }
   6640          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6641          
   6642          /**
   6643            * @}
   6644            */
   6645          
   6646          #endif /* HAL_TIM_MODULE_ENABLED */
   6647          /**
   6648            * @}
   6649            */
   6650          
   6651          /**
   6652            * @}
   6653            */
   6654          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
      16   HAL_TIM_Base_Init
        16   -> HAL_TIM_Base_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
      16   HAL_TIM_Base_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       8   HAL_TIM_Base_Stop_DMA
         8   -> HAL_DMA_Abort_IT
       0   HAL_TIM_Base_Stop_IT
      16   HAL_TIM_ConfigClockSource
        16   -> TIM_ETR_SetConfig
        16   -> TIM_ITRx_SetConfig
        16   -> TIM_TI1_ConfigInputStage
        16   -> TIM_TI2_ConfigInputStage
      24   HAL_TIM_ConfigOCrefClear
        24   -> TIM_ETR_SetConfig
       0   HAL_TIM_ConfigTI1Input
      24   HAL_TIM_DMABurst_ReadStart
        24   -> HAL_DMA_Start_IT
       0   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort_IT
      24   HAL_TIM_DMABurst_WriteStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort_IT
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      24   HAL_TIM_Encoder_Init
        24   -> HAL_TIM_Encoder_MspInit
        24   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
       8   HAL_TIM_Encoder_Start
         8   -> TIM_CCxChannelCmd
      32   HAL_TIM_Encoder_Start_DMA
        32   -> HAL_DMA_Start_IT
        32   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop_DMA
         8   -> HAL_DMA_Abort_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop_IT
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
       8   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
       0   HAL_TIM_IC_CaptureHalfCpltCallback
      24   HAL_TIM_IC_ConfigChannel
        24   -> TIM_TI1_SetConfig
        24   -> TIM_TI2_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
      16   HAL_TIM_IC_Init
        16   -> HAL_TIM_IC_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
       8   HAL_TIM_IC_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_IC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IRQHandler
         8   -> HAL_TIMEx_BreakCallback
         0   -> HAL_TIMEx_CommutCallback
         8   -> HAL_TIM_IC_CaptureCallback
         8   -> HAL_TIM_OC_DelayElapsedCallback
         8   -> HAL_TIM_PWM_PulseFinishedCallback
         8   -> HAL_TIM_PeriodElapsedCallback
         8   -> HAL_TIM_TriggerCallback
      16   HAL_TIM_OC_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
      16   HAL_TIM_OC_Init
        16   -> HAL_TIM_OC_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
       8   HAL_TIM_OC_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_OC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop_IT
         8   -> TIM_CCxChannelCmd
      48   HAL_TIM_OnePulse_ConfigChannel
        48   -> TIM_OC1_SetConfig
        48   -> TIM_OC2_SetConfig
        48   -> TIM_TI1_SetConfig
        48   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
       8   HAL_TIM_OnePulse_Start
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Stop_IT
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
      16   HAL_TIM_PWM_Init
        16   -> HAL_TIM_PWM_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
       0   HAL_TIM_PWM_PulseFinishedHalfCpltCallback
       8   HAL_TIM_PWM_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Start_IT
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Stop_IT
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_PeriodElapsedHalfCpltCallback
       0   HAL_TIM_ReadCapturedValue
      16   HAL_TIM_SlaveConfigSynchro
        16   -> TIM_SlaveTimer_SetConfig
      16   HAL_TIM_SlaveConfigSynchro_IT
        16   -> TIM_SlaveTimer_SetConfig
       0   HAL_TIM_TriggerCallback
       0   HAL_TIM_TriggerHalfCpltCallback
      20   TIM_Base_SetConfig
       8   TIM_CCxChannelCmd
       8   TIM_DMACaptureCplt
         8   -> HAL_TIM_IC_CaptureCallback
       8   TIM_DMACaptureHalfCplt
         8   -> HAL_TIM_IC_CaptureHalfCpltCallback
       8   TIM_DMADelayPulseCplt
         8   -> HAL_TIM_PWM_PulseFinishedCallback
       8   TIM_DMADelayPulseHalfCplt
         8   -> HAL_TIM_PWM_PulseFinishedHalfCpltCallback
       0   TIM_DMAError
         0   -> HAL_TIM_ErrorCallback
       0   TIM_DMAPeriodElapsedCplt
         0   -> HAL_TIM_PeriodElapsedCallback
       0   TIM_DMAPeriodElapsedHalfCplt
         0   -> HAL_TIM_PeriodElapsedHalfCpltCallback
       0   TIM_DMATriggerCplt
         0   -> HAL_TIM_TriggerCallback
       0   TIM_DMATriggerHalfCplt
         0   -> HAL_TIM_TriggerHalfCpltCallback
       8   TIM_ETR_SetConfig
       0   TIM_ITRx_SetConfig
      20   TIM_OC1_SetConfig
      20   TIM_OC2_SetConfig
      20   TIM_OC3_SetConfig
      16   TIM_OC4_SetConfig
       8   TIM_SlaveTimer_SetConfig
         8   -> TIM_ETR_SetConfig
         8   -> TIM_TI1_ConfigInputStage
         8   -> TIM_TI2_ConfigInputStage
       8   TIM_TI1_ConfigInputStage
      20   TIM_TI1_SetConfig
       8   TIM_TI2_ConfigInputStage
      12   TIM_TI2_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_10
       4  ??DataTable31_11
       4  ??DataTable31_12
       4  ??DataTable31_13
       4  ??DataTable31_2
       4  ??DataTable31_3
       4  ??DataTable31_4
       4  ??DataTable31_5
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       4  ??DataTable31_9
       6  ??Subroutine74_0
       6  ??Subroutine75_0
       6  ??Subroutine76_0
       6  ??Subroutine77_0
      12  ??Subroutine78_0
      96  ?Subroutine0
      12  ?Subroutine1
       8  ?Subroutine10
       6  ?Subroutine11
       6  ?Subroutine12
      10  ?Subroutine13
       6  ?Subroutine14
      12  ?Subroutine15
      14  ?Subroutine16
      36  ?Subroutine17
      10  ?Subroutine18
      12  ?Subroutine19
      22  ?Subroutine2
       8  ?Subroutine20
       8  ?Subroutine21
      10  ?Subroutine22
      12  ?Subroutine23
      20  ?Subroutine24
      16  ?Subroutine25
       6  ?Subroutine26
      68  ?Subroutine27
      68  ?Subroutine28
      10  ?Subroutine29
      20  ?Subroutine3
      10  ?Subroutine30
      14  ?Subroutine31
       8  ?Subroutine32
       8  ?Subroutine33
      18  ?Subroutine34
      18  ?Subroutine35
      18  ?Subroutine36
      18  ?Subroutine37
      26  ?Subroutine38
      12  ?Subroutine39
      10  ?Subroutine4
      10  ?Subroutine40
      10  ?Subroutine41
      14  ?Subroutine42
      10  ?Subroutine43
      14  ?Subroutine44
      14  ?Subroutine45
      14  ?Subroutine46
      10  ?Subroutine47
      10  ?Subroutine48
      10  ?Subroutine49
      32  ?Subroutine5
      10  ?Subroutine50
      10  ?Subroutine51
      10  ?Subroutine52
      10  ?Subroutine53
      12  ?Subroutine54
      12  ?Subroutine55
      12  ?Subroutine56
      12  ?Subroutine57
      24  ?Subroutine58
       6  ?Subroutine59
      22  ?Subroutine6
      10  ?Subroutine60
      16  ?Subroutine61
      10  ?Subroutine62
      10  ?Subroutine63
      14  ?Subroutine64
      14  ?Subroutine65
      18  ?Subroutine66
      16  ?Subroutine67
       8  ?Subroutine68
       8  ?Subroutine69
      14  ?Subroutine7
      12  ?Subroutine70
       8  ?Subroutine71
      10  ?Subroutine72
       8  ?Subroutine73
      14  ?Subroutine8
      10  ?Subroutine9
      26  HAL_TIM_Base_DeInit
       2  HAL_TIM_Base_GetState
      26  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      30  HAL_TIM_Base_Start
      98  HAL_TIM_Base_Start_DMA
      32  HAL_TIM_Base_Start_IT
      38  HAL_TIM_Base_Stop
      38  HAL_TIM_Base_Stop_DMA
      42  HAL_TIM_Base_Stop_IT
     144  HAL_TIM_ConfigClockSource
     168  HAL_TIM_ConfigOCrefClear
      16  HAL_TIM_ConfigTI1Input
     336  HAL_TIM_DMABurst_ReadStart
       2  HAL_TIM_DMABurst_ReadStop
     336  HAL_TIM_DMABurst_WriteStart
       4  HAL_TIM_DMABurst_WriteStop
      28  HAL_TIM_Encoder_DeInit
       2  HAL_TIM_Encoder_GetState
     140  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      30  HAL_TIM_Encoder_Start
     212  HAL_TIM_Encoder_Start_DMA
      62  HAL_TIM_Encoder_Start_IT
      50  HAL_TIM_Encoder_Stop
      84  HAL_TIM_Encoder_Stop_DMA
      76  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      36  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
       2  HAL_TIM_IC_CaptureHalfCpltCallback
     244  HAL_TIM_IC_ConfigChannel
      26  HAL_TIM_IC_DeInit
       2  HAL_TIM_IC_GetState
      26  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      10  HAL_TIM_IC_Start
     204  HAL_TIM_IC_Start_DMA
      10  HAL_TIM_IC_Start_IT
      22  HAL_TIM_IC_Stop
      80  HAL_TIM_IC_Stop_DMA
      22  HAL_TIM_IC_Stop_IT
     322  HAL_TIM_IRQHandler
      72  HAL_TIM_OC_ConfigChannel
      24  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       2  HAL_TIM_OC_GetState
      24  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
      20  HAL_TIM_OC_Start
     120  HAL_TIM_OC_Start_DMA
      18  HAL_TIM_OC_Start_IT
      50  HAL_TIM_OC_Stop
      98  HAL_TIM_OC_Stop_DMA
      48  HAL_TIM_OC_Stop_IT
     190  HAL_TIM_OnePulse_ConfigChannel
      26  HAL_TIM_OnePulse_DeInit
       2  HAL_TIM_OnePulse_GetState
      64  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      28  HAL_TIM_OnePulse_Start
      36  HAL_TIM_OnePulse_Start_IT
      58  HAL_TIM_OnePulse_Stop
      70  HAL_TIM_OnePulse_Stop_IT
     188  HAL_TIM_PWM_ConfigChannel
      26  HAL_TIM_PWM_DeInit
       2  HAL_TIM_PWM_GetState
      26  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
       2  HAL_TIM_PWM_PulseFinishedHalfCpltCallback
      20  HAL_TIM_PWM_Start
     120  HAL_TIM_PWM_Start_DMA
      20  HAL_TIM_PWM_Start_IT
      50  HAL_TIM_PWM_Stop
      98  HAL_TIM_PWM_Stop_DMA
      50  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
       2  HAL_TIM_PeriodElapsedHalfCpltCallback
      44  HAL_TIM_ReadCapturedValue
      30  HAL_TIM_SlaveConfigSynchro
      30  HAL_TIM_SlaveConfigSynchro_IT
       2  HAL_TIM_TriggerCallback
       2  HAL_TIM_TriggerHalfCpltCallback
     150  TIM_Base_SetConfig
      22  TIM_CCxChannelCmd
      50  TIM_DMACaptureCplt
      50  TIM_DMACaptureHalfCplt
      50  TIM_DMADelayPulseCplt
      48  TIM_DMADelayPulseHalfCplt
      12  TIM_DMAError
      12  TIM_DMAPeriodElapsedCplt
      12  TIM_DMAPeriodElapsedHalfCplt
      12  TIM_DMATriggerCplt
      12  TIM_DMATriggerHalfCplt
      20  TIM_ETR_SetConfig
      16  TIM_ITRx_SetConfig
      88  TIM_OC1_SetConfig
      96  TIM_OC2_SetConfig
      94  TIM_OC3_SetConfig
      70  TIM_OC4_SetConfig
     114  TIM_SlaveTimer_SetConfig
      30  TIM_TI1_ConfigInputStage
      94  TIM_TI1_SetConfig
      36  TIM_TI2_ConfigInputStage
      44  TIM_TI2_SetConfig

 
 7'140 bytes in section .text
 
 7'096 bytes of CODE memory (+ 44 bytes shared)

Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V8.42.1.233/W32 for ARM         26/Feb/2020  14:11:27
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\mohit\Desktop\Microapps
#        projects\LAB7\Task2\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim_ex.c
#    Command line      =
#        -f C:\Users\mohit\AppData\Local\Temp\EWE146.tmp
#        ("C:\Users\mohit\Desktop\Microapps
#        projects\LAB7\Task2\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim_ex.c"
#        -D USE_HAL_DRIVER -D STM32F429xx -lC "C:\Users\mohit\Desktop\Microapps
#        projects\LAB7\Task2\EWARM\Task2\List" -o
#        "C:\Users\mohit\Desktop\Microapps projects\LAB7\Task2\EWARM\Task2\Obj"
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I "C:\Users\mohit\Desktop\Microapps
#        projects\LAB7\Task2\EWARM/../Inc\" -I
#        "C:\Users\mohit\Desktop\Microapps
#        projects\LAB7\Task2\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\" -I
#        "C:\Users\mohit\Desktop\Microapps
#        projects\LAB7\Task2\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\"
#        -I "C:\Users\mohit\Desktop\Microapps
#        projects\LAB7\Task2\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\"
#        -I "C:\Users\mohit\Desktop\Microapps
#        projects\LAB7\Task2\EWARM/../Drivers/CMSIS/Include\" -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\mohit\Desktop\Microapps
#        projects\LAB7\Task2\EWARM\Task2\List\stm32f4xx_hal_tim_ex.lst
#    Object file       =
#        C:\Users\mohit\Desktop\Microapps
#        projects\LAB7\Task2\EWARM\Task2\Obj\stm32f4xx_hal_tim_ex.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#      __size_limit    =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Users\mohit\Desktop\Microapps projects\LAB7\Task2\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_tim_ex.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Timer Extended peripheral:
      8            *           + Time Hall Sensor Interface Initialization
      9            *           + Time Hall Sensor Interface Start
     10            *           + Time Complementary signal break and dead time configuration
     11            *           + Time Master and Slave synchronization configuration
     12            *           + Timer remapping capabilities configuration
     13            @verbatim
     14            ==============================================================================
     15                                ##### TIMER Extended features #####
     16            ==============================================================================
     17            [..]
     18              The Timer Extended features include:
     19              (#) Complementary outputs with programmable dead-time for :
     20                  (++) Output Compare
     21                  (++) PWM generation (Edge and Center-aligned Mode)
     22                  (++) One-pulse mode output
     23              (#) Synchronization circuit to control the timer with external signals and to
     24                  interconnect several timers together.
     25              (#) Break input to put the timer output signals in reset state or in a known state.
     26              (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for
     27                  positioning purposes
     28          
     29                      ##### How to use this driver #####
     30            ==============================================================================
     31              [..]
     32               (#) Initialize the TIM low level resources by implementing the following functions
     33                   depending on the selected feature:
     34                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()
     35          
     36               (#) Initialize the TIM low level resources :
     37                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     38                  (##) TIM pins configuration
     39                      (+++) Enable the clock for the TIM GPIOs using the following function:
     40                        __HAL_RCC_GPIOx_CLK_ENABLE();
     41                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     42          
     43               (#) The external Clock can be configured, if needed (the default clock is the
     44                   internal clock from the APBx), using the following function:
     45                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     46                   any start function.
     47          
     48               (#) Configure the TIM in the desired functioning mode using one of the
     49                   initialization function of this driver:
     50                    (++) HAL_TIMEx_HallSensor_Init() and HAL_TIMEx_ConfigCommutEvent(): to use the
     51                         Timer Hall Sensor Interface and the commutation event with the corresponding
     52                         Interrupt and DMA request if needed (Note that One Timer is used to interface
     53                         with the Hall sensor Interface and another Timer should be used to use
     54                         the commutation event).
     55          
     56               (#) Activate the TIM peripheral using one of the start functions:
     57                     (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OC_Start_IT()
     58                     (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()
     59                     (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()
     60                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().
     61          
     62            @endverbatim
     63            ******************************************************************************
     64            * @attention
     65            *
     66            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     67            * All rights reserved.</center></h2>
     68            *
     69            * This software component is licensed by ST under BSD 3-Clause license,
     70            * the "License"; You may not use this file except in compliance with the
     71            * License. You may obtain a copy of the License at:
     72            *                        opensource.org/licenses/BSD-3-Clause
     73            *
     74            ******************************************************************************
     75            */
     76          
     77          /* Includes ------------------------------------------------------------------*/
     78          #include "stm32f4xx_hal.h"
     79          
     80          /** @addtogroup STM32F4xx_HAL_Driver
     81            * @{
     82            */
     83          
     84          /** @defgroup TIMEx TIMEx
     85            * @brief TIM Extended HAL module driver
     86            * @{
     87            */
     88          
     89          #ifdef HAL_TIM_MODULE_ENABLED
     90          
     91          /* Private typedef -----------------------------------------------------------*/
     92          /* Private define ------------------------------------------------------------*/
     93          /* Private macro -------------------------------------------------------------*/
     94          /* Private variables ---------------------------------------------------------*/
     95          /* Private function prototypes -----------------------------------------------*/
     96          static void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState);
     97          
     98          /* Exported functions --------------------------------------------------------*/
     99          /** @defgroup TIMEx_Exported_Functions TIM Extended Exported Functions
    100            * @{
    101            */
    102          
    103          /** @defgroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions
    104            * @brief    Timer Hall Sensor functions
    105            *
    106          @verbatim
    107            ==============================================================================
    108                                ##### Timer Hall Sensor functions #####
    109            ==============================================================================
    110            [..]
    111              This section provides functions allowing to:
    112              (+) Initialize and configure TIM HAL Sensor.
    113              (+) De-initialize TIM HAL Sensor.
    114              (+) Start the Hall Sensor Interface.
    115              (+) Stop the Hall Sensor Interface.
    116              (+) Start the Hall Sensor Interface and enable interrupts.
    117              (+) Stop the Hall Sensor Interface and disable interrupts.
    118              (+) Start the Hall Sensor Interface and enable DMA transfers.
    119              (+) Stop the Hall Sensor Interface and disable DMA transfers.
    120          
    121          @endverbatim
    122            * @{
    123            */
    124          /**
    125            * @brief  Initializes the TIM Hall Sensor Interface and initialize the associated handle.
    126            * @param  htim TIM Hall Sensor Interface handle
    127            * @param  sConfig TIM Hall Sensor configuration structure
    128            * @retval HAL status
    129            */
    130          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef *sConfig)
    131          {
    132            TIM_OC_InitTypeDef OC_Config;
    133          
    134            /* Check the TIM handle allocation */
    135            if (htim == NULL)
    136            {
    137              return HAL_ERROR;
    138            }
    139          
    140            /* Check the parameters */
    141            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    142            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    143            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    144            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    145            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
    146            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
    147            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
    148          
    149            if (htim->State == HAL_TIM_STATE_RESET)
    150            {
    151              /* Allocate lock resource and initialize it */
    152              htim->Lock = HAL_UNLOCKED;
    153          
    154          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    155              /* Reset interrupt callbacks to legacy week callbacks */
    156              TIM_ResetCallback(htim);
    157          
    158              if (htim->HallSensor_MspInitCallback == NULL)
    159              {
    160                htim->HallSensor_MspInitCallback = HAL_TIMEx_HallSensor_MspInit;
    161              }
    162              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    163              htim->HallSensor_MspInitCallback(htim);
    164          #else
    165              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    166              HAL_TIMEx_HallSensor_MspInit(htim);
    167          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    168            }
    169          
    170            /* Set the TIM state */
    171            htim->State = HAL_TIM_STATE_BUSY;
    172          
    173            /* Configure the Time base in the Encoder Mode */
    174            TIM_Base_SetConfig(htim->Instance, &htim->Init);
    175          
    176            /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
    177            TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
    178          
    179            /* Reset the IC1PSC Bits */
    180            htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
    181            /* Set the IC1PSC value */
    182            htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
    183          
    184            /* Enable the Hall sensor interface (XOR function of the three inputs) */
    185            htim->Instance->CR2 |= TIM_CR2_TI1S;
    186          
    187            /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
    188            htim->Instance->SMCR &= ~TIM_SMCR_TS;
    189            htim->Instance->SMCR |= TIM_TS_TI1F_ED;
    190          
    191            /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
    192            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
    193            htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
    194          
    195            /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
    196            OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
    197            OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
    198            OC_Config.OCMode = TIM_OCMODE_PWM2;
    199            OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
    200            OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
    201            OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
    202            OC_Config.Pulse = sConfig->Commutation_Delay;
    203          
    204            TIM_OC2_SetConfig(htim->Instance, &OC_Config);
    205          
    206            /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
    207              register to 101 */
    208            htim->Instance->CR2 &= ~TIM_CR2_MMS;
    209            htim->Instance->CR2 |= TIM_TRGO_OC2REF;
    210          
    211            /* Initialize the TIM state*/
    212            htim->State = HAL_TIM_STATE_READY;
    213          
    214            return HAL_OK;
    215          }
    216          
    217          /**
    218            * @brief  DeInitializes the TIM Hall Sensor interface
    219            * @param  htim TIM Hall Sensor Interface handle
    220            * @retval HAL status
    221            */
    222          HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
    223          {
    224            /* Check the parameters */
    225            assert_param(IS_TIM_INSTANCE(htim->Instance));
    226          
    227            htim->State = HAL_TIM_STATE_BUSY;
    228          
    229            /* Disable the TIM Peripheral Clock */
    230            __HAL_TIM_DISABLE(htim);
    231          
    232          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    233            if (htim->HallSensor_MspDeInitCallback == NULL)
    234            {
    235              htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;
    236            }
    237            /* DeInit the low level hardware */
    238            htim->HallSensor_MspDeInitCallback(htim);
    239          #else
    240            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    241            HAL_TIMEx_HallSensor_MspDeInit(htim);
    242          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    243          
    244            /* Change TIM state */
    245            htim->State = HAL_TIM_STATE_RESET;
    246          
    247            /* Release Lock */
    248            __HAL_UNLOCK(htim);
    249          
    250            return HAL_OK;
    251          }
    252          
    253          /**
    254            * @brief  Initializes the TIM Hall Sensor MSP.
    255            * @param  htim TIM Hall Sensor Interface handle
    256            * @retval None
    257            */
    258          __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
    259          {
    260            /* Prevent unused argument(s) compilation warning */
    261            UNUSED(htim);
    262          
    263            /* NOTE : This function should not be modified, when the callback is needed,
    264                      the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
    265             */
    266          }
    267          
    268          /**
    269            * @brief  DeInitializes TIM Hall Sensor MSP.
    270            * @param  htim TIM Hall Sensor Interface handle
    271            * @retval None
    272            */
    273          __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
    274          {
    275            /* Prevent unused argument(s) compilation warning */
    276            UNUSED(htim);
    277          
    278            /* NOTE : This function should not be modified, when the callback is needed,
    279                      the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
    280             */
    281          }
    282          
    283          /**
    284            * @brief  Starts the TIM Hall Sensor Interface.
    285            * @param  htim TIM Hall Sensor Interface handle
    286            * @retval HAL status
    287            */
    288          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
    289          {
    290            uint32_t tmpsmcr;
    291          
    292            /* Check the parameters */
    293            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    294          
    295            /* Enable the Input Capture channel 1
    296              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    297            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
    298          
    299            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    300            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    301            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    302            {
    303              __HAL_TIM_ENABLE(htim);
    304            }
    305          
    306            /* Return function status */
    307            return HAL_OK;
    308          }
    309          
    310          /**
    311            * @brief  Stops the TIM Hall sensor Interface.
    312            * @param  htim TIM Hall Sensor Interface handle
    313            * @retval HAL status
    314            */
    315          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
    316          {
    317            /* Check the parameters */
    318            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    319          
    320            /* Disable the Input Capture channels 1, 2 and 3
    321              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    322            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
    323          
    324            /* Disable the Peripheral */
    325            __HAL_TIM_DISABLE(htim);
    326          
    327            /* Return function status */
    328            return HAL_OK;
    329          }
    330          
    331          /**
    332            * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.
    333            * @param  htim TIM Hall Sensor Interface handle
    334            * @retval HAL status
    335            */
    336          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
    337          {
    338            uint32_t tmpsmcr;
    339          
    340            /* Check the parameters */
    341            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    342          
    343            /* Enable the capture compare Interrupts 1 event */
    344            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
    345          
    346            /* Enable the Input Capture channel 1
    347              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    348            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
    349          
    350            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    351            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    352            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    353            {
    354              __HAL_TIM_ENABLE(htim);
    355            }
    356          
    357            /* Return function status */
    358            return HAL_OK;
    359          }
    360          
    361          /**
    362            * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.
    363            * @param  htim TIM Hall Sensor Interface handle
    364            * @retval HAL status
    365            */
    366          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
    367          {
    368            /* Check the parameters */
    369            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    370          
    371            /* Disable the Input Capture channel 1
    372              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    373            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
    374          
    375            /* Disable the capture compare Interrupts event */
    376            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
    377          
    378            /* Disable the Peripheral */
    379            __HAL_TIM_DISABLE(htim);
    380          
    381            /* Return function status */
    382            return HAL_OK;
    383          }
    384          
    385          /**
    386            * @brief  Starts the TIM Hall Sensor Interface in DMA mode.
    387            * @param  htim TIM Hall Sensor Interface handle
    388            * @param  pData The destination Buffer address.
    389            * @param  Length The length of data to be transferred from TIM peripheral to memory.
    390            * @retval HAL status
    391            */
    392          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    393          {
    394            uint32_t tmpsmcr;
    395          
    396            /* Check the parameters */
    397            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    398          
    399            if (htim->State == HAL_TIM_STATE_BUSY)
    400            {
    401              return HAL_BUSY;
    402            }
    403            else if (htim->State == HAL_TIM_STATE_READY)
    404            {
    405              if (((uint32_t)pData == 0U) && (Length > 0U))
    406              {
    407                return HAL_ERROR;
    408              }
    409              else
    410              {
    411                htim->State = HAL_TIM_STATE_BUSY;
    412              }
    413            }
    414            else
    415            {
    416              /* nothing to do */
    417            }
    418            /* Enable the Input Capture channel 1
    419              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    420            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
    421          
    422            /* Set the DMA Input Capture 1 Callbacks */
    423            htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
    424            htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
    425            /* Set the DMA error callback */
    426            htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
    427          
    428            /* Enable the DMA stream for Capture 1*/
    429            if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
    430            {
    431              return HAL_ERROR;
    432            }
    433            /* Enable the capture compare 1 Interrupt */
    434            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
    435          
    436            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    437            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    438            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    439            {
    440              __HAL_TIM_ENABLE(htim);
    441            }
    442          
    443            /* Return function status */
    444            return HAL_OK;
    445          }
    446          
    447          /**
    448            * @brief  Stops the TIM Hall Sensor Interface in DMA mode.
    449            * @param  htim TIM Hall Sensor Interface handle
    450            * @retval HAL status
    451            */
    452          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
    453          {
    454            /* Check the parameters */
    455            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    456          
    457            /* Disable the Input Capture channel 1
    458              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    459            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
    460          
    461          
    462            /* Disable the capture compare Interrupts 1 event */
    463            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
    464          
    465            (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
    466            /* Disable the Peripheral */
    467            __HAL_TIM_DISABLE(htim);
    468          
    469            /* Return function status */
    470            return HAL_OK;
    471          }
    472          
    473          /**
    474            * @}
    475            */
    476          
    477          /** @defgroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions
    478            *  @brief   Timer Complementary Output Compare functions
    479            *
    480          @verbatim
    481            ==============================================================================
    482                        ##### Timer Complementary Output Compare functions #####
    483            ==============================================================================
    484            [..]
    485              This section provides functions allowing to:
    486              (+) Start the Complementary Output Compare/PWM.
    487              (+) Stop the Complementary Output Compare/PWM.
    488              (+) Start the Complementary Output Compare/PWM and enable interrupts.
    489              (+) Stop the Complementary Output Compare/PWM and disable interrupts.
    490              (+) Start the Complementary Output Compare/PWM and enable DMA transfers.
    491              (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.
    492          
    493          @endverbatim
    494            * @{
    495            */
    496          
    497          /**
    498            * @brief  Starts the TIM Output Compare signal generation on the complementary
    499            *         output.
    500            * @param  htim TIM Output Compare handle
    501            * @param  Channel TIM Channel to be enabled
    502            *          This parameter can be one of the following values:
    503            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    504            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    505            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    506            * @retval HAL status
    507            */
    508          HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    509          {
    510            uint32_t tmpsmcr;
    511          
    512            /* Check the parameters */
    513            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    514          
    515            /* Enable the Capture compare channel N */
    516            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
    517          
    518            /* Enable the Main Output */
    519            __HAL_TIM_MOE_ENABLE(htim);
    520          
    521            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    522            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    523            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    524            {
    525              __HAL_TIM_ENABLE(htim);
    526            }
    527          
    528            /* Return function status */
    529            return HAL_OK;
    530          }
    531          
    532          /**
    533            * @brief  Stops the TIM Output Compare signal generation on the complementary
    534            *         output.
    535            * @param  htim TIM handle
    536            * @param  Channel TIM Channel to be disabled
    537            *          This parameter can be one of the following values:
    538            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    539            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    540            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    541            * @retval HAL status
    542            */
    543          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    544          {
    545            /* Check the parameters */
    546            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    547          
    548            /* Disable the Capture compare channel N */
    549            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
    550          
    551            /* Disable the Main Output */
    552            __HAL_TIM_MOE_DISABLE(htim);
    553          
    554            /* Disable the Peripheral */
    555            __HAL_TIM_DISABLE(htim);
    556          
    557            /* Return function status */
    558            return HAL_OK;
    559          }
    560          
    561          /**
    562            * @brief  Starts the TIM Output Compare signal generation in interrupt mode
    563            *         on the complementary output.
    564            * @param  htim TIM OC handle
    565            * @param  Channel TIM Channel to be enabled
    566            *          This parameter can be one of the following values:
    567            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    568            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    569            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    570            * @retval HAL status
    571            */
    572          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    573          {
    574            uint32_t tmpsmcr;
    575          
    576            /* Check the parameters */
    577            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    578          
    579            switch (Channel)
    580            {
    581              case TIM_CHANNEL_1:
    582              {
    583                /* Enable the TIM Output Compare interrupt */
    584                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
    585                break;
    586              }
    587          
    588              case TIM_CHANNEL_2:
    589              {
    590                /* Enable the TIM Output Compare interrupt */
    591                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
    592                break;
    593              }
    594          
    595              case TIM_CHANNEL_3:
    596              {
    597                /* Enable the TIM Output Compare interrupt */
    598                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
    599                break;
    600              }
    601          
    602          
    603              default:
    604                break;
    605            }
    606          
    607            /* Enable the TIM Break interrupt */
    608            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
    609          
    610            /* Enable the Capture compare channel N */
    611            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
    612          
    613            /* Enable the Main Output */
    614            __HAL_TIM_MOE_ENABLE(htim);
    615          
    616            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    617            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    618            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    619            {
    620              __HAL_TIM_ENABLE(htim);
    621            }
    622          
    623            /* Return function status */
    624            return HAL_OK;
    625          }
    626          
    627          /**
    628            * @brief  Stops the TIM Output Compare signal generation in interrupt mode
    629            *         on the complementary output.
    630            * @param  htim TIM Output Compare handle
    631            * @param  Channel TIM Channel to be disabled
    632            *          This parameter can be one of the following values:
    633            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    634            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    635            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    636            * @retval HAL status
    637            */
    638          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    639          {
    640            uint32_t tmpccer;
    641            /* Check the parameters */
    642            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    643          
    644            switch (Channel)
    645            {
    646              case TIM_CHANNEL_1:
    647              {
    648                /* Disable the TIM Output Compare interrupt */
    649                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
    650                break;
    651              }
    652          
    653              case TIM_CHANNEL_2:
    654              {
    655                /* Disable the TIM Output Compare interrupt */
    656                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
    657                break;
    658              }
    659          
    660              case TIM_CHANNEL_3:
    661              {
    662                /* Disable the TIM Output Compare interrupt */
    663                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
    664                break;
    665              }
    666          
    667              default:
    668                break;
    669            }
    670          
    671            /* Disable the Capture compare channel N */
    672            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
    673          
    674            /* Disable the TIM Break interrupt (only if no more channel is active) */
    675            tmpccer = htim->Instance->CCER;
    676            if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
    677            {
    678              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
    679            }
    680          
    681            /* Disable the Main Output */
    682            __HAL_TIM_MOE_DISABLE(htim);
    683          
    684            /* Disable the Peripheral */
    685            __HAL_TIM_DISABLE(htim);
    686          
    687            /* Return function status */
    688            return HAL_OK;
    689          }
    690          
    691          /**
    692            * @brief  Starts the TIM Output Compare signal generation in DMA mode
    693            *         on the complementary output.
    694            * @param  htim TIM Output Compare handle
    695            * @param  Channel TIM Channel to be enabled
    696            *          This parameter can be one of the following values:
    697            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    698            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    699            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    700            * @param  pData The source Buffer address.
    701            * @param  Length The length of data to be transferred from memory to TIM peripheral
    702            * @retval HAL status
    703            */
    704          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    705          {
    706            uint32_t tmpsmcr;
    707          
    708            /* Check the parameters */
    709            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    710          
    711            if (htim->State == HAL_TIM_STATE_BUSY)
    712            {
    713              return HAL_BUSY;
    714            }
    715            else if (htim->State == HAL_TIM_STATE_READY)
    716            {
    717              if (((uint32_t)pData == 0U) && (Length > 0U))
    718              {
    719                return HAL_ERROR;
    720              }
    721              else
    722              {
    723                htim->State = HAL_TIM_STATE_BUSY;
    724              }
    725            }
    726            else
    727            {
    728              /* nothing to do  */
    729            }
    730          
    731            switch (Channel)
    732            {
    733              case TIM_CHANNEL_1:
    734              {
    735                /* Set the DMA compare callbacks */
    736                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
    737                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    738          
    739                /* Set the DMA error callback */
    740                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
    741          
    742                /* Enable the DMA stream */
    743                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
    744                {
    745                  return HAL_ERROR;
    746                }
    747                /* Enable the TIM Output Compare DMA request */
    748                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
    749                break;
    750              }
    751          
    752              case TIM_CHANNEL_2:
    753              {
    754                /* Set the DMA compare callbacks */
    755                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
    756                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    757          
    758                /* Set the DMA error callback */
    759                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
    760          
    761                /* Enable the DMA stream */
    762                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
    763                {
    764                  return HAL_ERROR;
    765                }
    766                /* Enable the TIM Output Compare DMA request */
    767                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
    768                break;
    769              }
    770          
    771              case TIM_CHANNEL_3:
    772              {
    773                /* Set the DMA compare callbacks */
    774                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
    775                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    776          
    777                /* Set the DMA error callback */
    778                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
    779          
    780                /* Enable the DMA stream */
    781                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
    782                {
    783                  return HAL_ERROR;
    784                }
    785                /* Enable the TIM Output Compare DMA request */
    786                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
    787                break;
    788              }
    789          
    790              default:
    791                break;
    792            }
    793          
    794            /* Enable the Capture compare channel N */
    795            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
    796          
    797            /* Enable the Main Output */
    798            __HAL_TIM_MOE_ENABLE(htim);
    799          
    800            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    801            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    802            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    803            {
    804              __HAL_TIM_ENABLE(htim);
    805            }
    806          
    807            /* Return function status */
    808            return HAL_OK;
    809          }
    810          
    811          /**
    812            * @brief  Stops the TIM Output Compare signal generation in DMA mode
    813            *         on the complementary output.
    814            * @param  htim TIM Output Compare handle
    815            * @param  Channel TIM Channel to be disabled
    816            *          This parameter can be one of the following values:
    817            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    818            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    819            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    820            * @retval HAL status
    821            */
    822          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    823          {
    824            /* Check the parameters */
    825            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    826          
    827            switch (Channel)
    828            {
    829              case TIM_CHANNEL_1:
    830              {
    831                /* Disable the TIM Output Compare DMA request */
    832                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
    833                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
    834                break;
    835              }
    836          
    837              case TIM_CHANNEL_2:
    838              {
    839                /* Disable the TIM Output Compare DMA request */
    840                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
    841                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
    842                break;
    843              }
    844          
    845              case TIM_CHANNEL_3:
    846              {
    847                /* Disable the TIM Output Compare DMA request */
    848                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
    849                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
    850                break;
    851              }
    852          
    853              default:
    854                break;
    855            }
    856          
    857            /* Disable the Capture compare channel N */
    858            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
    859          
    860            /* Disable the Main Output */
    861            __HAL_TIM_MOE_DISABLE(htim);
    862          
    863            /* Disable the Peripheral */
    864            __HAL_TIM_DISABLE(htim);
    865          
    866            /* Change the htim state */
    867            htim->State = HAL_TIM_STATE_READY;
    868          
    869            /* Return function status */
    870            return HAL_OK;
    871          }
    872          
    873          /**
    874            * @}
    875            */
    876          
    877          /** @defgroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions
    878            * @brief    Timer Complementary PWM functions
    879            *
    880          @verbatim
    881            ==============================================================================
    882                           ##### Timer Complementary PWM functions #####
    883            ==============================================================================
    884            [..]
    885              This section provides functions allowing to:
    886              (+) Start the Complementary PWM.
    887              (+) Stop the Complementary PWM.
    888              (+) Start the Complementary PWM and enable interrupts.
    889              (+) Stop the Complementary PWM and disable interrupts.
    890              (+) Start the Complementary PWM and enable DMA transfers.
    891              (+) Stop the Complementary PWM and disable DMA transfers.
    892              (+) Start the Complementary Input Capture measurement.
    893              (+) Stop the Complementary Input Capture.
    894              (+) Start the Complementary Input Capture and enable interrupts.
    895              (+) Stop the Complementary Input Capture and disable interrupts.
    896              (+) Start the Complementary Input Capture and enable DMA transfers.
    897              (+) Stop the Complementary Input Capture and disable DMA transfers.
    898              (+) Start the Complementary One Pulse generation.
    899              (+) Stop the Complementary One Pulse.
    900              (+) Start the Complementary One Pulse and enable interrupts.
    901              (+) Stop the Complementary One Pulse and disable interrupts.
    902          
    903          @endverbatim
    904            * @{
    905            */
    906          
    907          /**
    908            * @brief  Starts the PWM signal generation on the complementary output.
    909            * @param  htim TIM handle
    910            * @param  Channel TIM Channel to be enabled
    911            *          This parameter can be one of the following values:
    912            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    913            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    914            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    915            * @retval HAL status
    916            */
    917          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    918          {
    919            uint32_t tmpsmcr;
    920          
    921            /* Check the parameters */
    922            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    923          
    924            /* Enable the complementary PWM output  */
    925            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
    926          
    927            /* Enable the Main Output */
    928            __HAL_TIM_MOE_ENABLE(htim);
    929          
    930            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    931            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    932            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    933            {
    934              __HAL_TIM_ENABLE(htim);
    935            }
    936          
    937            /* Return function status */
    938            return HAL_OK;
    939          }
    940          
    941          /**
    942            * @brief  Stops the PWM signal generation on the complementary output.
    943            * @param  htim TIM handle
    944            * @param  Channel TIM Channel to be disabled
    945            *          This parameter can be one of the following values:
    946            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    947            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    948            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    949            * @retval HAL status
    950            */
    951          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    952          {
    953            /* Check the parameters */
    954            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    955          
    956            /* Disable the complementary PWM output  */
    957            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
    958          
    959            /* Disable the Main Output */
    960            __HAL_TIM_MOE_DISABLE(htim);
    961          
    962            /* Disable the Peripheral */
    963            __HAL_TIM_DISABLE(htim);
    964          
    965            /* Return function status */
    966            return HAL_OK;
    967          }
    968          
    969          /**
    970            * @brief  Starts the PWM signal generation in interrupt mode on the
    971            *         complementary output.
    972            * @param  htim TIM handle
    973            * @param  Channel TIM Channel to be disabled
    974            *          This parameter can be one of the following values:
    975            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    976            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    977            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    978            * @retval HAL status
    979            */
    980          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    981          {
    982            uint32_t tmpsmcr;
    983          
    984            /* Check the parameters */
    985            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    986          
    987            switch (Channel)
    988            {
    989              case TIM_CHANNEL_1:
    990              {
    991                /* Enable the TIM Capture/Compare 1 interrupt */
    992                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
    993                break;
    994              }
    995          
    996              case TIM_CHANNEL_2:
    997              {
    998                /* Enable the TIM Capture/Compare 2 interrupt */
    999                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1000                break;
   1001              }
   1002          
   1003              case TIM_CHANNEL_3:
   1004              {
   1005                /* Enable the TIM Capture/Compare 3 interrupt */
   1006                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1007                break;
   1008              }
   1009          
   1010              default:
   1011                break;
   1012            }
   1013          
   1014            /* Enable the TIM Break interrupt */
   1015            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   1016          
   1017            /* Enable the complementary PWM output  */
   1018            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   1019          
   1020            /* Enable the Main Output */
   1021            __HAL_TIM_MOE_ENABLE(htim);
   1022          
   1023            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1024            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1025            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1026            {
   1027              __HAL_TIM_ENABLE(htim);
   1028            }
   1029          
   1030            /* Return function status */
   1031            return HAL_OK;
   1032          }
   1033          
   1034          /**
   1035            * @brief  Stops the PWM signal generation in interrupt mode on the
   1036            *         complementary output.
   1037            * @param  htim TIM handle
   1038            * @param  Channel TIM Channel to be disabled
   1039            *          This parameter can be one of the following values:
   1040            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1041            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1042            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1043            * @retval HAL status
   1044            */
   1045          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1046          {
   1047            uint32_t tmpccer;
   1048          
   1049            /* Check the parameters */
   1050            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1051          
   1052            switch (Channel)
   1053            {
   1054              case TIM_CHANNEL_1:
   1055              {
   1056                /* Disable the TIM Capture/Compare 1 interrupt */
   1057                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1058                break;
   1059              }
   1060          
   1061              case TIM_CHANNEL_2:
   1062              {
   1063                /* Disable the TIM Capture/Compare 2 interrupt */
   1064                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1065                break;
   1066              }
   1067          
   1068              case TIM_CHANNEL_3:
   1069              {
   1070                /* Disable the TIM Capture/Compare 3 interrupt */
   1071                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1072                break;
   1073              }
   1074          
   1075              default:
   1076                break;
   1077            }
   1078          
   1079            /* Disable the complementary PWM output  */
   1080            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   1081          
   1082            /* Disable the TIM Break interrupt (only if no more channel is active) */
   1083            tmpccer = htim->Instance->CCER;
   1084            if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
   1085            {
   1086              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   1087            }
   1088          
   1089            /* Disable the Main Output */
   1090            __HAL_TIM_MOE_DISABLE(htim);
   1091          
   1092            /* Disable the Peripheral */
   1093            __HAL_TIM_DISABLE(htim);
   1094          
   1095            /* Return function status */
   1096            return HAL_OK;
   1097          }
   1098          
   1099          /**
   1100            * @brief  Starts the TIM PWM signal generation in DMA mode on the
   1101            *         complementary output
   1102            * @param  htim TIM handle
   1103            * @param  Channel TIM Channel to be enabled
   1104            *          This parameter can be one of the following values:
   1105            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1106            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1107            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1108            * @param  pData The source Buffer address.
   1109            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1110            * @retval HAL status
   1111            */
   1112          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1113          {
   1114            uint32_t tmpsmcr;
   1115          
   1116            /* Check the parameters */
   1117            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1118          
   1119            if (htim->State == HAL_TIM_STATE_BUSY)
   1120            {
   1121              return HAL_BUSY;
   1122            }
   1123            else if (htim->State == HAL_TIM_STATE_READY)
   1124            {
   1125              if (((uint32_t)pData == 0U) && (Length > 0U))
   1126              {
   1127                return HAL_ERROR;
   1128              }
   1129              else
   1130              {
   1131                htim->State = HAL_TIM_STATE_BUSY;
   1132              }
   1133            }
   1134            else
   1135            {
   1136              /* nothing to do */
   1137            }
   1138            switch (Channel)
   1139            {
   1140              case TIM_CHANNEL_1:
   1141              {
   1142                /* Set the DMA compare callbacks */
   1143                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1144                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1145          
   1146                /* Set the DMA error callback */
   1147                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   1148          
   1149                /* Enable the DMA stream */
   1150                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   1151                {
   1152                  return HAL_ERROR;
   1153                }
   1154                /* Enable the TIM Capture/Compare 1 DMA request */
   1155                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1156                break;
   1157              }
   1158          
   1159              case TIM_CHANNEL_2:
   1160              {
   1161                /* Set the DMA compare callbacks */
   1162                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1163                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1164          
   1165                /* Set the DMA error callback */
   1166                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   1167          
   1168                /* Enable the DMA stream */
   1169                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   1170                {
   1171                  return HAL_ERROR;
   1172                }
   1173                /* Enable the TIM Capture/Compare 2 DMA request */
   1174                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1175                break;
   1176              }
   1177          
   1178              case TIM_CHANNEL_3:
   1179              {
   1180                /* Set the DMA compare callbacks */
   1181                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1182                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1183          
   1184                /* Set the DMA error callback */
   1185                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1186          
   1187                /* Enable the DMA stream */
   1188                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   1189                {
   1190                  return HAL_ERROR;
   1191                }
   1192                /* Enable the TIM Capture/Compare 3 DMA request */
   1193                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1194                break;
   1195              }
   1196          
   1197              default:
   1198                break;
   1199            }
   1200          
   1201            /* Enable the complementary PWM output  */
   1202            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   1203          
   1204            /* Enable the Main Output */
   1205            __HAL_TIM_MOE_ENABLE(htim);
   1206          
   1207            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1208            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1209            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1210            {
   1211              __HAL_TIM_ENABLE(htim);
   1212            }
   1213          
   1214            /* Return function status */
   1215            return HAL_OK;
   1216          }
   1217          
   1218          /**
   1219            * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary
   1220            *         output
   1221            * @param  htim TIM handle
   1222            * @param  Channel TIM Channel to be disabled
   1223            *          This parameter can be one of the following values:
   1224            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1225            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1226            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1227            * @retval HAL status
   1228            */
   1229          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1230          {
   1231            /* Check the parameters */
   1232            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1233          
   1234            switch (Channel)
   1235            {
   1236              case TIM_CHANNEL_1:
   1237              {
   1238                /* Disable the TIM Capture/Compare 1 DMA request */
   1239                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1240                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   1241                break;
   1242              }
   1243          
   1244              case TIM_CHANNEL_2:
   1245              {
   1246                /* Disable the TIM Capture/Compare 2 DMA request */
   1247                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1248                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   1249                break;
   1250              }
   1251          
   1252              case TIM_CHANNEL_3:
   1253              {
   1254                /* Disable the TIM Capture/Compare 3 DMA request */
   1255                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1256                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   1257                break;
   1258              }
   1259          
   1260              default:
   1261                break;
   1262            }
   1263          
   1264            /* Disable the complementary PWM output */
   1265            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   1266          
   1267            /* Disable the Main Output */
   1268            __HAL_TIM_MOE_DISABLE(htim);
   1269          
   1270            /* Disable the Peripheral */
   1271            __HAL_TIM_DISABLE(htim);
   1272          
   1273            /* Change the htim state */
   1274            htim->State = HAL_TIM_STATE_READY;
   1275          
   1276            /* Return function status */
   1277            return HAL_OK;
   1278          }
   1279          
   1280          /**
   1281            * @}
   1282            */
   1283          
   1284          /** @defgroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions
   1285            * @brief    Timer Complementary One Pulse functions
   1286            *
   1287          @verbatim
   1288            ==============================================================================
   1289                          ##### Timer Complementary One Pulse functions #####
   1290            ==============================================================================
   1291            [..]
   1292              This section provides functions allowing to:
   1293              (+) Start the Complementary One Pulse generation.
   1294              (+) Stop the Complementary One Pulse.
   1295              (+) Start the Complementary One Pulse and enable interrupts.
   1296              (+) Stop the Complementary One Pulse and disable interrupts.
   1297          
   1298          @endverbatim
   1299            * @{
   1300            */
   1301          
   1302          /**
   1303            * @brief  Starts the TIM One Pulse signal generation on the complementary
   1304            *         output.
   1305            * @param  htim TIM One Pulse handle
   1306            * @param  OutputChannel TIM Channel to be enabled
   1307            *          This parameter can be one of the following values:
   1308            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1309            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1310            * @retval HAL status
   1311            */
   1312          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1313          {
   1314            /* Check the parameters */
   1315            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1316          
   1317            /* Enable the complementary One Pulse output */
   1318            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
   1319          
   1320            /* Enable the Main Output */
   1321            __HAL_TIM_MOE_ENABLE(htim);
   1322          
   1323            /* Return function status */
   1324            return HAL_OK;
   1325          }
   1326          
   1327          /**
   1328            * @brief  Stops the TIM One Pulse signal generation on the complementary
   1329            *         output.
   1330            * @param  htim TIM One Pulse handle
   1331            * @param  OutputChannel TIM Channel to be disabled
   1332            *          This parameter can be one of the following values:
   1333            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1334            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1335            * @retval HAL status
   1336            */
   1337          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1338          {
   1339          
   1340            /* Check the parameters */
   1341            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1342          
   1343            /* Disable the complementary One Pulse output */
   1344            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   1345          
   1346            /* Disable the Main Output */
   1347            __HAL_TIM_MOE_DISABLE(htim);
   1348          
   1349            /* Disable the Peripheral */
   1350            __HAL_TIM_DISABLE(htim);
   1351          
   1352            /* Return function status */
   1353            return HAL_OK;
   1354          }
   1355          
   1356          /**
   1357            * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the
   1358            *         complementary channel.
   1359            * @param  htim TIM One Pulse handle
   1360            * @param  OutputChannel TIM Channel to be enabled
   1361            *          This parameter can be one of the following values:
   1362            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1363            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1364            * @retval HAL status
   1365            */
   1366          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1367          {
   1368            /* Check the parameters */
   1369            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1370          
   1371            /* Enable the TIM Capture/Compare 1 interrupt */
   1372            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1373          
   1374            /* Enable the TIM Capture/Compare 2 interrupt */
   1375            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1376          
   1377            /* Enable the complementary One Pulse output */
   1378            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
   1379          
   1380            /* Enable the Main Output */
   1381            __HAL_TIM_MOE_ENABLE(htim);
   1382          
   1383            /* Return function status */
   1384            return HAL_OK;
   1385          }
   1386          
   1387          /**
   1388            * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the
   1389            *         complementary channel.
   1390            * @param  htim TIM One Pulse handle
   1391            * @param  OutputChannel TIM Channel to be disabled
   1392            *          This parameter can be one of the following values:
   1393            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1394            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1395            * @retval HAL status
   1396            */
   1397          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1398          {
   1399            /* Check the parameters */
   1400            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1401          
   1402            /* Disable the TIM Capture/Compare 1 interrupt */
   1403            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1404          
   1405            /* Disable the TIM Capture/Compare 2 interrupt */
   1406            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1407          
   1408            /* Disable the complementary One Pulse output */
   1409            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   1410          
   1411            /* Disable the Main Output */
   1412            __HAL_TIM_MOE_DISABLE(htim);
   1413          
   1414            /* Disable the Peripheral */
   1415            __HAL_TIM_DISABLE(htim);
   1416          
   1417            /* Return function status */
   1418            return HAL_OK;
   1419          }
   1420          
   1421          /**
   1422            * @}
   1423            */
   1424          
   1425          /** @defgroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions
   1426            * @brief    Peripheral Control functions
   1427            *
   1428          @verbatim
   1429            ==============================================================================
   1430                              ##### Peripheral Control functions #####
   1431            ==============================================================================
   1432            [..]
   1433              This section provides functions allowing to:
   1434                (+) Configure the commutation event in case of use of the Hall sensor interface.
   1435                (+) Configure Output channels for OC and PWM mode.
   1436          
   1437                (+) Configure Complementary channels, break features and dead time.
   1438                (+) Configure Master synchronization.
   1439                (+) Configure timer remapping capabilities.
   1440          
   1441          @endverbatim
   1442            * @{
   1443            */
   1444          
   1445          /**
   1446            * @brief  Configure the TIM commutation event sequence.
   1447            * @note  This function is mandatory to use the commutation event in order to
   1448            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1449            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1450            *        configured in Hall sensor interface, this interface Timer will generate the
   1451            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1452            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1453            * @param  htim TIM handle
   1454            * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1455            *          This parameter can be one of the following values:
   1456            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1457            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1458            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1459            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1460            *            @arg TIM_TS_NONE: No trigger is needed
   1461            * @param  CommutationSource the Commutation Event source
   1462            *          This parameter can be one of the following values:
   1463            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1464            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1465            * @retval HAL status
   1466            */
   1467          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
   1468                                                        uint32_t  CommutationSource)
   1469          {
   1470            /* Check the parameters */
   1471            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1472            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1473          
   1474            __HAL_LOCK(htim);
   1475          
   1476            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1477                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   1478            {
   1479              /* Select the Input trigger */
   1480              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   1481              htim->Instance->SMCR |= InputTrigger;
   1482            }
   1483          
   1484            /* Select the Capture Compare preload feature */
   1485            htim->Instance->CR2 |= TIM_CR2_CCPC;
   1486            /* Select the Commutation event source */
   1487            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   1488            htim->Instance->CR2 |= CommutationSource;
   1489          
   1490            /* Disable Commutation Interrupt */
   1491            __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
   1492          
   1493            /* Disable Commutation DMA request */
   1494            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
   1495          
   1496            __HAL_UNLOCK(htim);
   1497          
   1498            return HAL_OK;
   1499          }
   1500          
   1501          /**
   1502            * @brief  Configure the TIM commutation event sequence with interrupt.
   1503            * @note  This function is mandatory to use the commutation event in order to
   1504            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1505            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1506            *        configured in Hall sensor interface, this interface Timer will generate the
   1507            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1508            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1509            * @param  htim TIM handle
   1510            * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1511            *          This parameter can be one of the following values:
   1512            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1513            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1514            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1515            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1516            *            @arg TIM_TS_NONE: No trigger is needed
   1517            * @param  CommutationSource the Commutation Event source
   1518            *          This parameter can be one of the following values:
   1519            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1520            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1521            * @retval HAL status
   1522            */
   1523          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
   1524                                                           uint32_t  CommutationSource)
   1525          {
   1526            /* Check the parameters */
   1527            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1528            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1529          
   1530            __HAL_LOCK(htim);
   1531          
   1532            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1533                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   1534            {
   1535              /* Select the Input trigger */
   1536              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   1537              htim->Instance->SMCR |= InputTrigger;
   1538            }
   1539          
   1540            /* Select the Capture Compare preload feature */
   1541            htim->Instance->CR2 |= TIM_CR2_CCPC;
   1542            /* Select the Commutation event source */
   1543            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   1544            htim->Instance->CR2 |= CommutationSource;
   1545          
   1546            /* Disable Commutation DMA request */
   1547            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
   1548          
   1549            /* Enable the Commutation Interrupt */
   1550            __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
   1551          
   1552            __HAL_UNLOCK(htim);
   1553          
   1554            return HAL_OK;
   1555          }
   1556          
   1557          /**
   1558            * @brief  Configure the TIM commutation event sequence with DMA.
   1559            * @note  This function is mandatory to use the commutation event in order to
   1560            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1561            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1562            *        configured in Hall sensor interface, this interface Timer will generate the
   1563            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1564            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1565            * @note  The user should configure the DMA in his own software, in This function only the COMDE bit is set
   1566            * @param  htim TIM handle
   1567            * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1568            *          This parameter can be one of the following values:
   1569            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1570            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1571            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1572            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1573            *            @arg TIM_TS_NONE: No trigger is needed
   1574            * @param  CommutationSource the Commutation Event source
   1575            *          This parameter can be one of the following values:
   1576            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1577            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1578            * @retval HAL status
   1579            */
   1580          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
   1581                                                            uint32_t  CommutationSource)
   1582          {
   1583            /* Check the parameters */
   1584            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1585            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1586          
   1587            __HAL_LOCK(htim);
   1588          
   1589            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1590                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   1591            {
   1592              /* Select the Input trigger */
   1593              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   1594              htim->Instance->SMCR |= InputTrigger;
   1595            }
   1596          
   1597            /* Select the Capture Compare preload feature */
   1598            htim->Instance->CR2 |= TIM_CR2_CCPC;
   1599            /* Select the Commutation event source */
   1600            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   1601            htim->Instance->CR2 |= CommutationSource;
   1602          
   1603            /* Enable the Commutation DMA Request */
   1604            /* Set the DMA Commutation Callback */
   1605            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
   1606            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback = TIMEx_DMACommutationHalfCplt;
   1607            /* Set the DMA error callback */
   1608            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
   1609          
   1610            /* Disable Commutation Interrupt */
   1611            __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
   1612          
   1613            /* Enable the Commutation DMA Request */
   1614            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
   1615          
   1616            __HAL_UNLOCK(htim);
   1617          
   1618            return HAL_OK;
   1619          }
   1620          
   1621          /**
   1622            * @brief  Configures the TIM in master mode.
   1623            * @param  htim TIM handle.
   1624            * @param  sMasterConfig pointer to a TIM_MasterConfigTypeDef structure that
   1625            *         contains the selected trigger output (TRGO) and the Master/Slave
   1626            *         mode.
   1627            * @retval HAL status
   1628            */
   1629          HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
   1630                                                                  TIM_MasterConfigTypeDef *sMasterConfig)
   1631          {
   1632            uint32_t tmpcr2;
   1633            uint32_t tmpsmcr;
   1634          
   1635            /* Check the parameters */
   1636            assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   1637            assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   1638            assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   1639          
   1640            /* Check input state */
   1641            __HAL_LOCK(htim);
   1642          
   1643            /* Change the handler state */
   1644            htim->State = HAL_TIM_STATE_BUSY;
   1645          
   1646            /* Get the TIMx CR2 register value */
   1647            tmpcr2 = htim->Instance->CR2;
   1648          
   1649            /* Get the TIMx SMCR register value */
   1650            tmpsmcr = htim->Instance->SMCR;
   1651          
   1652            /* Reset the MMS Bits */
   1653            tmpcr2 &= ~TIM_CR2_MMS;
   1654            /* Select the TRGO source */
   1655            tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
   1656          
   1657            /* Update TIMx CR2 */
   1658            htim->Instance->CR2 = tmpcr2;
   1659          
   1660            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   1661            {
   1662              /* Reset the MSM Bit */
   1663              tmpsmcr &= ~TIM_SMCR_MSM;
   1664              /* Set master mode */
   1665              tmpsmcr |= sMasterConfig->MasterSlaveMode;
   1666          
   1667              /* Update TIMx SMCR */
   1668              htim->Instance->SMCR = tmpsmcr;
   1669            }
   1670          
   1671            /* Change the htim state */
   1672            htim->State = HAL_TIM_STATE_READY;
   1673          
   1674            __HAL_UNLOCK(htim);
   1675          
   1676            return HAL_OK;
   1677          }
   1678          
   1679          /**
   1680            * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   1681            *         and the AOE(automatic output enable).
   1682            * @param  htim TIM handle
   1683            * @param  sBreakDeadTimeConfig pointer to a TIM_ConfigBreakDeadConfigTypeDef structure that
   1684            *         contains the BDTR Register configuration  information for the TIM peripheral.
   1685            * @note   Interrupts can be generated when an active level is detected on the
   1686            *         break input, the break 2 input or the system break input. Break
   1687            *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.
   1688            * @retval HAL status
   1689            */
   1690          HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
   1691                                                          TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
   1692          {
   1693            /* Keep this variable initialized to 0 as it is used to configure BDTR register */
   1694            uint32_t tmpbdtr = 0U;
   1695          
   1696            /* Check the parameters */
   1697            assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
   1698            assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
   1699            assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
   1700            assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
   1701            assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
   1702            assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
   1703            assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
   1704            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
   1705          
   1706            /* Check input state */
   1707            __HAL_LOCK(htim);
   1708          
   1709            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   1710               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   1711          
   1712            /* Set the BDTR bits */
   1713            MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
   1714            MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
   1715            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
   1716            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
   1717            MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
   1718            MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
   1719            MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
   1720          
   1721          
   1722            /* Set TIMx_BDTR */
   1723            htim->Instance->BDTR = tmpbdtr;
   1724          
   1725            __HAL_UNLOCK(htim);
   1726          
   1727            return HAL_OK;
   1728          }
   1729          
   1730          /**
   1731            * @brief  Configures the TIMx Remapping input capabilities.
   1732            * @param  htim TIM handle.
   1733            * @param  Remap specifies the TIM remapping source.
   1734            *         For TIM1, the parameter can have the following values:                   (**)
   1735            *           @arg TIM_TIM1_TIM3_TRGO:  TIM1 ITR2 is connected to TIM3 TRGO
   1736            *           @arg TIM_TIM1_LPTIM:      TIM1 ITR2 is connected to LPTIM1 output
   1737            *
   1738            *         For TIM2, the parameter can have the following values:                   (**)
   1739            *           @arg TIM_TIM2_TIM8_TRGO:  TIM2 ITR1 is connected to TIM8 TRGO          (*)
   1740            *           @arg TIM_TIM2_ETH_PTP:    TIM2 ITR1 is connected to PTP trigger output (*)
   1741            *           @arg TIM_TIM2_USBFS_SOF:  TIM2 ITR1 is connected to OTG FS SOF
   1742            *           @arg TIM_TIM2_USBHS_SOF:  TIM2 ITR1 is connected to OTG FS SOF
   1743            *
   1744            *         For TIM5, the parameter can have the following values:
   1745            *           @arg TIM_TIM5_GPIO:       TIM5 TI4 is connected to GPIO
   1746            *           @arg TIM_TIM5_LSI:        TIM5 TI4 is connected to LSI
   1747            *           @arg TIM_TIM5_LSE:        TIM5 TI4 is connected to LSE
   1748            *           @arg TIM_TIM5_RTC:        TIM5 TI4 is connected to the RTC wakeup interrupt
   1749            *           @arg TIM_TIM5_TIM3_TRGO:  TIM5 ITR1 is connected to TIM3 TRGO          (*)
   1750            *           @arg TIM_TIM5_LPTIM:      TIM5 ITR1 is connected to LPTIM1 output      (*)
   1751            *
   1752            *         For TIM9, the parameter can have the following values:                   (**)
   1753            *           @arg TIM_TIM9_TIM3_TRGO:  TIM9 ITR1 is connected to TIM3 TRGO
   1754            *           @arg TIM_TIM9_LPTIM:      TIM9 ITR1 is connected to LPTIM1 output
   1755            *
   1756            *         For TIM11, the parameter can have the following values:
   1757            *           @arg TIM_TIM11_GPIO:     TIM11 TI1 is connected to GPIO
   1758            *           @arg TIM_TIM11_HSE:      TIM11 TI1 is connected to HSE_RTC clock
   1759            *           @arg TIM_TIM11_SPDIFRX:  TIM11 TI1 is connected to SPDIFRX_FRAME_SYNC  (*)
   1760            *
   1761            *         (*)  Value not defined in all devices. \n
   1762            *         (**) Register not available in all devices.
   1763            *
   1764            * @retval HAL status
   1765            */
   1766          HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)
   1767          {
   1768            __HAL_LOCK(htim);
   1769          
   1770            /* Check parameters */
   1771            assert_param(IS_TIM_REMAP(htim->Instance, Remap));
   1772          
   1773          #if defined(LPTIM_OR_TIM1_ITR2_RMP) && defined(LPTIM_OR_TIM5_ITR1_RMP) && defined(LPTIM_OR_TIM5_ITR1_RMP)
   1774            if ((Remap & LPTIM_REMAP_MASK) == LPTIM_REMAP_MASK)
   1775            {
   1776              /* Connect TIMx internal trigger to LPTIM1 output */
   1777              __HAL_RCC_LPTIM1_CLK_ENABLE();
   1778              MODIFY_REG(LPTIM1->OR,
   1779                         (LPTIM_OR_TIM1_ITR2_RMP | LPTIM_OR_TIM5_ITR1_RMP | LPTIM_OR_TIM9_ITR1_RMP),
   1780                         Remap & ~(LPTIM_REMAP_MASK));
   1781            }
   1782            else
   1783            {
   1784              /* Set the Timer remapping configuration */
   1785              WRITE_REG(htim->Instance->OR, Remap);
   1786            }
   1787          #else
   1788            /* Set the Timer remapping configuration */
   1789            WRITE_REG(htim->Instance->OR, Remap);
   1790          #endif /* LPTIM_OR_TIM1_ITR2_RMP &&  LPTIM_OR_TIM5_ITR1_RMP && LPTIM_OR_TIM5_ITR1_RMP */
   1791          
   1792            __HAL_UNLOCK(htim);
   1793          
   1794            return HAL_OK;
   1795          }
   1796          
   1797          /**
   1798            * @}
   1799            */
   1800          
   1801          /** @defgroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions
   1802            * @brief    Extended Callbacks functions
   1803            *
   1804          @verbatim
   1805            ==============================================================================
   1806                              ##### Extended Callbacks functions #####
   1807            ==============================================================================
   1808            [..]
   1809              This section provides Extended TIM callback functions:
   1810              (+) Timer Commutation callback
   1811              (+) Timer Break callback
   1812          
   1813          @endverbatim
   1814            * @{
   1815            */
   1816          
   1817          /**
   1818            * @brief  Hall commutation changed callback in non-blocking mode
   1819            * @param  htim TIM handle
   1820            * @retval None
   1821            */
   1822          __weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
   1823          {
   1824            /* Prevent unused argument(s) compilation warning */
   1825            UNUSED(htim);
   1826          
   1827            /* NOTE : This function should not be modified, when the callback is needed,
   1828                      the HAL_TIMEx_CommutCallback could be implemented in the user file
   1829             */
   1830          }
   1831          /**
   1832            * @brief  Hall commutation changed half complete callback in non-blocking mode
   1833            * @param  htim TIM handle
   1834            * @retval None
   1835            */
   1836          __weak void HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim)
   1837          {
   1838            /* Prevent unused argument(s) compilation warning */
   1839            UNUSED(htim);
   1840          
   1841            /* NOTE : This function should not be modified, when the callback is needed,
   1842                      the HAL_TIMEx_CommutHalfCpltCallback could be implemented in the user file
   1843             */
   1844          }
   1845          
   1846          /**
   1847            * @brief  Hall Break detection callback in non-blocking mode
   1848            * @param  htim TIM handle
   1849            * @retval None
   1850            */
   1851          __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
   1852          {
   1853            /* Prevent unused argument(s) compilation warning */
   1854            UNUSED(htim);
   1855          
   1856            /* NOTE : This function should not be modified, when the callback is needed,
   1857                      the HAL_TIMEx_BreakCallback could be implemented in the user file
   1858             */
   1859          }
   1860          /**
   1861            * @}
   1862            */
   1863          
   1864          /** @defgroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions
   1865            * @brief    Extended Peripheral State functions
   1866            *
   1867          @verbatim
   1868            ==============================================================================
   1869                          ##### Extended Peripheral State functions #####
   1870            ==============================================================================
   1871            [..]
   1872              This subsection permits to get in run-time the status of the peripheral
   1873              and the data flow.
   1874          
   1875          @endverbatim
   1876            * @{
   1877            */
   1878          
   1879          /**
   1880            * @brief  Return the TIM Hall Sensor interface handle state.
   1881            * @param  htim TIM Hall Sensor handle
   1882            * @retval HAL state
   1883            */
   1884          HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
   1885          {
   1886            return htim->State;
   1887          }
   1888          
   1889          /**
   1890            * @}
   1891            */
   1892          
   1893          /**
   1894            * @}
   1895            */
   1896          
   1897          /* Private functions ---------------------------------------------------------*/
   1898          /** @defgroup TIMEx_Private_Functions TIMEx Private Functions
   1899            * @{
   1900            */
   1901          
   1902          /**
   1903            * @brief  TIM DMA Commutation callback.
   1904            * @param  hdma pointer to DMA handle.
   1905            * @retval None
   1906            */
   1907          void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
   1908          {
   1909            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   1910          
   1911            /* Change the htim state */
   1912            htim->State = HAL_TIM_STATE_READY;
   1913          
   1914          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1915            htim->CommutationCallback(htim);
   1916          #else
   1917            HAL_TIMEx_CommutCallback(htim);
   1918          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1919          }
   1920          
   1921          /**
   1922            * @brief  TIM DMA Commutation half complete callback.
   1923            * @param  hdma pointer to DMA handle.
   1924            * @retval None
   1925            */
   1926          void TIMEx_DMACommutationHalfCplt(DMA_HandleTypeDef *hdma)
   1927          {
   1928            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   1929          
   1930            /* Change the htim state */
   1931            htim->State = HAL_TIM_STATE_READY;
   1932          
   1933          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1934            htim->CommutationHalfCpltCallback(htim);
   1935          #else
   1936            HAL_TIMEx_CommutHalfCpltCallback(htim);
   1937          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1938          }
   1939          
   1940          
   1941          /**
   1942            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1943            * @param  TIMx to select the TIM peripheral
   1944            * @param  Channel specifies the TIM Channel
   1945            *          This parameter can be one of the following values:
   1946            *            @arg TIM_CHANNEL_1: TIM Channel 1
   1947            *            @arg TIM_CHANNEL_2: TIM Channel 2
   1948            *            @arg TIM_CHANNEL_3: TIM Channel 3
   1949            * @param  ChannelNState specifies the TIM Channel CCxNE bit new state.
   1950            *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.
   1951            * @retval None
   1952            */
   1953          static void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState)
   1954          {
   1955            uint32_t tmp;
   1956          
   1957            tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   1958          
   1959            /* Reset the CCxNE Bit */
   1960            TIMx->CCER &=  ~tmp;
   1961          
   1962            /* Set or reset the CCxNE Bit */
   1963            TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   1964          }
   1965          /**
   1966            * @}
   1967            */
   1968          
   1969          #endif /* HAL_TIM_MODULE_ENABLED */
   1970          /**
   1971            * @}
   1972            */
   1973          
   1974          /**
   1975            * @}
   1976            */
   1977          
   1978          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/


 
 
 0 bytes of memory

Errors: none
Warnings: none

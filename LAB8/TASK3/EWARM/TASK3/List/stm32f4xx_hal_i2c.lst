###############################################################################
#
# IAR ANSI C/C++ Compiler V8.42.1.233/W32 for ARM         07/Mar/2020  11:46:57
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\mohit\Desktop\Microapps
#        projects\LAB8\TASK3\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2c.c
#    Command line      =
#        -f C:\Users\mohit\AppData\Local\Temp\EW697.tmp
#        ("C:\Users\mohit\Desktop\Microapps
#        projects\LAB8\TASK3\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2c.c"
#        -D USE_HAL_DRIVER -D STM32F429xx -lC "C:\Users\mohit\Desktop\Microapps
#        projects\LAB8\TASK3\EWARM\TASK3\List" -o
#        "C:\Users\mohit\Desktop\Microapps projects\LAB8\TASK3\EWARM\TASK3\Obj"
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I "C:\Users\mohit\Desktop\Microapps
#        projects\LAB8\TASK3\EWARM/../Inc\" -I
#        "C:\Users\mohit\Desktop\Microapps
#        projects\LAB8\TASK3\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\" -I
#        "C:\Users\mohit\Desktop\Microapps
#        projects\LAB8\TASK3\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\"
#        -I "C:\Users\mohit\Desktop\Microapps
#        projects\LAB8\TASK3\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\"
#        -I "C:\Users\mohit\Desktop\Microapps
#        projects\LAB8\TASK3\EWARM/../Drivers/CMSIS/Include\" -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\mohit\Desktop\Microapps
#        projects\LAB8\TASK3\EWARM\TASK3\List\stm32f4xx_hal_i2c.lst
#    Object file       =
#        C:\Users\mohit\Desktop\Microapps
#        projects\LAB8\TASK3\EWARM\TASK3\Obj\stm32f4xx_hal_i2c.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#      __size_limit    =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Users\mohit\Desktop\Microapps projects\LAB8\TASK3\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_i2c.c
      4            * @author  MCD Application Team
      5            * @brief   I2C HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral State, Mode and Error functions
     11            *
     12            @verbatim
     13            ==============================================================================
     14                                  ##### How to use this driver #####
     15            ==============================================================================
     16            [..]
     17              The I2C HAL driver can be used as follows:
     18          
     19              (#) Declare a I2C_HandleTypeDef handle structure, for example:
     20                  I2C_HandleTypeDef  hi2c;
     21          
     22              (#)Initialize the I2C low level resources by implementing the @ref HAL_I2C_MspInit() API:
     23                  (##) Enable the I2Cx interface clock
     24                  (##) I2C pins configuration
     25                      (+++) Enable the clock for the I2C GPIOs
     26                      (+++) Configure I2C pins as alternate function open-drain
     27                  (##) NVIC configuration if you need to use interrupt process
     28                      (+++) Configure the I2Cx interrupt priority
     29                      (+++) Enable the NVIC I2C IRQ Channel
     30                  (##) DMA Configuration if you need to use DMA process
     31                      (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive stream
     32                      (+++) Enable the DMAx interface clock using
     33                      (+++) Configure the DMA handle parameters
     34                      (+++) Configure the DMA Tx or Rx stream
     35                      (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
     36                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on
     37                            the DMA Tx or Rx stream
     38          
     39              (#) Configure the Communication Speed, Duty cycle, Addressing mode, Own Address1,
     40                  Dual Addressing mode, Own Address2, General call and Nostretch mode in the hi2c Init structure.
     41          
     42              (#) Initialize the I2C registers by calling the @ref HAL_I2C_Init(), configures also the low level Hardware
     43                  (GPIO, CLOCK, NVIC...etc) by calling the customized @ref HAL_I2C_MspInit() API.
     44          
     45              (#) To check if target device is ready for communication, use the function @ref HAL_I2C_IsDeviceReady()
     46          
     47              (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :
     48          
     49              *** Polling mode IO operation ***
     50              =================================
     51              [..]
     52                (+) Transmit in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Transmit()
     53                (+) Receive in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Receive()
     54                (+) Transmit in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Transmit()
     55                (+) Receive in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Receive()
     56          
     57              *** Polling mode IO MEM operation ***
     58              =====================================
     59              [..]
     60                (+) Write an amount of data in blocking mode to a specific memory address using @ref HAL_I2C_Mem_Write()
     61                (+) Read an amount of data in blocking mode from a specific memory address using @ref HAL_I2C_Mem_Read()
     62          
     63          
     64              *** Interrupt mode IO operation ***
     65              ===================================
     66              [..]
     67                (+) Transmit in master mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Transmit_IT()
     68                (+) At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
     69                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
     70                (+) Receive in master mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Receive_IT()
     71                (+) At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
     72                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
     73                (+) Transmit in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Transmit_IT()
     74                (+) At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
     75                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
     76                (+) Receive in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Receive_IT()
     77                (+) At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
     78                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
     79                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
     80                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
     81                (+) Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
     82                (+) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
     83                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
     84          
     85              *** Interrupt mode or DMA mode IO sequential operation ***
     86              ==========================================================
     87              [..]
     88                (@) These interfaces allow to manage a sequential transfer with a repeated start condition
     89                    when a direction change during transfer
     90              [..]
     91                (+) A specific option field manage the different steps of a sequential transfer
     92                (+) Option field values are defined through @ref I2C_XferOptions_definition and are listed below:
     93                (++) I2C_FIRST_AND_LAST_FRAME: No sequential usage, functionnal is same as associated interfaces in no sequential mode
     94                (++) I2C_FIRST_FRAME: Sequential usage, this option allow to manage a sequence with start condition, address
     95                                      and data to transfer without a final stop condition
     96                (++) I2C_FIRST_AND_NEXT_FRAME: Sequential usage (Master only), this option allow to manage a sequence with start condition, address
     97                                      and data to transfer without a final stop condition, an then permit a call the same master sequential interface
     98                                      several times (like @ref HAL_I2C_Master_Seq_Transmit_IT() then @ref HAL_I2C_Master_Seq_Transmit_IT()
     99                                      or @ref HAL_I2C_Master_Seq_Transmit_DMA() then @ref HAL_I2C_Master_Seq_Transmit_DMA())
    100                (++) I2C_NEXT_FRAME: Sequential usage, this option allow to manage a sequence with a restart condition, address
    101                                      and with new data to transfer if the direction change or manage only the new data to transfer
    102                                      if no direction change and without a final stop condition in both cases
    103                (++) I2C_LAST_FRAME: Sequential usage, this option allow to manage a sequance with a restart condition, address
    104                                      and with new data to transfer if the direction change or manage only the new data to transfer
    105                                      if no direction change and with a final stop condition in both cases
    106                (++) I2C_LAST_FRAME_NO_STOP: Sequential usage (Master only), this option allow to manage a restart condition after several call of the same master sequential
    107                                      interface several times (link with option I2C_FIRST_AND_NEXT_FRAME).
    108                                      Usage can, transfer several bytes one by one using HAL_I2C_Master_Seq_Transmit_IT(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    109                                        or HAL_I2C_Master_Seq_Receive_IT(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    110                                        or HAL_I2C_Master_Seq_Transmit_DMA(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    111                                        or HAL_I2C_Master_Seq_Receive_DMA(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME).
    112                                      Then usage of this option I2C_LAST_FRAME_NO_STOP at the last Transmit or Receive sequence permit to call the oposite interface Receive or Transmit
    113                                        without stopping the communication and so generate a restart condition.
    114                (++) I2C_OTHER_FRAME: Sequential usage (Master only), this option allow to manage a restart condition after each call of the same master sequential
    115                                      interface.
    116                                      Usage can, transfer several bytes one by one with a restart with slave address between each bytes using HAL_I2C_Master_Seq_Transmit_IT(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    117                                        or HAL_I2C_Master_Seq_Receive_IT(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    118                                        or HAL_I2C_Master_Seq_Transmit_DMA(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    119                                        or HAL_I2C_Master_Seq_Receive_DMA(option I2C_FIRST_FRAME then I2C_OTHER_FRAME).
    120                                      Then usage of this option I2C_OTHER_AND_LAST_FRAME at the last frame to help automatic generation of STOP condition.
    121          
    122                (+) Differents sequential I2C interfaces are listed below:
    123                (++) Sequential transmit in master I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Seq_Transmit_IT()
    124                      or using @ref HAL_I2C_Master_Seq_Transmit_DMA()
    125                (+++) At transmission end of current frame transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
    126                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
    127                (++) Sequential receive in master I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Seq_Receive_IT()
    128                      or using @ref HAL_I2C_Master_Seq_Receive_DMA()
    129                (+++) At reception end of current frame transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
    130                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
    131                (++) Abort a master IT or DMA I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
    132                (+++) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
    133                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
    134                (++) Enable/disable the Address listen mode in slave I2C mode using @ref HAL_I2C_EnableListen_IT() @ref HAL_I2C_DisableListen_IT()
    135                (+++) When address slave I2C match, @ref HAL_I2C_AddrCallback() is executed and user can
    136                     add his own code to check the Address Match Code and the transmission direction request by master (Write/Read).
    137                (+++) At Listen mode end @ref HAL_I2C_ListenCpltCallback() is executed and user can
    138                     add his own code by customization of function pointer @ref HAL_I2C_ListenCpltCallback()
    139                (++) Sequential transmit in slave I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Seq_Transmit_IT()
    140                      or using @ref HAL_I2C_Slave_Seq_Transmit_DMA()
    141                (+++) At transmission end of current frame transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
    142                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
    143                (++) Sequential receive in slave I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Seq_Receive_IT()
    144                      or using @ref HAL_I2C_Slave_Seq_Receive_DMA()
    145                (+++) At reception end of current frame transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
    146                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
    147                (++) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    148                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    149          
    150              *** Interrupt mode IO MEM operation ***
    151              =======================================
    152              [..]
    153                (+) Write an amount of data in non-blocking mode with Interrupt to a specific memory address using
    154                    @ref HAL_I2C_Mem_Write_IT()
    155                (+) At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can
    156                     add his own code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
    157                (+) Read an amount of data in non-blocking mode with Interrupt from a specific memory address using
    158                    @ref HAL_I2C_Mem_Read_IT()
    159                (+) At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can
    160                     add his own code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
    161                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    162                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    163          
    164              *** DMA mode IO operation ***
    165              ==============================
    166              [..]
    167                (+) Transmit in master mode an amount of data in non-blocking mode (DMA) using
    168                    @ref HAL_I2C_Master_Transmit_DMA()
    169                (+) At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
    170                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
    171                (+) Receive in master mode an amount of data in non-blocking mode (DMA) using
    172                    @ref HAL_I2C_Master_Receive_DMA()
    173                (+) At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
    174                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
    175                (+) Transmit in slave mode an amount of data in non-blocking mode (DMA) using
    176                    @ref HAL_I2C_Slave_Transmit_DMA()
    177                (+) At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
    178                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
    179                (+) Receive in slave mode an amount of data in non-blocking mode (DMA) using
    180                    @ref HAL_I2C_Slave_Receive_DMA()
    181                (+) At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
    182                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
    183                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    184                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    185                (+) Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
    186                (+) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
    187                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
    188          
    189              *** DMA mode IO MEM operation ***
    190              =================================
    191              [..]
    192                (+) Write an amount of data in non-blocking mode with DMA to a specific memory address using
    193                    @ref HAL_I2C_Mem_Write_DMA()
    194                (+) At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can
    195                     add his own code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
    196                (+) Read an amount of data in non-blocking mode with DMA from a specific memory address using
    197                    @ref HAL_I2C_Mem_Read_DMA()
    198                (+) At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can
    199                     add his own code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
    200                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    201                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    202          
    203          
    204               *** I2C HAL driver macros list ***
    205               ==================================
    206               [..]
    207                 Below the list of most used macros in I2C HAL driver.
    208          
    209                (+) @ref __HAL_I2C_ENABLE:     Enable the I2C peripheral
    210                (+) @ref __HAL_I2C_DISABLE:    Disable the I2C peripheral
    211                (+) @ref __HAL_I2C_GET_FLAG:   Checks whether the specified I2C flag is set or not
    212                (+) @ref __HAL_I2C_CLEAR_FLAG: Clear the specified I2C pending flag
    213                (+) @ref __HAL_I2C_ENABLE_IT:  Enable the specified I2C interrupt
    214                (+) @ref __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt
    215          
    216               *** Callback registration ***
    217               =============================================
    218              [..]
    219               The compilation flag USE_HAL_I2C_REGISTER_CALLBACKS when set to 1
    220               allows the user to configure dynamically the driver callbacks.
    221               Use Functions @ref HAL_I2C_RegisterCallback() or @ref HAL_I2C_RegisterAddrCallback()
    222               to register an interrupt callback.
    223              [..]
    224               Function @ref HAL_I2C_RegisterCallback() allows to register following callbacks:
    225                 (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
    226                 (+) MasterRxCpltCallback : callback for Master reception end of transfer.
    227                 (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
    228                 (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
    229                 (+) ListenCpltCallback   : callback for end of listen mode.
    230                 (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
    231                 (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
    232                 (+) ErrorCallback        : callback for error detection.
    233                 (+) AbortCpltCallback    : callback for abort completion process.
    234                 (+) MspInitCallback      : callback for Msp Init.
    235                 (+) MspDeInitCallback    : callback for Msp DeInit.
    236               This function takes as parameters the HAL peripheral handle, the Callback ID
    237               and a pointer to the user callback function.
    238              [..]
    239               For specific callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_RegisterAddrCallback().
    240              [..]
    241               Use function @ref HAL_I2C_UnRegisterCallback to reset a callback to the default
    242               weak function.
    243               @ref HAL_I2C_UnRegisterCallback takes as parameters the HAL peripheral handle,
    244               and the Callback ID.
    245               This function allows to reset following callbacks:
    246                 (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
    247                 (+) MasterRxCpltCallback : callback for Master reception end of transfer.
    248                 (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
    249                 (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
    250                 (+) ListenCpltCallback   : callback for end of listen mode.
    251                 (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
    252                 (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
    253                 (+) ErrorCallback        : callback for error detection.
    254                 (+) AbortCpltCallback    : callback for abort completion process.
    255                 (+) MspInitCallback      : callback for Msp Init.
    256                 (+) MspDeInitCallback    : callback for Msp DeInit.
    257              [..]
    258               For callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_UnRegisterAddrCallback().
    259              [..]
    260               By default, after the @ref HAL_I2C_Init() and when the state is @ref HAL_I2C_STATE_RESET
    261               all callbacks are set to the corresponding weak functions:
    262               examples @ref HAL_I2C_MasterTxCpltCallback(), @ref HAL_I2C_MasterRxCpltCallback().
    263               Exception done for MspInit and MspDeInit functions that are
    264               reset to the legacy weak functions in the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit() only when
    265               these callbacks are null (not registered beforehand).
    266               If MspInit or MspDeInit are not null, the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit()
    267               keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
    268              [..]
    269               Callbacks can be registered/unregistered in @ref HAL_I2C_STATE_READY state only.
    270               Exception done MspInit/MspDeInit functions that can be registered/unregistered
    271               in @ref HAL_I2C_STATE_READY or @ref HAL_I2C_STATE_RESET state,
    272               thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    273               Then, the user first registers the MspInit/MspDeInit user callbacks
    274               using @ref HAL_I2C_RegisterCallback() before calling @ref HAL_I2C_DeInit()
    275               or @ref HAL_I2C_Init() function.
    276              [..]
    277               When the compilation flag USE_HAL_I2C_REGISTER_CALLBACKS is set to 0 or
    278               not defined, the callback registration feature is not available and all callbacks
    279               are set to the corresponding weak functions.
    280          
    281          
    282          
    283               [..]
    284                 (@) You can refer to the I2C HAL driver header file for more useful macros
    285          
    286            @endverbatim
    287            ******************************************************************************
    288            * @attention
    289            *
    290            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    291            * All rights reserved.</center></h2>
    292            *
    293            * This software component is licensed by ST under BSD 3-Clause license,
    294            * the "License"; You may not use this file except in compliance with the
    295            * License. You may obtain a copy of the License at:
    296            *                        opensource.org/licenses/BSD-3-Clause
    297            *
    298            ******************************************************************************
    299            */
    300          
    301          /* Includes ------------------------------------------------------------------*/
    302          #include "stm32f4xx_hal.h"
    303          
    304          /** @addtogroup STM32F4xx_HAL_Driver
    305            * @{
    306            */
    307          
    308          /** @defgroup I2C I2C
    309            * @brief I2C HAL module driver
    310            * @{
    311            */
    312          
    313          #ifdef HAL_I2C_MODULE_ENABLED
    314          
    315          /* Private typedef -----------------------------------------------------------*/
    316          /* Private define ------------------------------------------------------------*/
    317          /** @addtogroup I2C_Private_Define
    318            * @{
    319            */
    320          #define I2C_TIMEOUT_FLAG          35U         /*!< Timeout 35 ms             */
    321          #define I2C_TIMEOUT_BUSY_FLAG     25U         /*!< Timeout 25 ms             */
    322          #define I2C_NO_OPTION_FRAME       0xFFFF0000U /*!< XferOptions default value */
    323          
    324          /* Private define for @ref PreviousState usage */
    325          #define I2C_STATE_MSK             ((uint32_t)((uint32_t)((uint32_t)HAL_I2C_STATE_BUSY_TX | (uint32_t)HAL_I2C_STATE_BUSY_RX) & (uint32_t)(~((uint32_t)HAL_I2C_STATE_READY)))) /*!< Mask State define, keep only RX and TX bits            */
    326          #define I2C_STATE_NONE            ((uint32_t)(HAL_I2C_MODE_NONE))                                                        /*!< Default Value                                          */
    327          #define I2C_STATE_MASTER_BUSY_TX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))            /*!< Master Busy TX, combinaison of State LSB and Mode enum */
    328          #define I2C_STATE_MASTER_BUSY_RX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))            /*!< Master Busy RX, combinaison of State LSB and Mode enum */
    329          #define I2C_STATE_SLAVE_BUSY_TX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))             /*!< Slave Busy TX, combinaison of State LSB and Mode enum  */
    330          #define I2C_STATE_SLAVE_BUSY_RX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))             /*!< Slave Busy RX, combinaison of State LSB and Mode enum  */
    331          
    332          /**
    333            * @}
    334            */
    335          
    336          /* Private macro -------------------------------------------------------------*/
    337          /* Private variables ---------------------------------------------------------*/
    338          /* Private function prototypes -----------------------------------------------*/
    339          
    340          /** @defgroup I2C_Private_Functions I2C Private Functions
    341            * @{
    342            */
    343          /* Private functions to handle DMA transfer */
    344          static void I2C_DMAXferCplt(DMA_HandleTypeDef *hdma);
    345          static void I2C_DMAError(DMA_HandleTypeDef *hdma);
    346          static void I2C_DMAAbort(DMA_HandleTypeDef *hdma);
    347          
    348          static void I2C_ITError(I2C_HandleTypeDef *hi2c);
    349          
    350          static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart);
    351          static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart);
    352          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart);
    353          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart);
    354          
    355          /* Private functions to handle flags during polling transfer */
    356          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart);
    357          static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart);
    358          static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    359          static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    360          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    361          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    362          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c);
    363          
    364          /* Private functions for I2C transfer IRQ handler */
    365          static void I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c);
    366          static void I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c);
    367          static void I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c);
    368          static void I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c);
    369          static void I2C_Master_SB(I2C_HandleTypeDef *hi2c);
    370          static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c);
    371          static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c);
    372          
    373          static void I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c);
    374          static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c);
    375          static void I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c);
    376          static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c);
    377          static void I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c, uint32_t IT2Flags);
    378          static void I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c);
    379          static void I2C_Slave_AF(I2C_HandleTypeDef *hi2c);
    380          
    381          static void I2C_MemoryTransmit_TXE_BTF(I2C_HandleTypeDef *hi2c);
    382          
    383          /* Private function to Convert Specific options */
    384          static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c);
    385          /**
    386            * @}
    387            */
    388          
    389          /* Exported functions --------------------------------------------------------*/
    390          
    391          /** @defgroup I2C_Exported_Functions I2C Exported Functions
    392            * @{
    393            */
    394          
    395          /** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
    396           *  @brief    Initialization and Configuration functions
    397           *
    398          @verbatim
    399           ===============================================================================
    400                        ##### Initialization and de-initialization functions #####
    401           ===============================================================================
    402              [..]  This subsection provides a set of functions allowing to initialize and
    403                    deinitialize the I2Cx peripheral:
    404          
    405                (+) User must Implement HAL_I2C_MspInit() function in which he configures
    406                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC).
    407          
    408                (+) Call the function HAL_I2C_Init() to configure the selected device with
    409                    the selected configuration:
    410                  (++) Communication Speed
    411                  (++) Duty cycle
    412                  (++) Addressing mode
    413                  (++) Own Address 1
    414                  (++) Dual Addressing mode
    415                  (++) Own Address 2
    416                  (++) General call mode
    417                  (++) Nostretch mode
    418          
    419                (+) Call the function HAL_I2C_DeInit() to restore the default configuration
    420                    of the selected I2Cx peripheral.
    421          
    422          @endverbatim
    423            * @{
    424            */
    425          
    426          /**
    427            * @brief  Initializes the I2C according to the specified parameters
    428            *         in the I2C_InitTypeDef and initialize the associated handle.
    429            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    430            *                the configuration information for the specified I2C.
    431            * @retval HAL status
    432            */

   \                                 In section .text, align 2, keep-with-next
    433          HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
    434          {
   \                     HAL_I2C_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    435            uint32_t freqrange;
    436            uint32_t pclk1;
    437          
    438            /* Check the I2C handle allocation */
    439            if (hi2c == NULL)
   \        0x4   0xD025             BEQ.N    ??HAL_I2C_Init_0
    440            {
    441              return HAL_ERROR;
    442            }
    443          
    444            /* Check the parameters */
    445            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    446            assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
    447            assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
    448            assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    449            assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    450            assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    451            assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    452            assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    453            assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    454          
    455            if (hi2c->State == HAL_I2C_STATE_RESET)
   \        0x6   0xF104 0x053C      ADD      R5,R4,#+60
   \        0xA   0x7869             LDRB     R1,[R5, #+1]
   \        0xC   0xB921             CBNZ.N   R1,??HAL_I2C_Init_1
    456            {
    457              /* Allocate lock resource and initialize it */
    458              hi2c->Lock = HAL_UNLOCKED;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x7028             STRB     R0,[R5, #+0]
    459          
    460          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    461              /* Init the I2C Callback settings */
    462              hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
    463              hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
    464              hi2c->SlaveTxCpltCallback  = HAL_I2C_SlaveTxCpltCallback;  /* Legacy weak SlaveTxCpltCallback  */
    465              hi2c->SlaveRxCpltCallback  = HAL_I2C_SlaveRxCpltCallback;  /* Legacy weak SlaveRxCpltCallback  */
    466              hi2c->ListenCpltCallback   = HAL_I2C_ListenCpltCallback;   /* Legacy weak ListenCpltCallback   */
    467              hi2c->MemTxCpltCallback    = HAL_I2C_MemTxCpltCallback;    /* Legacy weak MemTxCpltCallback    */
    468              hi2c->MemRxCpltCallback    = HAL_I2C_MemRxCpltCallback;    /* Legacy weak MemRxCpltCallback    */
    469              hi2c->ErrorCallback        = HAL_I2C_ErrorCallback;        /* Legacy weak ErrorCallback        */
    470              hi2c->AbortCpltCallback    = HAL_I2C_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
    471              hi2c->AddrCallback         = HAL_I2C_AddrCallback;         /* Legacy weak AddrCallback         */
    472          
    473              if (hi2c->MspInitCallback == NULL)
    474              {
    475                hi2c->MspInitCallback = HAL_I2C_MspInit; /* Legacy weak MspInit  */
    476              }
    477          
    478              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    479              hi2c->MspInitCallback(hi2c);
    480          #else
    481              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    482              HAL_I2C_MspInit(hi2c);
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x....'....        BL       HAL_I2C_MspInit
    483          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    484            }
    485          
    486            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_Init_1: (+1)
   \       0x18   0x2124             MOVS     R1,#+36
   \       0x1A   0x7069             STRB     R1,[R5, #+1]
    487          
    488            /* Disable the selected I2C peripheral */
    489            __HAL_I2C_DISABLE(hi2c);
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6802             LDR      R2,[R0, #+0]
   \       0x20   0x0852             LSRS     R2,R2,#+1
   \       0x22   0x0052             LSLS     R2,R2,#+1
   \       0x24   0x6002             STR      R2,[R0, #+0]
    490          
    491            /*Reset I2C*/
    492            hi2c->Instance->CR1 |= I2C_CR1_SWRST;
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6801             LDR      R1,[R0, #+0]
   \       0x2A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \       0x2E   0x6001             STR      R1,[R0, #+0]
    493            hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6802             LDR      R2,[R0, #+0]
   \       0x34   0xF422 0x4200      BIC      R2,R2,#0x8000
   \       0x38   0x6002             STR      R2,[R0, #+0]
    494          
    495            /* Get PCLK1 frequency */
    496            pclk1 = HAL_RCC_GetPCLK1Freq();
   \       0x3A   0x....'....        BL       HAL_RCC_GetPCLK1Freq
   \       0x3E   0x4601             MOV      R1,R0
    497          
    498            /* Check the minimum allowed PCLK1 frequency */
    499            if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
   \       0x40   0x6860             LDR      R0,[R4, #+4]
   \       0x42   0x....'....        LDR.W    R2,??DataTable14  ;; 0x186a1
   \       0x46   0x4290             CMP      R0,R2
   \       0x48   0xD205             BCS.N    ??HAL_I2C_Init_2
   \       0x4A   0x....'....        LDR.W    R3,??DataTable14_1  ;; 0x1e8480
   \       0x4E   0x4299             CMP      R1,R3
   \       0x50   0xD205             BCS.N    ??HAL_I2C_Init_3
    500            {
    501              return HAL_ERROR;
   \                     ??HAL_I2C_Init_0: (+1)
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xBDF2             POP      {R1,R4-R7,PC}
    502            }
   \                     ??HAL_I2C_Init_2: (+1)
   \       0x56   0x....'....        LDR.W    R0,??DataTable14_2  ;; 0x3d0900
   \       0x5A   0x4281             CMP      R1,R0
   \       0x5C   0xD3F9             BCC.N    ??HAL_I2C_Init_0
    503          
    504            /* Calculate frequency range */
    505            freqrange = I2C_FREQRANGE(pclk1);
    506          
    507            /*---------------------------- I2Cx CR2 Configuration ----------------------*/
    508            /* Configure I2Cx: Frequency range */
    509            MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
   \                     ??HAL_I2C_Init_3: (+1)
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x....'....        LDR.W    R3,??DataTable14_3  ;; 0xf4240
   \       0x64   0x6846             LDR      R6,[R0, #+4]
   \       0x66   0xFBB1 0xF3F3      UDIV     R3,R1,R3
   \       0x6A   0x09B6             LSRS     R6,R6,#+6
   \       0x6C   0xEA43 0x1686      ORR      R6,R3,R6, LSL #+6
   \       0x70   0x6046             STR      R6,[R0, #+4]
    510          
    511            /*---------------------------- I2Cx TRISE Configuration --------------------*/
    512            /* Configure I2Cx: Rise Time */
    513            MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
   \       0x72   0x6826             LDR      R6,[R4, #+0]
   \       0x74   0x6A37             LDR      R7,[R6, #+32]
   \       0x76   0x6860             LDR      R0,[R4, #+4]
   \       0x78   0x4290             CMP      R0,R2
   \       0x7A   0xD306             BCC.N    ??HAL_I2C_Init_4
   \       0x7C   0xF44F 0x7096      MOV      R0,#+300
   \       0x80   0x4343             MULS     R3,R0,R3
   \       0x82   0xF44F 0x707A      MOV      R0,#+1000
   \       0x86   0xFBB3 0xF3F0      UDIV     R3,R3,R0
   \                     ??HAL_I2C_Init_4: (+1)
   \       0x8A   0x1C5B             ADDS     R3,R3,#+1
   \       0x8C   0x09BF             LSRS     R7,R7,#+6
   \       0x8E   0xEA43 0x1387      ORR      R3,R3,R7, LSL #+6
   \       0x92   0x6233             STR      R3,[R6, #+32]
    514          
    515            /*---------------------------- I2Cx CCR Configuration ----------------------*/
    516            /* Configure I2Cx: Speed */
    517            MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
   \       0x94   0x1E49             SUBS     R1,R1,#+1
   \       0x96   0x6823             LDR      R3,[R4, #+0]
   \       0x98   0x69DE             LDR      R6,[R3, #+28]
   \       0x9A   0x6867             LDR      R7,[R4, #+4]
   \       0x9C   0x4297             CMP      R7,R2
   \       0x9E   0xD206             BCS.N    ??HAL_I2C_Init_5
   \       0xA0   0x007F             LSLS     R7,R7,#+1
   \       0xA2   0x....'....        BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_183: (+1)
   \       0xA6   0x2904             CMP      R1,#+4
   \       0xA8   0xD213             BCS.N    ??HAL_I2C_Init_6
   \       0xAA   0x2104             MOVS     R1,#+4
   \       0xAC   0xE011             B.N      ??HAL_I2C_Init_6
   \                     ??HAL_I2C_Init_5: (+1)
   \       0xAE   0x68A0             LDR      R0,[R4, #+8]
   \       0xB0   0xB920             CBNZ.N   R0,??HAL_I2C_Init_7
   \       0xB2   0xEB07 0x0747      ADD      R7,R7,R7, LSL #+1
   \       0xB6   0x....'....        BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_184: (+1)
   \       0xBA   0xE005             B.N      ??HAL_I2C_Init_8
   \                     ??HAL_I2C_Init_7: (+1)
   \       0xBC   0x2019             MOVS     R0,#+25
   \       0xBE   0x4347             MULS     R7,R0,R7
   \       0xC0   0x....'....        BL       ?Subroutine63
   \                     ??CrossCallReturnLabel_185: (+1)
   \       0xC4   0xF441 0x4180      ORR      R1,R1,#0x4000
   \                     ??HAL_I2C_Init_8: (+1)
   \       0xC8   0x0508             LSLS     R0,R1,#+20
   \       0xCA   0xBF0C             ITE      EQ
   \       0xCC   0x2101             MOVEQ    R1,#+1
   \       0xCE   0xF441 0x4100      ORRNE    R1,R1,#0x8000
   \                     ??HAL_I2C_Init_6: (+1)
   \       0xD2   0x....'....        LDR.W    R0,??DataTable14_4  ;; 0xffff3000
   \       0xD6   0x4006             ANDS     R6,R0,R6
   \       0xD8   0x430E             ORRS     R6,R1,R6
   \       0xDA   0x61DE             STR      R6,[R3, #+28]
    518          
    519            /*---------------------------- I2Cx CR1 Configuration ----------------------*/
    520            /* Configure I2Cx: Generalcall and NoStretch mode */
    521            MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
   \       0xDC   0x6822             LDR      R2,[R4, #+0]
   \       0xDE   0x6813             LDR      R3,[R2, #+0]
   \       0xE0   0x69E1             LDR      R1,[R4, #+28]
   \       0xE2   0x6A20             LDR      R0,[R4, #+32]
   \       0xE4   0xF023 0x03C0      BIC      R3,R3,#0xC0
   \       0xE8   0x430B             ORRS     R3,R1,R3
   \       0xEA   0x4303             ORRS     R3,R0,R3
   \       0xEC   0x6013             STR      R3,[R2, #+0]
    522          
    523            /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
    524            /* Configure I2Cx: Own Address1 and addressing mode */
    525            MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
   \       0xEE   0x6822             LDR      R2,[R4, #+0]
   \       0xF0   0x....'....        LDR.W    R0,??DataTable14_5  ;; 0xffff7c00
   \       0xF4   0x6893             LDR      R3,[R2, #+8]
   \       0xF6   0x6921             LDR      R1,[R4, #+16]
   \       0xF8   0x4003             ANDS     R3,R0,R3
   \       0xFA   0x68E0             LDR      R0,[R4, #+12]
   \       0xFC   0x430B             ORRS     R3,R1,R3
   \       0xFE   0x4303             ORRS     R3,R0,R3
   \      0x100   0x6093             STR      R3,[R2, #+8]
    526          
    527            /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
    528            /* Configure I2Cx: Dual mode and Own Address2 */
    529            MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
   \      0x102   0x6821             LDR      R1,[R4, #+0]
   \      0x104   0x68CA             LDR      R2,[R1, #+12]
   \      0x106   0x69A3             LDR      R3,[R4, #+24]
   \      0x108   0x6960             LDR      R0,[R4, #+20]
   \      0x10A   0x0A12             LSRS     R2,R2,#+8
   \      0x10C   0x4303             ORRS     R3,R0,R3
   \      0x10E   0xEA43 0x2202      ORR      R2,R3,R2, LSL #+8
   \      0x112   0x60CA             STR      R2,[R1, #+12]
    530          
    531            /* Enable the selected I2C peripheral */
    532            __HAL_I2C_ENABLE(hi2c);
   \      0x114   0x6820             LDR      R0,[R4, #+0]
   \      0x116   0x6801             LDR      R1,[R0, #+0]
   \      0x118   0xF041 0x0101      ORR      R1,R1,#0x1
   \      0x11C   0x6001             STR      R1,[R0, #+0]
    533          
    534            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \      0x11E   0x2000             MOVS     R0,#+0
   \      0x120   0x6068             STR      R0,[R5, #+4]
    535            hi2c->State = HAL_I2C_STATE_READY;
   \      0x122   0x2120             MOVS     R1,#+32
   \      0x124   0x7069             STRB     R1,[R5, #+1]
    536            hi2c->PreviousState = I2C_STATE_NONE;
   \      0x126   0x6320             STR      R0,[R4, #+48]
    537            hi2c->Mode = HAL_I2C_MODE_NONE;
   \      0x128   0x70A8             STRB     R0,[R5, #+2]
    538          
    539            return HAL_OK;
   \      0x12A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    540          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine63: (+1)
   \        0x0   0xFBB1 0xF1F7      UDIV     R1,R1,R7
   \        0x4   0x1C49             ADDS     R1,R1,#+1
   \        0x6   0xF3C1 0x010B      UBFX     R1,R1,#+0,#+12
   \        0xA   0x4770             BX       LR
    541          
    542          /**
    543            * @brief  DeInitialize the I2C peripheral.
    544            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    545            *         the configuration information for the specified I2C.
    546            * @retval HAL status
    547            */

   \                                 In section .text, align 2, keep-with-next
    548          HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
    549          {
   \                     HAL_I2C_DeInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    550            /* Check the I2C handle allocation */
    551            if (hi2c == NULL)
   \        0x4   0xD101             BNE.N    ??HAL_I2C_DeInit_0
    552            {
    553              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
    554            }
    555          
    556            /* Check the parameters */
    557            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    558          
    559            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_DeInit_0: (+1)
   \        0xA   0xF104 0x053C      ADD      R5,R4,#+60
   \        0xE   0x2024             MOVS     R0,#+36
   \       0x10   0x7068             STRB     R0,[R5, #+1]
    560          
    561            /* Disable the I2C Peripheral Clock */
    562            __HAL_I2C_DISABLE(hi2c);
   \       0x12   0x....'....        BL       ?Subroutine38
    563          
    564          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    565            if (hi2c->MspDeInitCallback == NULL)
    566            {
    567              hi2c->MspDeInitCallback = HAL_I2C_MspDeInit; /* Legacy weak MspDeInit  */
    568            }
    569          
    570            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    571            hi2c->MspDeInitCallback(hi2c);
    572          #else
    573            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    574            HAL_I2C_MspDeInit(hi2c);
   \                     ??CrossCallReturnLabel_105: (+1)
   \       0x16   0x....'....        BL       HAL_I2C_MspDeInit
    575          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    576          
    577            hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6068             STR      R0,[R5, #+4]
    578            hi2c->State         = HAL_I2C_STATE_RESET;
   \       0x1E   0x7068             STRB     R0,[R5, #+1]
    579            hi2c->PreviousState = I2C_STATE_NONE;
   \       0x20   0x6320             STR      R0,[R4, #+48]
    580            hi2c->Mode          = HAL_I2C_MODE_NONE;
   \       0x22   0x70A8             STRB     R0,[R5, #+2]
    581          
    582            /* Release Lock */
    583            __HAL_UNLOCK(hi2c);
   \       0x24   0x7028             STRB     R0,[R5, #+0]
    584          
    585            return HAL_OK;
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    586          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine38: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x0849             LSRS     R1,R1,#+1
   \        0x6   0x0049             LSLS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x4770             BX       LR
    587          
    588          /**
    589            * @brief  Initialize the I2C MSP.
    590            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    591            *         the configuration information for the specified I2C.
    592            * @retval None
    593            */

   \                                 In section .text, align 2
    594          __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
    595          {
    596            /* Prevent unused argument(s) compilation warning */
    597            UNUSED(hi2c);
    598          
    599            /* NOTE : This function should not be modified, when the callback is needed,
    600                      the HAL_I2C_MspInit could be implemented in the user file
    601             */
    602          }
   \                     HAL_I2C_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    603          
    604          /**
    605            * @brief  DeInitialize the I2C MSP.
    606            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    607            *         the configuration information for the specified I2C.
    608            * @retval None
    609            */

   \                                 In section .text, align 2
    610          __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
    611          {
    612            /* Prevent unused argument(s) compilation warning */
    613            UNUSED(hi2c);
    614          
    615            /* NOTE : This function should not be modified, when the callback is needed,
    616                      the HAL_I2C_MspDeInit could be implemented in the user file
    617             */
    618          }
   \                     HAL_I2C_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    619          
    620          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    621          /**
    622            * @brief  Register a User I2C Callback
    623            *         To be used instead of the weak predefined callback
    624            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    625            *                the configuration information for the specified I2C.
    626            * @param  CallbackID ID of the callback to be registered
    627            *         This parameter can be one of the following values:
    628            *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
    629            *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
    630            *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
    631            *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
    632            *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
    633            *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
    634            *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
    635            *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
    636            *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
    637            *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
    638            *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
    639            * @param  pCallback pointer to the Callback function
    640            * @retval HAL status
    641            */
    642          HAL_StatusTypeDef HAL_I2C_RegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID, pI2C_CallbackTypeDef pCallback)
    643          {
    644            HAL_StatusTypeDef status = HAL_OK;
    645          
    646            if (pCallback == NULL)
    647            {
    648              /* Update the error code */
    649              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    650          
    651              return HAL_ERROR;
    652            }
    653            /* Process locked */
    654            __HAL_LOCK(hi2c);
    655          
    656            if (HAL_I2C_STATE_READY == hi2c->State)
    657            {
    658              switch (CallbackID)
    659              {
    660                case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :
    661                  hi2c->MasterTxCpltCallback = pCallback;
    662                  break;
    663          
    664                case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :
    665                  hi2c->MasterRxCpltCallback = pCallback;
    666                  break;
    667          
    668                case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :
    669                  hi2c->SlaveTxCpltCallback = pCallback;
    670                  break;
    671          
    672                case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :
    673                  hi2c->SlaveRxCpltCallback = pCallback;
    674                  break;
    675          
    676                case HAL_I2C_LISTEN_COMPLETE_CB_ID :
    677                  hi2c->ListenCpltCallback = pCallback;
    678                  break;
    679          
    680                case HAL_I2C_MEM_TX_COMPLETE_CB_ID :
    681                  hi2c->MemTxCpltCallback = pCallback;
    682                  break;
    683          
    684                case HAL_I2C_MEM_RX_COMPLETE_CB_ID :
    685                  hi2c->MemRxCpltCallback = pCallback;
    686                  break;
    687          
    688                case HAL_I2C_ERROR_CB_ID :
    689                  hi2c->ErrorCallback = pCallback;
    690                  break;
    691          
    692                case HAL_I2C_ABORT_CB_ID :
    693                  hi2c->AbortCpltCallback = pCallback;
    694                  break;
    695          
    696                case HAL_I2C_MSPINIT_CB_ID :
    697                  hi2c->MspInitCallback = pCallback;
    698                  break;
    699          
    700                case HAL_I2C_MSPDEINIT_CB_ID :
    701                  hi2c->MspDeInitCallback = pCallback;
    702                  break;
    703          
    704                default :
    705                  /* Update the error code */
    706                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    707          
    708                  /* Return error status */
    709                  status =  HAL_ERROR;
    710                  break;
    711              }
    712            }
    713            else if (HAL_I2C_STATE_RESET == hi2c->State)
    714            {
    715              switch (CallbackID)
    716              {
    717                case HAL_I2C_MSPINIT_CB_ID :
    718                  hi2c->MspInitCallback = pCallback;
    719                  break;
    720          
    721                case HAL_I2C_MSPDEINIT_CB_ID :
    722                  hi2c->MspDeInitCallback = pCallback;
    723                  break;
    724          
    725                default :
    726                  /* Update the error code */
    727                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    728          
    729                  /* Return error status */
    730                  status =  HAL_ERROR;
    731                  break;
    732              }
    733            }
    734            else
    735            {
    736              /* Update the error code */
    737              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    738          
    739              /* Return error status */
    740              status =  HAL_ERROR;
    741            }
    742          
    743            /* Release Lock */
    744            __HAL_UNLOCK(hi2c);
    745            return status;
    746          }
    747          
    748          /**
    749            * @brief  Unregister an I2C Callback
    750            *         I2C callback is redirected to the weak predefined callback
    751            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    752            *                the configuration information for the specified I2C.
    753            * @param  CallbackID ID of the callback to be unregistered
    754            *         This parameter can be one of the following values:
    755            *         This parameter can be one of the following values:
    756            *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
    757            *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
    758            *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
    759            *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
    760            *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
    761            *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
    762            *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
    763            *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
    764            *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
    765            *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
    766            *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
    767            * @retval HAL status
    768            */
    769          HAL_StatusTypeDef HAL_I2C_UnRegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID)
    770          {
    771            HAL_StatusTypeDef status = HAL_OK;
    772          
    773            /* Process locked */
    774            __HAL_LOCK(hi2c);
    775          
    776            if (HAL_I2C_STATE_READY == hi2c->State)
    777            {
    778              switch (CallbackID)
    779              {
    780                case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :
    781                  hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
    782                  break;
    783          
    784                case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :
    785                  hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
    786                  break;
    787          
    788                case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :
    789                  hi2c->SlaveTxCpltCallback = HAL_I2C_SlaveTxCpltCallback;   /* Legacy weak SlaveTxCpltCallback  */
    790                  break;
    791          
    792                case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :
    793                  hi2c->SlaveRxCpltCallback = HAL_I2C_SlaveRxCpltCallback;   /* Legacy weak SlaveRxCpltCallback  */
    794                  break;
    795          
    796                case HAL_I2C_LISTEN_COMPLETE_CB_ID :
    797                  hi2c->ListenCpltCallback = HAL_I2C_ListenCpltCallback;     /* Legacy weak ListenCpltCallback   */
    798                  break;
    799          
    800                case HAL_I2C_MEM_TX_COMPLETE_CB_ID :
    801                  hi2c->MemTxCpltCallback = HAL_I2C_MemTxCpltCallback;       /* Legacy weak MemTxCpltCallback    */
    802                  break;
    803          
    804                case HAL_I2C_MEM_RX_COMPLETE_CB_ID :
    805                  hi2c->MemRxCpltCallback = HAL_I2C_MemRxCpltCallback;       /* Legacy weak MemRxCpltCallback    */
    806                  break;
    807          
    808                case HAL_I2C_ERROR_CB_ID :
    809                  hi2c->ErrorCallback = HAL_I2C_ErrorCallback;               /* Legacy weak ErrorCallback        */
    810                  break;
    811          
    812                case HAL_I2C_ABORT_CB_ID :
    813                  hi2c->AbortCpltCallback = HAL_I2C_AbortCpltCallback;       /* Legacy weak AbortCpltCallback    */
    814                  break;
    815          
    816                case HAL_I2C_MSPINIT_CB_ID :
    817                  hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */
    818                  break;
    819          
    820                case HAL_I2C_MSPDEINIT_CB_ID :
    821                  hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */
    822                  break;
    823          
    824                default :
    825                  /* Update the error code */
    826                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    827          
    828                  /* Return error status */
    829                  status =  HAL_ERROR;
    830                  break;
    831              }
    832            }
    833            else if (HAL_I2C_STATE_RESET == hi2c->State)
    834            {
    835              switch (CallbackID)
    836              {
    837                case HAL_I2C_MSPINIT_CB_ID :
    838                  hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */
    839                  break;
    840          
    841                case HAL_I2C_MSPDEINIT_CB_ID :
    842                  hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */
    843                  break;
    844          
    845                default :
    846                  /* Update the error code */
    847                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    848          
    849                  /* Return error status */
    850                  status =  HAL_ERROR;
    851                  break;
    852              }
    853            }
    854            else
    855            {
    856              /* Update the error code */
    857              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    858          
    859              /* Return error status */
    860              status =  HAL_ERROR;
    861            }
    862          
    863            /* Release Lock */
    864            __HAL_UNLOCK(hi2c);
    865            return status;
    866          }
    867          
    868          /**
    869            * @brief  Register the Slave Address Match I2C Callback
    870            *         To be used instead of the weak HAL_I2C_AddrCallback() predefined callback
    871            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    872            *                the configuration information for the specified I2C.
    873            * @param  pCallback pointer to the Address Match Callback function
    874            * @retval HAL status
    875            */
    876          HAL_StatusTypeDef HAL_I2C_RegisterAddrCallback(I2C_HandleTypeDef *hi2c, pI2C_AddrCallbackTypeDef pCallback)
    877          {
    878            HAL_StatusTypeDef status = HAL_OK;
    879          
    880            if (pCallback == NULL)
    881            {
    882              /* Update the error code */
    883              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    884          
    885              return HAL_ERROR;
    886            }
    887            /* Process locked */
    888            __HAL_LOCK(hi2c);
    889          
    890            if (HAL_I2C_STATE_READY == hi2c->State)
    891            {
    892              hi2c->AddrCallback = pCallback;
    893            }
    894            else
    895            {
    896              /* Update the error code */
    897              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    898          
    899              /* Return error status */
    900              status =  HAL_ERROR;
    901            }
    902          
    903            /* Release Lock */
    904            __HAL_UNLOCK(hi2c);
    905            return status;
    906          }
    907          
    908          /**
    909            * @brief  UnRegister the Slave Address Match I2C Callback
    910            *         Info Ready I2C Callback is redirected to the weak HAL_I2C_AddrCallback() predefined callback
    911            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    912            *                the configuration information for the specified I2C.
    913            * @retval HAL status
    914            */
    915          HAL_StatusTypeDef HAL_I2C_UnRegisterAddrCallback(I2C_HandleTypeDef *hi2c)
    916          {
    917            HAL_StatusTypeDef status = HAL_OK;
    918          
    919            /* Process locked */
    920            __HAL_LOCK(hi2c);
    921          
    922            if (HAL_I2C_STATE_READY == hi2c->State)
    923            {
    924              hi2c->AddrCallback = HAL_I2C_AddrCallback; /* Legacy weak AddrCallback  */
    925            }
    926            else
    927            {
    928              /* Update the error code */
    929              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    930          
    931              /* Return error status */
    932              status =  HAL_ERROR;
    933            }
    934          
    935            /* Release Lock */
    936            __HAL_UNLOCK(hi2c);
    937            return status;
    938          }
    939          
    940          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    941          
    942          /**
    943            * @}
    944            */
    945          
    946          /** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions
    947           *  @brief   Data transfers functions
    948           *
    949          @verbatim
    950           ===============================================================================
    951                                ##### IO operation functions #####
    952           ===============================================================================
    953              [..]
    954              This subsection provides a set of functions allowing to manage the I2C data
    955              transfers.
    956          
    957              (#) There are two modes of transfer:
    958                 (++) Blocking mode : The communication is performed in the polling mode.
    959                      The status of all data processing is returned by the same function
    960                      after finishing transfer.
    961                 (++) No-Blocking mode : The communication is performed using Interrupts
    962                      or DMA. These functions return the status of the transfer startup.
    963                      The end of the data processing will be indicated through the
    964                      dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when
    965                      using DMA mode.
    966          
    967              (#) Blocking mode functions are :
    968                  (++) HAL_I2C_Master_Transmit()
    969                  (++) HAL_I2C_Master_Receive()
    970                  (++) HAL_I2C_Slave_Transmit()
    971                  (++) HAL_I2C_Slave_Receive()
    972                  (++) HAL_I2C_Mem_Write()
    973                  (++) HAL_I2C_Mem_Read()
    974                  (++) HAL_I2C_IsDeviceReady()
    975          
    976              (#) No-Blocking mode functions with Interrupt are :
    977                  (++) HAL_I2C_Master_Transmit_IT()
    978                  (++) HAL_I2C_Master_Receive_IT()
    979                  (++) HAL_I2C_Slave_Transmit_IT()
    980                  (++) HAL_I2C_Slave_Receive_IT()
    981                  (++) HAL_I2C_Mem_Write_IT()
    982                  (++) HAL_I2C_Mem_Read_IT()
    983                  (++) HAL_I2C_Master_Seq_Transmit_IT()
    984                  (++) HAL_I2C_Master_Seq_Receive_IT()
    985                  (++) HAL_I2C_Slave_Seq_Transmit_IT()
    986                  (++) HAL_I2C_Slave_Seq_Receive_IT()
    987                  (++) HAL_I2C_EnableListen_IT()
    988                  (++) HAL_I2C_DisableListen_IT()
    989                  (++) HAL_I2C_Master_Abort_IT()
    990          
    991              (#) No-Blocking mode functions with DMA are :
    992                  (++) HAL_I2C_Master_Transmit_DMA()
    993                  (++) HAL_I2C_Master_Receive_DMA()
    994                  (++) HAL_I2C_Slave_Transmit_DMA()
    995                  (++) HAL_I2C_Slave_Receive_DMA()
    996                  (++) HAL_I2C_Mem_Write_DMA()
    997                  (++) HAL_I2C_Mem_Read_DMA()
    998                  (++) HAL_I2C_Master_Seq_Transmit_DMA()
    999                  (++) HAL_I2C_Master_Seq_Receive_DMA()
   1000                  (++) HAL_I2C_Slave_Seq_Transmit_DMA()
   1001                  (++) HAL_I2C_Slave_Seq_Receive_DMA()
   1002          
   1003              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
   1004                  (++) HAL_I2C_MasterTxCpltCallback()
   1005                  (++) HAL_I2C_MasterRxCpltCallback()
   1006                  (++) HAL_I2C_SlaveTxCpltCallback()
   1007                  (++) HAL_I2C_SlaveRxCpltCallback()
   1008                  (++) HAL_I2C_MemTxCpltCallback()
   1009                  (++) HAL_I2C_MemRxCpltCallback()
   1010                  (++) HAL_I2C_AddrCallback()
   1011                  (++) HAL_I2C_ListenCpltCallback()
   1012                  (++) HAL_I2C_ErrorCallback()
   1013                  (++) HAL_I2C_AbortCpltCallback()
   1014          
   1015          @endverbatim
   1016            * @{
   1017            */
   1018          
   1019          /**
   1020            * @brief  Transmits in master mode an amount of data in blocking mode.
   1021            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1022            *                the configuration information for the specified I2C.
   1023            * @param  DevAddress Target device address: The device 7 bits address value
   1024            *         in datasheet must be shifted to the left before calling the interface
   1025            * @param  pData Pointer to data buffer
   1026            * @param  Size Amount of data to be sent
   1027            * @param  Timeout Timeout duration
   1028            * @retval HAL status
   1029            */

   \                                 In section .text, align 2, keep-with-next
   1030          HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1031          {
   \                     HAL_I2C_Master_Transmit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x....'....        BL       ??Subroutine76_0
   1032            /* Init tickstart for timeout management*/
   1033            uint32_t tickstart = HAL_GetTick();
   1034          
   1035            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_228: (+1)
   \        0xE   0xF104 0x073C      ADD      R7,R4,#+60
   \       0x12   0x4680             MOV      R8,R0
   \       0x14   0x7878             LDRB     R0,[R7, #+1]
   \       0x16   0x2820             CMP      R0,#+32
   \       0x18   0xD108             BNE.N    ??HAL_I2C_Master_Transmit_0
   1036            {
   1037              /* Wait until BUSY flag is reset */
   1038              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \       0x1A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x1E   0x2319             MOVS     R3,#+25
   \       0x20   0x2201             MOVS     R2,#+1
   \       0x22   0x....'....        LDR.W    R1,??DataTable15  ;; 0x100002
   \       0x26   0x....'....        BL       ??Subroutine25_1
   \                     ??CrossCallReturnLabel_60: (+1)
   \       0x2A   0x2800             CMP      R0,#+0
   \                     ??HAL_I2C_Master_Transmit_0: (+1)
   \       0x2C   0xF040 0x8080      BNE.W    ??HAL_I2C_Master_Transmit_1
   1039              {
   1040                return HAL_BUSY;
   1041              }
   1042          
   1043              /* Process Locked */
   1044              __HAL_LOCK(hi2c);
   \       0x30   0x7838             LDRB     R0,[R7, #+0]
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD07C             BEQ.N    ??HAL_I2C_Master_Transmit_1
   \       0x36   0x2101             MOVS     R1,#+1
   \       0x38   0x7039             STRB     R1,[R7, #+0]
   1045          
   1046              /* Check if the I2C is already enabled */
   1047              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x3A   0x....'....        BL       ?Subroutine30
   1048              {
   1049                /* Enable I2C peripheral */
   1050                __HAL_I2C_ENABLE(hi2c);
   1051              }
   1052          
   1053              /* Disable Pos */
   1054              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   1055          
   1056              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \                     ??CrossCallReturnLabel_83: (+1)
   \       0x3E   0x2021             MOVS     R0,#+33
   \       0x40   0x7078             STRB     R0,[R7, #+1]
   1057              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   \       0x42   0x2110             MOVS     R1,#+16
   \       0x44   0x....'....        BL       ?Subroutine19
   1058              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1059          
   1060              /* Prepare transfer parameters */
   1061              hi2c->pBuffPtr    = pData;
   1062              hi2c->XferCount   = Size;
   1063              hi2c->XferSize    = hi2c->XferCount;
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0x48   0x8520             STRH     R0,[R4, #+40]
   1064              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x4A   0x....'....        LDR.W    R0,??DataTable15_1  ;; 0xffff0000
   \       0x4E   0x62E0             STR      R0,[R4, #+44]
   1065          
   1066              /* Send Slave Address */
   1067              if (I2C_MasterRequestWrite(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
   \       0x50   0x6AE1             LDR      R1,[R4, #+44]
   \       0x52   0x2908             CMP      R1,#+8
   \       0x54   0xBF18             IT       NE
   \       0x56   0x2901             CMPNE    R1,#+1
   \       0x58   0xD004             BEQ.N    ??HAL_I2C_Master_Transmit_2
   \       0x5A   0x4281             CMP      R1,R0
   \       0x5C   0xBF1C             ITT      NE
   \       0x5E   0x6B20             LDRNE    R0,[R4, #+48]
   \       0x60   0x2812             CMPNE    R0,#+18
   \       0x62   0xD101             BNE.N    ??CrossCallReturnLabel_78
   \                     ??HAL_I2C_Master_Transmit_2: (+1)
   \       0x64   0x....'....        BL       ?Subroutine29
   \                     ??CrossCallReturnLabel_78: (+1)
   \       0x68   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x6C   0x2200             MOVS     R2,#+0
   \       0x6E   0x9D08             LDR      R5,[SP, #+32]
   \       0x70   0x462B             MOV      R3,R5
   \       0x72   0x....'....        BL       ??Subroutine25_0
   \                     ??CrossCallReturnLabel_63: (+1)
   \       0x76   0xB138             CBZ.N    R0,??HAL_I2C_Master_Transmit_3
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x6801             LDR      R1,[R0, #+0]
   \       0x7C   0x05CA             LSLS     R2,R1,#+23
   \       0x7E   0xD550             BPL.N    ??CrossCallReturnLabel_92
   \       0x80   0xF44F 0x7000      MOV      R0,#+512
   \       0x84   0x6078             STR      R0,[R7, #+4]
   \       0x86   0xE04C             B.N      ??CrossCallReturnLabel_92
   \                     ??HAL_I2C_Master_Transmit_3: (+1)
   \       0x88   0x6920             LDR      R0,[R4, #+16]
   \       0x8A   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x8E   0xBF08             IT       EQ
   \       0x90   0xF006 0x06FE      ANDEQ    R6,R6,#0xFE
   \       0x94   0xD010             BEQ.N    ??HAL_I2C_Master_Transmit_4
   \       0x96   0x09F1             LSRS     R1,R6,#+7
   \       0x98   0x6820             LDR      R0,[R4, #+0]
   \       0x9A   0xF001 0x0106      AND      R1,R1,#0x6
   \       0x9E   0xF041 0x01F0      ORR      R1,R1,#0xF0
   \       0xA2   0x6101             STR      R1,[R0, #+16]
   \       0xA4   0x4643             MOV      R3,R8
   \       0xA6   0x462A             MOV      R2,R5
   \       0xA8   0x....'....        LDR.W    R1,??DataTable16  ;; 0x10008
   \       0xAC   0x4620             MOV      R0,R4
   \       0xAE   0x....'....        BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD135             BNE.N    ??CrossCallReturnLabel_92
   \       0xB6   0xB2F6             UXTB     R6,R6
   \                     ??HAL_I2C_Master_Transmit_4: (+1)
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x....'....        LDR.W    R1,??DataTable16_1  ;; 0x10002
   \       0xBE   0x6106             STR      R6,[R0, #+16]
   \       0xC0   0x4643             MOV      R3,R8
   \       0xC2   0x462A             MOV      R2,R5
   \       0xC4   0x4620             MOV      R0,R4
   \       0xC6   0x....'....        BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD129             BNE.N    ??CrossCallReturnLabel_92
   1068              {
   1069                return HAL_ERROR;
   1070              }
   1071          
   1072              /* Clear ADDR flag */
   1073              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0xCE   0x9000             STR      R0,[SP, #+0]
   \       0xD0   0x6821             LDR      R1,[R4, #+0]
   \       0xD2   0x694A             LDR      R2,[R1, #+20]
   \       0xD4   0x9200             STR      R2,[SP, #+0]
   \       0xD6   0x6989             LDR      R1,[R1, #+24]
   \       0xD8   0x9100             STR      R1,[SP, #+0]
   \       0xDA   0x9A00             LDR      R2,[SP, #+0]
   1074          
   1075              while (hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Master_Transmit_5: (+1)
   \       0xDC   0x8D20             LDRH     R0,[R4, #+40]
   \       0xDE   0x2800             CMP      R0,#+0
   \       0xE0   0xD021             BEQ.N    ??HAL_I2C_Master_Transmit_6
   1076              {
   1077                /* Wait until TXE flag is set */
   1078                if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \       0xE2   0x4642             MOV      R2,R8
   \       0xE4   0x4629             MOV      R1,R5
   \       0xE6   0x....'....        BL       ??Subroutine27_0
   \                     ??CrossCallReturnLabel_68: (+1)
   \       0xEA   0xB9A8             CBNZ.N   R0,??HAL_I2C_Master_Transmit_7
   1079                {
   1080                  if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   1081                  {
   1082                    /* Generate Stop */
   1083                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   1084                  }
   1085                  return HAL_ERROR;
   1086                }
   1087          
   1088                /* Write data to DR */
   1089                hi2c->Instance->DR = *hi2c->pBuffPtr;
   \       0xEC   0x....'....        BL       ?Subroutine66
   1090          
   1091                /* Increment Buffer pointer */
   1092                hi2c->pBuffPtr++;
   1093          
   1094                /* Update counter */
   1095                hi2c->XferCount--;
   1096                hi2c->XferSize--;
   \                     ??CrossCallReturnLabel_202: (+1)
   \       0xF0   0x1E40             SUBS     R0,R0,#+1
   \       0xF2   0x8520             STRH     R0,[R4, #+40]
   1097          
   1098                if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
   \       0xF4   0x6821             LDR      R1,[R4, #+0]
   \       0xF6   0x694A             LDR      R2,[R1, #+20]
   \       0xF8   0x0753             LSLS     R3,R2,#+29
   \       0xFA   0xD506             BPL.N    ??CrossCallReturnLabel_267
   \       0xFC   0xB280             UXTH     R0,R0
   \       0xFE   0xB120             CBZ.N    R0,??CrossCallReturnLabel_267
   1099                {
   1100                  /* Write data to DR */
   1101                  hi2c->Instance->DR = *hi2c->pBuffPtr;
   \      0x100   0x6A60             LDR      R0,[R4, #+36]
   \      0x102   0x7802             LDRB     R2,[R0, #+0]
   \      0x104   0x610A             STR      R2,[R1, #+16]
   1102          
   1103                  /* Increment Buffer pointer */
   1104                  hi2c->pBuffPtr++;
   \      0x106   0x....'....        BL       ?Subroutine88
   1105          
   1106                  /* Update counter */
   1107                  hi2c->XferCount--;
   1108                  hi2c->XferSize--;
   1109                }
   1110          
   1111                /* Wait until BTF flag is set */
   1112                if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_267: (+1)
   \      0x10A   0x4642             MOV      R2,R8
   \      0x10C   0x4629             MOV      R1,R5
   \      0x10E   0x4620             MOV      R0,R4
   \      0x110   0x....'....        BL       I2C_WaitOnBTFFlagUntilTimeout
   \      0x114   0x2800             CMP      R0,#+0
   \      0x116   0xD0E1             BEQ.N    ??HAL_I2C_Master_Transmit_5
   1113                {
   1114                  if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Master_Transmit_7: (+1)
   \      0x118   0x6878             LDR      R0,[R7, #+4]
   \      0x11A   0x2804             CMP      R0,#+4
   \      0x11C   0xD101             BNE.N    ??CrossCallReturnLabel_92
   1115                  {
   1116                    /* Generate Stop */
   1117                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \      0x11E   0x....'....        BL       ?Subroutine34
   1118                  }
   1119                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_92: (+1)
   \      0x122   0x2001             MOVS     R0,#+1
   \      0x124   0xE005             B.N      ??HAL_I2C_Master_Transmit_8
   1120                }
   1121              }
   1122          
   1123              /* Generate Stop */
   1124              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Master_Transmit_6: (+1)
   \      0x126   0x....'....        BL       ?Subroutine34
   1125          
   1126              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??CrossCallReturnLabel_93: (+1)
   \      0x12A   0x....'....        BL       ?Subroutine83
   1127              hi2c->Mode = HAL_I2C_MODE_NONE;
   1128          
   1129              /* Process Unlocked */
   1130              __HAL_UNLOCK(hi2c);
   1131          
   1132              return HAL_OK;
   \                     ??CrossCallReturnLabel_253: (+1)
   \      0x12E   0xE000             B.N      ??HAL_I2C_Master_Transmit_8
   1133            }
   1134            else
   1135            {
   1136              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_1: (+1)
   \      0x130   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_8: (+1)
   \      0x132   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1137            }
   1138          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine88: (+1)
   \        0x0   0x6A60             LDR      R0,[R4, #+36]
   \        0x2   0x1C41             ADDS     R1,R0,#+1
   \        0x4   0x6261             STR      R1,[R4, #+36]
   \        0x6   0x8D60             LDRH     R0,[R4, #+42]
   \        0x8   0x1E41             SUBS     R1,R0,#+1
   \        0xA   0x8561             STRH     R1,[R4, #+42]
   \        0xC   0x8D20             LDRH     R0,[R4, #+40]
   \        0xE   0x1E41             SUBS     R1,R0,#+1
   \       0x10   0x8521             STRH     R1,[R4, #+40]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine66: (+1)
   \        0x0   0x6A60             LDR      R0,[R4, #+36]
   \        0x2   0x6822             LDR      R2,[R4, #+0]
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0x6111             STR      R1,[R2, #+16]
   \        0x8   0x6A60             LDR      R0,[R4, #+36]
   \        0xA   0x1C41             ADDS     R1,R0,#+1
   \        0xC   0x6261             STR      R1,[R4, #+36]
   \        0xE   0x8D60             LDRH     R0,[R4, #+42]
   \       0x10   0x1E41             SUBS     R1,R0,#+1
   \       0x12   0x8561             STRH     R1,[R4, #+42]
   \       0x14   0x8D20             LDRH     R0,[R4, #+40]
   \       0x16   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \        0x0   0x70B9             STRB     R1,[R7, #+2]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x6078             STR      R0,[R7, #+4]
   \        0x6   0x6265             STR      R5,[R4, #+36]
   \        0x8   0xF8A4 0x902A      STRH     R9,[R4, #+42]
   \        0xC   0x8D60             LDRH     R0,[R4, #+42]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine83: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x7078             STRB     R0,[R7, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70B9             STRB     R1,[R7, #+2]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x7038             STRB     R0,[R7, #+0]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine76: (+1)
   \        0x0   0x4690             MOV      R8,R2
   \                     ??Subroutine76_0: (+1)
   \        0x2   0x4699             MOV      R9,R3
   \        0x4   0x....'....        B.W      HAL_GetTick

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine30: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   \        0x4   0x07D1             LSLS     R1,R2,#+31
   \        0x6   0xD403             BMI.N    ??Subroutine30_0
   \        0x8   0x6802             LDR      R2,[R0, #+0]
   \        0xA   0xF042 0x0201      ORR      R2,R2,#0x1
   \        0xE   0x6002             STR      R2,[R0, #+0]
   \                     ??Subroutine30_0: (+1)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0xF421 0x6100      BIC      R1,R1,#0x800
   \       0x18   0x6001             STR      R1,[R0, #+0]
   \       0x1A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine29: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x7180      ORR      R1,R1,#0x100
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine25: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \                     ??Subroutine25_0: (+1)
   \        0x2   0xF04F 0x1101      MOV      R1,#+65537
   \                     ??Subroutine25_1: (+1)
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x....'....        B.W      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine34: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x7100      ORR      R1,R1,#0x200
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine27: (+1)
   \        0x0   0x4641             MOV      R1,R8
   \                     ??Subroutine27_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x....             B.N      I2C_WaitOnTXEFlagUntilTimeout
   1139          
   1140          /**
   1141            * @brief  Receives in master mode an amount of data in blocking mode.
   1142            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1143            *                the configuration information for the specified I2C.
   1144            * @param  DevAddress Target device address: The device 7 bits address value
   1145            *         in datasheet must be shifted to the left before calling the interface
   1146            * @param  pData Pointer to data buffer
   1147            * @param  Size Amount of data to be sent
   1148            * @param  Timeout Timeout duration
   1149            * @retval HAL status
   1150            */

   \                                 In section .text, align 2, keep-with-next
   1151          HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1152          {
   \                     HAL_I2C_Master_Receive: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x....'....        BL       ?Subroutine74
   1153            /* Init tickstart for timeout management*/
   1154            uint32_t tickstart = HAL_GetTick();
   1155          
   1156            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_224: (+1)
   \        0x8   0x....'....        BL       ?Subroutine73
   \                     ??CrossCallReturnLabel_218: (+1)
   \        0xC   0xD102             BNE.N    ??HAL_I2C_Master_Receive_0
   1157            {
   1158              /* Wait until BUSY flag is reset */
   1159              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \        0xE   0x....'....        BL       ?Subroutine77
   \                     ??CrossCallReturnLabel_233: (+1)
   \       0x12   0x2800             CMP      R0,#+0
   \                     ??HAL_I2C_Master_Receive_0: (+1)
   \       0x14   0xF040 0x80CB      BNE.W    ??HAL_I2C_Master_Receive_1
   1160              {
   1161                return HAL_BUSY;
   1162              }
   1163          
   1164              /* Process Locked */
   1165              __HAL_LOCK(hi2c);
   \       0x18   0x7838             LDRB     R0,[R7, #+0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xF000 0x80C7      BEQ.W    ??HAL_I2C_Master_Receive_1
   \       0x20   0x....'....        BL       ?Subroutine80
   1166          
   1167              /* Check if the I2C is already enabled */
   1168              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_245: (+1)
   \       0x24   0xD401             BMI.N    ??CrossCallReturnLabel_125
   1169              {
   1170                /* Enable I2C peripheral */
   1171                __HAL_I2C_ENABLE(hi2c);
   \       0x26   0x....'....        BL       ??Subroutine47_0
   1172              }
   1173          
   1174              /* Disable Pos */
   1175              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??CrossCallReturnLabel_125: (+1)
   \       0x2A   0x....'....        BL       ?Subroutine54
   1176          
   1177              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   1178              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   \                     ??CrossCallReturnLabel_154: (+1)
   \       0x2E   0x2110             MOVS     R1,#+16
   \       0x30   0x70B9             STRB     R1,[R7, #+2]
   1179              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6078             STR      R0,[R7, #+4]
   1180          
   1181              /* Prepare transfer parameters */
   1182              hi2c->pBuffPtr    = pData;
   \       0x36   0xF8C6 0x9024      STR      R9,[R6, #+36]
   1183              hi2c->XferCount   = Size;
   \       0x3A   0xF8A6 0x802A      STRH     R8,[R6, #+42]
   1184              hi2c->XferSize    = hi2c->XferCount;
   \       0x3E   0x8D70             LDRH     R0,[R6, #+42]
   \       0x40   0x8530             STRH     R0,[R6, #+40]
   1185              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x42   0x....'....        LDR.W    R0,??DataTable15_1  ;; 0xffff0000
   \       0x46   0x62F0             STR      R0,[R6, #+44]
   1186          
   1187              /* Send Slave Address */
   1188              if (I2C_MasterRequestRead(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
   \       0x48   0x6AF1             LDR      R1,[R6, #+44]
   \       0x4A   0x6832             LDR      R2,[R6, #+0]
   \       0x4C   0x6813             LDR      R3,[R2, #+0]
   \       0x4E   0x2908             CMP      R1,#+8
   \       0x50   0xF443 0x6380      ORR      R3,R3,#0x400
   \       0x54   0xBF18             IT       NE
   \       0x56   0x2901             CMPNE    R1,#+1
   \       0x58   0x6013             STR      R3,[R2, #+0]
   \       0x5A   0xD004             BEQ.N    ??HAL_I2C_Master_Receive_2
   \       0x5C   0x4281             CMP      R1,R0
   \       0x5E   0xBF1C             ITT      NE
   \       0x60   0x6B30             LDRNE    R0,[R6, #+48]
   \       0x62   0x2811             CMPNE    R0,#+17
   \       0x64   0xD101             BNE.N    ??CrossCallReturnLabel_143
   \                     ??HAL_I2C_Master_Receive_2: (+1)
   \       0x66   0x....'....        BL       ?Subroutine52
   \                     ??CrossCallReturnLabel_143: (+1)
   \       0x6A   0x9400             STR      R4,[SP, #+0]
   \       0x6C   0x2200             MOVS     R2,#+0
   \       0x6E   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \       0x72   0x464B             MOV      R3,R9
   \       0x74   0xF04F 0x1101      MOV      R1,#+65537
   \       0x78   0x....'....        BL       ??Subroutine78_1
   \                     ??CrossCallReturnLabel_241: (+1)
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xF44F 0x7A00      MOV      R10,#+512
   \       0x82   0xD131             BNE.N    ??HAL_I2C_Master_Receive_3
   \       0x84   0x6930             LDR      R0,[R6, #+16]
   \       0x86   0x....'....        LDR.W    R8,??DataTable16_1  ;; 0x10002
   \       0x8A   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x8E   0xD105             BNE.N    ??HAL_I2C_Master_Receive_4
   \       0x90   0x6830             LDR      R0,[R6, #+0]
   \       0x92   0xF045 0x0501      ORR      R5,R5,#0x1
   \       0x96   0xB2ED             UXTB     R5,R5
   \       0x98   0x6105             STR      R5,[R0, #+16]
   \       0x9A   0xE030             B.N      ??HAL_I2C_Master_Receive_5
   \                     ??HAL_I2C_Master_Receive_4: (+1)
   \       0x9C   0x09E8             LSRS     R0,R5,#+7
   \       0x9E   0x6832             LDR      R2,[R6, #+0]
   \       0xA0   0xF000 0x0B06      AND      R11,R0,#0x6
   \       0xA4   0xF04B 0x01F0      ORR      R1,R11,#0xF0
   \       0xA8   0x6111             STR      R1,[R2, #+16]
   \       0xAA   0x4623             MOV      R3,R4
   \       0xAC   0x464A             MOV      R2,R9
   \       0xAE   0x....'....        LDR.W    R1,??DataTable16  ;; 0x10008
   \       0xB2   0x....'....        BL       ??Subroutine95_0
   \                     ??CrossCallReturnLabel_280: (+1)
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD16F             BNE.N    ??HAL_I2C_Master_Receive_6
   \       0xBA   0x6830             LDR      R0,[R6, #+0]
   \       0xBC   0xB2ED             UXTB     R5,R5
   \       0xBE   0x6105             STR      R5,[R0, #+16]
   \       0xC0   0x....'....        BL       ?Subroutine95
   \                     ??CrossCallReturnLabel_281: (+1)
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD168             BNE.N    ??HAL_I2C_Master_Receive_6
   \       0xC8   0x9000             STR      R0,[SP, #+0]
   \       0xCA   0x464B             MOV      R3,R9
   \       0xCC   0x....'....        BL       ??Subroutine99_0
   \                     ??CrossCallReturnLabel_300: (+1)
   \       0xD0   0x6831             LDR      R1,[R6, #+0]
   \       0xD2   0x680A             LDR      R2,[R1, #+0]
   \       0xD4   0xF442 0x7280      ORR      R2,R2,#0x100
   \       0xD8   0x600A             STR      R2,[R1, #+0]
   \       0xDA   0x9400             STR      R4,[SP, #+0]
   \       0xDC   0x2200             MOVS     R2,#+0
   \       0xDE   0xF04F 0x1101      MOV      R1,#+65537
   \       0xE2   0x....'....        BL       ??Subroutine78_1
   \                     ??CrossCallReturnLabel_242: (+1)
   \       0xE6   0xB130             CBZ.N    R0,??HAL_I2C_Master_Receive_7
   \                     ??HAL_I2C_Master_Receive_3: (+1)
   \       0xE8   0x6830             LDR      R0,[R6, #+0]
   \       0xEA   0x6801             LDR      R1,[R0, #+0]
   \       0xEC   0x05CA             LSLS     R2,R1,#+23
   \       0xEE   0xD554             BPL.N    ??HAL_I2C_Master_Receive_6
   \       0xF0   0xF8C7 0xA004      STR      R10,[R7, #+4]
   \       0xF4   0xE051             B.N      ??HAL_I2C_Master_Receive_6
   \                     ??HAL_I2C_Master_Receive_7: (+1)
   \       0xF6   0x6830             LDR      R0,[R6, #+0]
   \       0xF8   0xF04B 0x01F1      ORR      R1,R11,#0xF1
   \       0xFC   0x6101             STR      R1,[R0, #+16]
   \                     ??HAL_I2C_Master_Receive_5: (+1)
   \       0xFE   0x....'....        BL       ?Subroutine95
   \                     ??CrossCallReturnLabel_282: (+1)
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD149             BNE.N    ??HAL_I2C_Master_Receive_6
   1189              {
   1190                return HAL_ERROR;
   1191              }
   1192          
   1193              if (hi2c->XferSize == 0U)
   \      0x106   0x8D30             LDRH     R0,[R6, #+40]
   \      0x108   0xB118             CBZ.N    R0,??CrossCallReturnLabel_167
   1194              {
   1195                /* Clear ADDR flag */
   1196                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   1197          
   1198                /* Generate Stop */
   1199                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   1200              }
   1201              else if (hi2c->XferSize == 1U)
   \      0x10A   0x2801             CMP      R0,#+1
   \      0x10C   0xD104             BNE.N    ??HAL_I2C_Master_Receive_8
   1202              {
   1203                /* Disable Acknowledge */
   1204                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x10E   0x....'....        BL       ?Subroutine59
   1205          
   1206                /* Clear ADDR flag */
   1207                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   1208          
   1209                /* Generate Stop */
   1210                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   1211              }
   \                     ??CrossCallReturnLabel_167: (+1)
   \      0x112   0x....'....        BL       ?Subroutine97
   \                     ??CrossCallReturnLabel_285: (+1)
   \      0x116   0xE018             B.N      ??CrossCallReturnLabel_312
   1212              else if (hi2c->XferSize == 2U)
   \                     ??HAL_I2C_Master_Receive_8: (+1)
   \      0x118   0x2802             CMP      R0,#+2
   \      0x11A   0x6830             LDR      R0,[R6, #+0]
   \      0x11C   0x6801             LDR      R1,[R0, #+0]
   \      0x11E   0xD105             BNE.N    ??HAL_I2C_Master_Receive_9
   1213              {
   1214                /* Disable Acknowledge */
   1215                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x120   0xF421 0x6180      BIC      R1,R1,#0x400
   \      0x124   0x6001             STR      R1,[R0, #+0]
   1216          
   1217                /* Enable Pos */
   1218                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \      0x126   0x....'....        BL       ?Subroutine110
   1219          
   1220                /* Clear ADDR flag */
   1221                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??CrossCallReturnLabel_325: (+1)
   \      0x12A   0xE002             B.N      ??HAL_I2C_Master_Receive_10
   1222              }
   1223              else
   1224              {
   1225                /* Enable Acknowledge */
   1226                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Receive_9: (+1)
   \      0x12C   0xF441 0x6180      ORR      R1,R1,#0x400
   \      0x130   0x6001             STR      R1,[R0, #+0]
   1227          
   1228                /* Clear ADDR flag */
   1229                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Master_Receive_10: (+1)
   \      0x132   0x2000             MOVS     R0,#+0
   \      0x134   0x....'....        BL       ?Subroutine99
   \                     ??CrossCallReturnLabel_297: (+1)
   \      0x138   0xE007             B.N      ??CrossCallReturnLabel_312
   1230              }
   1231          
   1232              while (hi2c->XferSize > 0U)
   1233              {
   1234                if (hi2c->XferSize <= 3U)
   1235                {
   1236                  /* One byte */
   1237                  if (hi2c->XferSize == 1U)
   1238                  {
   1239                    /* Wait until RXNE flag is set */
   1240                    if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_11: (+1)
   \      0x13A   0x....'....        BL       ?Subroutine107
   \                     ??CrossCallReturnLabel_320: (+1)
   \      0x13E   0x2800             CMP      R0,#+0
   \      0x140   0xD12B             BNE.N    ??HAL_I2C_Master_Receive_6
   1241                    {
   1242                      return HAL_ERROR;
   1243                    }
   1244          
   1245                    /* Read data from DR */
   1246                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x142   0x....'....        BL       ?Subroutine109
   1247          
   1248                    /* Increment Buffer pointer */
   1249                    hi2c->pBuffPtr++;
   1250          
   1251                    /* Update counter */
   1252                    hi2c->XferSize--;
   \                     ??CrossCallReturnLabel_323: (+1)
   \      0x146   0x....'....        BL       ?Subroutine105
   1253                    hi2c->XferCount--;
   1254                  }
   \                     ??CrossCallReturnLabel_312: (+1)
   \      0x14A   0x8D30             LDRH     R0,[R6, #+40]
   \      0x14C   0x2800             CMP      R0,#+0
   \      0x14E   0xD02B             BEQ.N    ??HAL_I2C_Master_Receive_12
   \      0x150   0x2804             CMP      R0,#+4
   \      0x152   0xD21F             BCS.N    ??HAL_I2C_Master_Receive_13
   \      0x154   0x2801             CMP      R0,#+1
   \      0x156   0xD0F0             BEQ.N    ??HAL_I2C_Master_Receive_11
   1255                  /* Two bytes */
   1256                  else if (hi2c->XferSize == 2U)
   \      0x158   0x2802             CMP      R0,#+2
   \      0x15A   0x....'....        LDR.W    R5,??DataTable17  ;; 0x10004
   \      0x15E   0x9400             STR      R4,[SP, #+0]
   \      0x160   0x464B             MOV      R3,R9
   \      0x162   0xD10A             BNE.N    ??HAL_I2C_Master_Receive_14
   1257                  {
   1258                    /* Wait until BTF flag is set */
   1259                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \      0x164   0x....'....        BL       ?Subroutine78
   \                     ??CrossCallReturnLabel_240: (+1)
   \      0x168   0x2800             CMP      R0,#+0
   \      0x16A   0xD116             BNE.N    ??HAL_I2C_Master_Receive_6
   1260                    {
   1261                      return HAL_ERROR;
   1262                    }
   1263          
   1264                    /* Generate Stop */
   1265                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Master_Receive_15: (+1)
   \      0x16C   0x....'....        BL       ?Subroutine51
   1266          
   1267                    /* Read data from DR */
   1268                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   1269          
   1270                    /* Increment Buffer pointer */
   1271                    hi2c->pBuffPtr++;
   1272          
   1273                    /* Update counter */
   1274                    hi2c->XferSize--;
   1275                    hi2c->XferCount--;
   1276          
   1277                    /* Read data from DR */
   1278                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??CrossCallReturnLabel_141: (+1)
   \      0x170   0x6A71             LDR      R1,[R6, #+36]
   \      0x172   0x7008             STRB     R0,[R1, #+0]
   1279          
   1280                    /* Increment Buffer pointer */
   1281                    hi2c->pBuffPtr++;
   \      0x174   0x6A70             LDR      R0,[R6, #+36]
   \      0x176   0x1C42             ADDS     R2,R0,#+1
   \      0x178   0xE7E5             B.N      ??CrossCallReturnLabel_323
   1282          
   1283                    /* Update counter */
   1284                    hi2c->XferSize--;
   1285                    hi2c->XferCount--;
   1286                  }
   1287                  /* 3 Last bytes */
   1288                  else
   1289                  {
   1290                    /* Wait until BTF flag is set */
   1291                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_14: (+1)
   \      0x17A   0x....'....        BL       ?Subroutine78
   \                     ??CrossCallReturnLabel_239: (+1)
   \      0x17E   0x2800             CMP      R0,#+0
   \      0x180   0xD10B             BNE.N    ??HAL_I2C_Master_Receive_6
   1292                    {
   1293                      return HAL_ERROR;
   1294                    }
   1295          
   1296                    /* Disable Acknowledge */
   1297                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x182   0x....'....        BL       ?Subroutine60
   1298          
   1299                    /* Read data from DR */
   1300                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   1301          
   1302                    /* Increment Buffer pointer */
   1303                    hi2c->pBuffPtr++;
   1304          
   1305                    /* Update counter */
   1306                    hi2c->XferSize--;
   1307                    hi2c->XferCount--;
   1308          
   1309                    /* Wait until BTF flag is set */
   1310                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_169: (+1)
   \      0x186   0x464B             MOV      R3,R9
   \      0x188   0x....'....        BL       ?Subroutine93
   \                     ??CrossCallReturnLabel_275: (+1)
   \      0x18C   0x....'....        BL       ??Subroutine78_0
   \                     ??CrossCallReturnLabel_238: (+1)
   \      0x190   0xB918             CBNZ.N   R0,??HAL_I2C_Master_Receive_6
   1311                    {
   1312                      return HAL_ERROR;
   1313                    }
   1314          
   1315                    /* Generate Stop */
   1316                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \      0x192   0xE7EB             B.N      ??HAL_I2C_Master_Receive_15
   1317          
   1318                    /* Read data from DR */
   1319                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   1320          
   1321                    /* Increment Buffer pointer */
   1322                    hi2c->pBuffPtr++;
   1323          
   1324                    /* Update counter */
   1325                    hi2c->XferSize--;
   1326                    hi2c->XferCount--;
   1327          
   1328                    /* Read data from DR */
   1329                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   1330          
   1331                    /* Increment Buffer pointer */
   1332                    hi2c->pBuffPtr++;
   1333          
   1334                    /* Update counter */
   1335                    hi2c->XferSize--;
   1336                    hi2c->XferCount--;
   1337                  }
   1338                }
   1339                else
   1340                {
   1341                  /* Wait until RXNE flag is set */
   1342                  if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_13: (+1)
   \      0x194   0x....'....        BL       ?Subroutine107
   \                     ??CrossCallReturnLabel_319: (+1)
   \      0x198   0xB108             CBZ.N    R0,??HAL_I2C_Master_Receive_16
   1343                  {
   1344                    return HAL_ERROR;
   \                     ??HAL_I2C_Master_Receive_6: (+1)
   \      0x19A   0x2001             MOVS     R0,#+1
   \      0x19C   0xE008             B.N      ??HAL_I2C_Master_Receive_17
   1345                  }
   1346          
   1347                  /* Read data from DR */
   1348                  *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??HAL_I2C_Master_Receive_16: (+1)
   \      0x19E   0x....'....        BL       ?Subroutine104
   1349          
   1350                  /* Increment Buffer pointer */
   1351                  hi2c->pBuffPtr++;
   1352          
   1353                  /* Update counter */
   1354                  hi2c->XferSize--;
   1355                  hi2c->XferCount--;
   1356          
   1357                  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \                     ??CrossCallReturnLabel_310: (+1)
   \      0x1A2   0xD5D2             BPL.N    ??CrossCallReturnLabel_312
   1358                  {
   1359                    /* Read data from DR */
   1360                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x1A4   0x6900             LDR      R0,[R0, #+16]
   \      0x1A6   0xE7E3             B.N      ??CrossCallReturnLabel_141
   1361          
   1362                    /* Increment Buffer pointer */
   1363                    hi2c->pBuffPtr++;
   1364          
   1365                    /* Update counter */
   1366                    hi2c->XferSize--;
   1367                    hi2c->XferCount--;
   1368                  }
   1369                }
   1370              }
   1371          
   1372              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Receive_12: (+1)
   \      0x1A8   0x....'....        BL       ?Subroutine83
   1373              hi2c->Mode = HAL_I2C_MODE_NONE;
   1374          
   1375              /* Process Unlocked */
   1376              __HAL_UNLOCK(hi2c);
   1377          
   1378              return HAL_OK;
   \                     ??CrossCallReturnLabel_254: (+1)
   \      0x1AC   0xE000             B.N      ??HAL_I2C_Master_Receive_17
   1379            }
   1380            else
   1381            {
   1382              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_1: (+1)
   \      0x1AE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_17: (+1)
   \      0x1B0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1383            }
   1384          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine95: (+1)
   \        0x0   0x4623             MOV      R3,R4
   \        0x2   0x464A             MOV      R2,R9
   \        0x4   0x4641             MOV      R1,R8
   \                     ??Subroutine95_0: (+1)
   \        0x6   0x4630             MOV      R0,R6
   \        0x8   0x....'....        B.W      I2C_WaitOnMasterAddressFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine74: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \                     ??Subroutine74_0: (+1)
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4691             MOV      R9,R2
   \        0x6   0x4698             MOV      R8,R3
   \        0x8   0x....'....        B.W      HAL_GetTick

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine78: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \                     ??Subroutine78_0: (+1)
   \        0x2   0x4629             MOV      R1,R5
   \                     ??Subroutine78_1: (+1)
   \        0x4   0x4630             MOV      R0,R6
   \        0x6   0x....'....        B.W      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine54: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF421 0x6100      BIC      R1,R1,#0x800
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x2022             MOVS     R0,#+34
   \        0xC   0x7078             STRB     R0,[R7, #+1]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine80: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x7039             STRB     R1,[R7, #+0]
   \        0x4   0x6830             LDR      R0,[R6, #+0]
   \        0x6   0x6802             LDR      R2,[R0, #+0]
   \        0x8   0x07D1             LSLS     R1,R2,#+31
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine77: (+1)
   \        0x0   0x9400             STR      R4,[SP, #+0]
   \        0x2   0x2319             MOVS     R3,#+25
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0x....             LDR.N    R1,??DataTable15  ;; 0x100002
   \        0x8   0x4630             MOV      R0,R6
   \        0xA   0x....'....        B.W      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine73: (+1)
   \        0x0   0xF106 0x073C      ADD      R7,R6,#+60
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x7878             LDRB     R0,[R7, #+1]
   \        0x8   0x2820             CMP      R0,#+32
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine110: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   \        0x4   0xF442 0x6200      ORR      R2,R2,#0x800
   \        0x8   0x6002             STR      R2,[R0, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine109: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6901             LDR      R1,[R0, #+16]
   \        0x4   0x6A70             LDR      R0,[R6, #+36]
   \        0x6   0x7001             STRB     R1,[R0, #+0]
   \        0x8   0x6A71             LDR      R1,[R6, #+36]
   \        0xA   0x1C4A             ADDS     R2,R1,#+1
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine107: (+1)
   \        0x0   0x4622             MOV      R2,R4
   \        0x2   0x4649             MOV      R1,R9
   \                     ??Subroutine107_0: (+1)
   \        0x4   0x4630             MOV      R0,R6
   \        0x6   0x....'....        B.W      I2C_WaitOnRXNEFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine105: (+1)
   \        0x0   0x8D30             LDRH     R0,[R6, #+40]
   \        0x2   0x6272             STR      R2,[R6, #+36]
   \        0x4   0x1E41             SUBS     R1,R0,#+1
   \        0x6   0x8531             STRH     R1,[R6, #+40]
   \        0x8   0x8D70             LDRH     R0,[R6, #+42]
   \        0xA   0x1E41             SUBS     R1,R0,#+1
   \        0xC   0x8571             STRH     R1,[R6, #+42]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine104: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6901             LDR      R1,[R0, #+16]
   \        0x4   0x6A70             LDR      R0,[R6, #+36]
   \        0x6   0x7001             STRB     R1,[R0, #+0]
   \        0x8   0x6A71             LDR      R1,[R6, #+36]
   \        0xA   0x8D30             LDRH     R0,[R6, #+40]
   \        0xC   0x1C4A             ADDS     R2,R1,#+1
   \        0xE   0x1E41             SUBS     R1,R0,#+1
   \       0x10   0x6272             STR      R2,[R6, #+36]
   \       0x12   0x8531             STRH     R1,[R6, #+40]
   \       0x14   0x8D70             LDRH     R0,[R6, #+42]
   \       0x16   0x1E41             SUBS     R1,R0,#+1
   \       0x18   0x8571             STRH     R1,[R6, #+42]
   \       0x1A   0x6830             LDR      R0,[R6, #+0]
   \       0x1C   0x6941             LDR      R1,[R0, #+20]
   \       0x1E   0x074A             LSLS     R2,R1,#+29
   \       0x20   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine99: (+1)
   \        0x0   0x9000             STR      R0,[SP, #+0]
   \                     ??Subroutine99_0: (+1)
   \        0x2   0x6831             LDR      R1,[R6, #+0]
   \        0x4   0x694A             LDR      R2,[R1, #+20]
   \        0x6   0x9200             STR      R2,[SP, #+0]
   \        0x8   0x6989             LDR      R1,[R1, #+24]
   \        0xA   0x9100             STR      R1,[SP, #+0]
   \        0xC   0x9800             LDR      R0,[SP, #+0]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine97: (+1)
   \        0x0   0x9000             STR      R0,[SP, #+0]
   \        0x2   0x6831             LDR      R1,[R6, #+0]
   \        0x4   0x694A             LDR      R2,[R1, #+20]
   \        0x6   0x9200             STR      R2,[SP, #+0]
   \        0x8   0x6989             LDR      R1,[R1, #+24]
   \        0xA   0x9100             STR      R1,[SP, #+0]
   \        0xC   0x9800             LDR      R0,[SP, #+0]
   \        0xE   0x6831             LDR      R1,[R6, #+0]
   \       0x10   0x680A             LDR      R2,[R1, #+0]
   \       0x12   0xF442 0x7200      ORR      R2,R2,#0x200
   \       0x16   0x600A             STR      R2,[R1, #+0]
   \       0x18   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine93: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6901             LDR      R1,[R0, #+16]
   \        0x4   0x6A70             LDR      R0,[R6, #+36]
   \        0x6   0x7001             STRB     R1,[R0, #+0]
   \        0x8   0x6A71             LDR      R1,[R6, #+36]
   \        0xA   0x8D30             LDRH     R0,[R6, #+40]
   \        0xC   0x1C4A             ADDS     R2,R1,#+1
   \        0xE   0x1E41             SUBS     R1,R0,#+1
   \       0x10   0x6272             STR      R2,[R6, #+36]
   \       0x12   0x8531             STRH     R1,[R6, #+40]
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0x8D70             LDRH     R0,[R6, #+42]
   \       0x18   0x1E41             SUBS     R1,R0,#+1
   \       0x1A   0x8571             STRH     R1,[R6, #+42]
   \       0x1C   0x9400             STR      R4,[SP, #+0]
   \       0x1E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine59: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF421 0x6180      BIC      R1,R1,#0x400
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine51: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x7100      ORR      R1,R1,#0x200
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x6830             LDR      R0,[R6, #+0]
   \        0xC   0x6901             LDR      R1,[R0, #+16]
   \        0xE   0x6A70             LDR      R0,[R6, #+36]
   \       0x10   0x7001             STRB     R1,[R0, #+0]
   \       0x12   0x6A71             LDR      R1,[R6, #+36]
   \       0x14   0x8D30             LDRH     R0,[R6, #+40]
   \       0x16   0x1C4A             ADDS     R2,R1,#+1
   \       0x18   0x1E41             SUBS     R1,R0,#+1
   \       0x1A   0x6272             STR      R2,[R6, #+36]
   \       0x1C   0x8531             STRH     R1,[R6, #+40]
   \       0x1E   0x8D70             LDRH     R0,[R6, #+42]
   \       0x20   0x1E41             SUBS     R1,R0,#+1
   \       0x22   0x8571             STRH     R1,[R6, #+42]
   \       0x24   0x6832             LDR      R2,[R6, #+0]
   \       0x26   0x6910             LDR      R0,[R2, #+16]
   \       0x28   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine47: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \                     ??Subroutine47_0: (+1)
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   \        0x4   0xF042 0x0201      ORR      R2,R2,#0x1
   \        0x8   0x6002             STR      R2,[R0, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine52: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \                     ??Subroutine52_0: (+1)
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x7180      ORR      R1,R1,#0x100
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine60: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \                     ??Subroutine60_0: (+1)
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF421 0x6180      BIC      R1,R1,#0x400
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
   1385          
   1386          /**
   1387            * @brief  Transmits in slave mode an amount of data in blocking mode.
   1388            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1389            *                the configuration information for the specified I2C.
   1390            * @param  pData Pointer to data buffer
   1391            * @param  Size Amount of data to be sent
   1392            * @param  Timeout Timeout duration
   1393            * @retval HAL status
   1394            */

   \                                 In section .text, align 2, keep-with-next
   1395          HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1396          {
   \                     HAL_I2C_Slave_Transmit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x....'....        BL       ??Subroutine74_0
   1397            /* Init tickstart for timeout management*/
   1398            uint32_t tickstart = HAL_GetTick();
   1399          
   1400            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_222: (+1)
   \        0xA   0xF104 0x073C      ADD      R7,R4,#+60
   \        0xE   0x4606             MOV      R6,R0
   \       0x10   0x7878             LDRB     R0,[R7, #+1]
   \       0x12   0x2820             CMP      R0,#+32
   \       0x14   0xD169             BNE.N    ??HAL_I2C_Slave_Transmit_0
   1401            {
   1402              if ((pData == NULL) || (Size == 0U))
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xBF18             IT       NE
   \       0x1A   0xF1B9 0x0F00      CMPNE    R9,#+0
   \       0x1E   0xD054             BEQ.N    ??HAL_I2C_Slave_Transmit_1
   1403              {
   1404                return  HAL_ERROR;
   1405              }
   1406          
   1407              /* Process Locked */
   1408              __HAL_LOCK(hi2c);
   \       0x20   0x7838             LDRB     R0,[R7, #+0]
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD061             BEQ.N    ??HAL_I2C_Slave_Transmit_0
   \       0x26   0x....'....        BL       ?Subroutine82
   1409          
   1410              /* Check if the I2C is already enabled */
   1411              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_251: (+1)
   \       0x2A   0xD401             BMI.N    ??CrossCallReturnLabel_126
   1412              {
   1413                /* Enable I2C peripheral */
   1414                __HAL_I2C_ENABLE(hi2c);
   \       0x2C   0x....'....        BL       ??Subroutine47_0
   1415              }
   1416          
   1417              /* Disable Pos */
   1418              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   1419          
   1420              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   1421              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   1422              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1423          
   1424              /* Prepare transfer parameters */
   1425              hi2c->pBuffPtr    = pData;
   1426              hi2c->XferCount   = Size;
   1427              hi2c->XferSize    = hi2c->XferCount;
   1428              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1429          
   1430              /* Enable Address Acknowledge */
   1431              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   1432          
   1433              /* Wait until ADDR flag is set */
   1434              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_126: (+1)
   \       0x30   0x4643             MOV      R3,R8
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x....'....        BL       ??Subroutine55_0
   \                     ??CrossCallReturnLabel_156: (+1)
   \       0x38   0x2021             MOVS     R0,#+33
   \       0x3A   0x7078             STRB     R0,[R7, #+1]
   \       0x3C   0x2120             MOVS     R1,#+32
   \       0x3E   0x....'....        BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0x42   0x....'....        LDR.W    R1,??DataTable15_1  ;; 0xffff0000
   \       0x46   0x....'....        LDR.W    R5,??DataTable16_1  ;; 0x10002
   \       0x4A   0x8520             STRH     R0,[R4, #+40]
   \       0x4C   0x62E1             STR      R1,[R4, #+44]
   \       0x4E   0x4629             MOV      R1,R5
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x6802             LDR      R2,[R0, #+0]
   \       0x54   0xF442 0x6280      ORR      R2,R2,#0x400
   \       0x58   0x6002             STR      R2,[R0, #+0]
   \       0x5A   0x9600             STR      R6,[SP, #+0]
   \       0x5C   0x2200             MOVS     R2,#+0
   \       0x5E   0x....'....        BL       ??Subroutine25_1
   \                     ??CrossCallReturnLabel_59: (+1)
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD131             BNE.N    ??HAL_I2C_Slave_Transmit_1
   1435              {
   1436                return HAL_ERROR;
   1437              }
   1438          
   1439              /* Clear ADDR flag */
   1440              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0x66   0x....'....        BL       ?Subroutine67
   1441          
   1442              /* If 10bit addressing mode is selected */
   1443              if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \                     ??CrossCallReturnLabel_204: (+1)
   \       0x6A   0x6921             LDR      R1,[R4, #+16]
   \       0x6C   0xF5B1 0x4F40      CMP      R1,#+49152
   \       0x70   0xD10F             BNE.N    ??CrossCallReturnLabel_268
   1444              {
   1445                /* Wait until ADDR flag is set */
   1446                if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \       0x72   0x9600             STR      R6,[SP, #+0]
   \       0x74   0x4643             MOV      R3,R8
   \       0x76   0x2200             MOVS     R2,#+0
   \       0x78   0x4629             MOV      R1,R5
   \       0x7A   0x....'....        BL       ??Subroutine25_1
   \                     ??CrossCallReturnLabel_58: (+1)
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD123             BNE.N    ??HAL_I2C_Slave_Transmit_1
   1447                {
   1448                  return HAL_ERROR;
   1449                }
   1450          
   1451                /* Clear ADDR flag */
   1452                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0x82   0x....'....        BL       ?Subroutine67
   \                     ??CrossCallReturnLabel_205: (+1)
   \       0x86   0xE004             B.N      ??CrossCallReturnLabel_268
   1453              }
   1454          
   1455              while (hi2c->XferSize > 0U)
   1456              {
   1457                /* Wait until TXE flag is set */
   1458                if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1459                {
   1460                  /* Disable Address Acknowledge */
   1461                  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   1462          
   1463                  return HAL_ERROR;
   1464                }
   1465          
   1466                /* Write data to DR */
   1467                hi2c->Instance->DR = *hi2c->pBuffPtr;
   1468          
   1469                /* Increment Buffer pointer */
   1470                hi2c->pBuffPtr++;
   1471          
   1472                /* Update counter */
   1473                hi2c->XferCount--;
   1474                hi2c->XferSize--;
   1475          
   1476                if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
   1477                {
   1478                  /* Write data to DR */
   1479                  hi2c->Instance->DR = *hi2c->pBuffPtr;
   \                     ??HAL_I2C_Slave_Transmit_2: (+1)
   \       0x88   0x6A61             LDR      R1,[R4, #+36]
   \       0x8A   0x780A             LDRB     R2,[R1, #+0]
   \       0x8C   0x6102             STR      R2,[R0, #+16]
   1480          
   1481                  /* Increment Buffer pointer */
   1482                  hi2c->pBuffPtr++;
   \       0x8E   0x....'....        BL       ?Subroutine88
   1483          
   1484                  /* Update counter */
   1485                  hi2c->XferCount--;
   1486                  hi2c->XferSize--;
   1487                }
   \                     ??CrossCallReturnLabel_268: (+1)
   \       0x92   0x8D20             LDRH     R0,[R4, #+40]
   \       0x94   0xB188             CBZ.N    R0,??HAL_I2C_Slave_Transmit_3
   \       0x96   0x4632             MOV      R2,R6
   \       0x98   0x....'....        BL       ?Subroutine27
   \                     ??CrossCallReturnLabel_70: (+1)
   \       0x9C   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Transmit_4
   \       0x9E   0x....'....        BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_109: (+1)
   \       0xA2   0xE012             B.N      ??HAL_I2C_Slave_Transmit_1
   \                     ??HAL_I2C_Slave_Transmit_4: (+1)
   \       0xA4   0x....'....        BL       ?Subroutine66
   \                     ??CrossCallReturnLabel_203: (+1)
   \       0xA8   0x1E41             SUBS     R1,R0,#+1
   \       0xAA   0x8521             STRH     R1,[R4, #+40]
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x6942             LDR      R2,[R0, #+20]
   \       0xB0   0x0753             LSLS     R3,R2,#+29
   \       0xB2   0xD5EE             BPL.N    ??CrossCallReturnLabel_268
   \       0xB4   0xB289             UXTH     R1,R1
   \       0xB6   0x2900             CMP      R1,#+0
   \       0xB8   0xD1E6             BNE.N    ??HAL_I2C_Slave_Transmit_2
   1488              }
   1489          
   1490              /* Wait until AF flag is set */
   1491              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_3: (+1)
   \       0xBA   0x9600             STR      R6,[SP, #+0]
   \       0xBC   0x4643             MOV      R3,R8
   \       0xBE   0x2200             MOVS     R2,#+0
   \       0xC0   0xF44F 0x3182      MOV      R1,#+66560
   \       0xC4   0x....'....        BL       ??Subroutine25_1
   \                     ??CrossCallReturnLabel_57: (+1)
   \       0xC8   0xB108             CBZ.N    R0,??HAL_I2C_Slave_Transmit_5
   1492              {
   1493                return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_1: (+1)
   \       0xCA   0x2001             MOVS     R0,#+1
   \       0xCC   0xE00E             B.N      ??HAL_I2C_Slave_Transmit_6
   1494              }
   1495          
   1496              /* Clear AF flag */
   1497              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_Slave_Transmit_5: (+1)
   \       0xCE   0x6821             LDR      R1,[R4, #+0]
   \       0xD0   0xF46F 0x6080      MVN      R0,#+1024
   \       0xD4   0x6148             STR      R0,[R1, #+20]
   1498          
   1499              /* Disable Address Acknowledge */
   1500              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   1501          
   1502              hi2c->State = HAL_I2C_STATE_READY;
   1503              hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0xD6   0x2100             MOVS     R1,#+0
   \       0xD8   0x6820             LDR      R0,[R4, #+0]
   \       0xDA   0x....'....        BL       ?Subroutine49
   \                     ??CrossCallReturnLabel_136: (+1)
   \       0xDE   0x2020             MOVS     R0,#+32
   \       0xE0   0x7078             STRB     R0,[R7, #+1]
   \       0xE2   0x70B9             STRB     R1,[R7, #+2]
   1504          
   1505              /* Process Unlocked */
   1506              __HAL_UNLOCK(hi2c);
   \       0xE4   0x2000             MOVS     R0,#+0
   \       0xE6   0x7038             STRB     R0,[R7, #+0]
   1507          
   1508              return HAL_OK;
   \       0xE8   0xE000             B.N      ??HAL_I2C_Slave_Transmit_6
   1509            }
   1510            else
   1511            {
   1512              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_0: (+1)
   \       0xEA   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_6: (+1)
   \       0xEC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1513            }
   1514          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine82: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x7039             STRB     R1,[R7, #+0]
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6802             LDR      R2,[R0, #+0]
   \        0x8   0x07D1             LSLS     R1,R2,#+31
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine67: (+1)
   \        0x0   0x9000             STR      R0,[SP, #+0]
   \        0x2   0x6821             LDR      R1,[R4, #+0]
   \        0x4   0x694A             LDR      R2,[R1, #+20]
   \        0x6   0x9200             STR      R2,[SP, #+0]
   \        0x8   0x6989             LDR      R1,[R1, #+24]
   \        0xA   0x9100             STR      R1,[SP, #+0]
   \        0xC   0x9800             LDR      R0,[SP, #+0]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine49: (+1)
   \        0x0   0x6802             LDR      R2,[R0, #+0]
   \        0x2   0xF422 0x6280      BIC      R2,R2,#0x400
   \        0x6   0x6002             STR      R2,[R0, #+0]
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine55: (+1)
   \        0x0   0x6828             LDR      R0,[R5, #+0]
   \                     ??Subroutine55_0: (+1)
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF421 0x6100      BIC      R1,R1,#0x800
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine40: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF421 0x6180      BIC      R1,R1,#0x400
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
   1515          
   1516          /**
   1517            * @brief  Receive in slave mode an amount of data in blocking mode
   1518            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1519            *         the configuration information for the specified I2C.
   1520            * @param  pData Pointer to data buffer
   1521            * @param  Size Amount of data to be sent
   1522            * @param  Timeout Timeout duration
   1523            * @retval HAL status
   1524            */

   \                                 In section .text, align 2, keep-with-next
   1525          HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1526          {
   \                     HAL_I2C_Slave_Receive: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x....'....        BL       ?Subroutine74
   1527            /* Init tickstart for timeout management*/
   1528            uint32_t tickstart = HAL_GetTick();
   1529          
   1530            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_223: (+1)
   \        0x8   0x....'....        BL       ?Subroutine73
   \                     ??CrossCallReturnLabel_219: (+1)
   \        0xC   0xD166             BNE.N    ??HAL_I2C_Slave_Receive_0
   1531            {
   1532              if ((pData == NULL) || (Size == (uint16_t)0))
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xBF18             IT       NE
   \       0x12   0xF1B9 0x0F00      CMPNE    R9,#+0
   \       0x16   0xD022             BEQ.N    ??HAL_I2C_Slave_Receive_1
   1533              {
   1534                return HAL_ERROR;
   1535              }
   1536          
   1537              /* Process Locked */
   1538              __HAL_LOCK(hi2c);
   \       0x18   0x7838             LDRB     R0,[R7, #+0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD05E             BEQ.N    ??HAL_I2C_Slave_Receive_0
   \       0x1E   0x....'....        BL       ?Subroutine80
   1539          
   1540              /* Check if the I2C is already enabled */
   1541              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_246: (+1)
   \       0x22   0xD401             BMI.N    ??CrossCallReturnLabel_127
   1542              {
   1543                /* Enable I2C peripheral */
   1544                __HAL_I2C_ENABLE(hi2c);
   \       0x24   0x....'....        BL       ??Subroutine47_0
   1545              }
   1546          
   1547              /* Disable Pos */
   1548              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   1549          
   1550              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   1551              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   1552              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1553          
   1554              /* Prepare transfer parameters */
   1555              hi2c->pBuffPtr    = pData;
   1556              hi2c->XferCount   = Size;
   1557              hi2c->XferSize    = hi2c->XferCount;
   1558              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1559          
   1560              /* Enable Address Acknowledge */
   1561              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   1562          
   1563              /* Wait until ADDR flag is set */
   1564              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_127: (+1)
   \       0x28   0x4643             MOV      R3,R8
   \       0x2A   0x....'....        BL       ?Subroutine54
   \                     ??CrossCallReturnLabel_155: (+1)
   \       0x2E   0x2120             MOVS     R1,#+32
   \       0x30   0x70B9             STRB     R1,[R7, #+2]
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6078             STR      R0,[R7, #+4]
   \       0x36   0x6275             STR      R5,[R6, #+36]
   \       0x38   0xF8A6 0x902A      STRH     R9,[R6, #+42]
   \       0x3C   0x8D70             LDRH     R0,[R6, #+42]
   \       0x3E   0x....'....        LDR.W    R1,??DataTable15_1  ;; 0xffff0000
   \       0x42   0x8530             STRH     R0,[R6, #+40]
   \       0x44   0x62F1             STR      R1,[R6, #+44]
   \       0x46   0x6830             LDR      R0,[R6, #+0]
   \       0x48   0x....'....        LDR.W    R1,??DataTable16_1  ;; 0x10002
   \       0x4C   0x6802             LDR      R2,[R0, #+0]
   \       0x4E   0xF442 0x6280      ORR      R2,R2,#0x400
   \       0x52   0x6002             STR      R2,[R0, #+0]
   \       0x54   0x9400             STR      R4,[SP, #+0]
   \       0x56   0x2200             MOVS     R2,#+0
   \       0x58   0x....'....        BL       ??Subroutine78_1
   \                     ??CrossCallReturnLabel_237: (+1)
   \       0x5C   0xB108             CBZ.N    R0,??HAL_I2C_Slave_Receive_2
   1565              {
   1566                return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_1: (+1)
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xE03D             B.N      ??HAL_I2C_Slave_Receive_3
   1567              }
   1568          
   1569              /* Clear ADDR flag */
   1570              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_2: (+1)
   \       0x62   0x....'....        BL       ?Subroutine99
   \                     ??CrossCallReturnLabel_298: (+1)
   \       0x66   0xE003             B.N      ??HAL_I2C_Slave_Receive_4
   1571          
   1572              while (hi2c->XferSize > 0U)
   1573              {
   1574                /* Wait until RXNE flag is set */
   1575                if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1576                {
   1577                  /* Disable Address Acknowledge */
   1578                  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   1579          
   1580                  return HAL_ERROR;
   1581                }
   1582          
   1583                /* Read data from DR */
   1584                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   1585          
   1586                /* Increment Buffer pointer */
   1587                hi2c->pBuffPtr++;
   1588          
   1589                /* Update counter */
   1590                hi2c->XferSize--;
   1591                hi2c->XferCount--;
   1592          
   1593                if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
   1594                {
   1595                  /* Read data from DR */
   1596                  *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??HAL_I2C_Slave_Receive_5: (+1)
   \       0x68   0x....'....        BL       ?Subroutine112
   1597          
   1598                  /* Increment Buffer pointer */
   1599                  hi2c->pBuffPtr++;
   1600          
   1601                  /* Update counter */
   1602                  hi2c->XferSize--;
   1603                  hi2c->XferCount--;
   1604                }
   \                     ??CrossCallReturnLabel_329: (+1)
   \       0x6C   0x1E41             SUBS     R1,R0,#+1
   \       0x6E   0x8571             STRH     R1,[R6, #+42]
   \                     ??HAL_I2C_Slave_Receive_4: (+1)
   \       0x70   0x8D30             LDRH     R0,[R6, #+40]
   \       0x72   0xB188             CBZ.N    R0,??HAL_I2C_Slave_Receive_6
   \       0x74   0x4622             MOV      R2,R4
   \       0x76   0x4641             MOV      R1,R8
   \       0x78   0x....'....        BL       ??Subroutine107_0
   \                     ??CrossCallReturnLabel_318: (+1)
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0x6830             LDR      R0,[R6, #+0]
   \       0x80   0xD002             BEQ.N    ??HAL_I2C_Slave_Receive_7
   \                     ??HAL_I2C_Slave_Receive_8: (+1)
   \       0x82   0x....'....        BL       ??Subroutine60_0
   \                     ??CrossCallReturnLabel_170: (+1)
   \       0x86   0xE7EA             B.N      ??HAL_I2C_Slave_Receive_1
   \                     ??HAL_I2C_Slave_Receive_7: (+1)
   \       0x88   0x....'....        BL       ?Subroutine112
   1605              }
   \                     ??CrossCallReturnLabel_330: (+1)
   \       0x8C   0x....'....        BL       ?Subroutine114
   \                     ??CrossCallReturnLabel_337: (+1)
   \       0x90   0xD5EE             BPL.N    ??HAL_I2C_Slave_Receive_4
   \       0x92   0xB289             UXTH     R1,R1
   \       0x94   0x2900             CMP      R1,#+0
   \       0x96   0xD1E7             BNE.N    ??HAL_I2C_Slave_Receive_5
   \                     ??HAL_I2C_Slave_Receive_6: (+1)
   \       0x98   0x6831             LDR      R1,[R6, #+0]
   \       0x9A   0x6948             LDR      R0,[R1, #+20]
   \       0x9C   0x06C2             LSLS     R2,R0,#+27
   \       0x9E   0xD411             BMI.N    ??HAL_I2C_Slave_Receive_9
   \       0xA0   0x4630             MOV      R0,R6
   \       0xA2   0x....'....        BL       I2C_IsAcknowledgeFailed
   \       0xA6   0xB958             CBNZ.N   R0,??CrossCallReturnLabel_210
   \       0xA8   0x....'....        BL       HAL_GetTick
   \       0xAC   0x1B00             SUBS     R0,R0,R4
   \       0xAE   0x4580             CMP      R8,R0
   \       0xB0   0xD302             BCC.N    ??HAL_I2C_Slave_Receive_10
   \       0xB2   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xB6   0xD1EF             BNE.N    ??HAL_I2C_Slave_Receive_6
   \                     ??HAL_I2C_Slave_Receive_10: (+1)
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0x6330             STR      R0,[R6, #+48]
   \       0xBC   0x....'....        BL       ?Subroutine69
   1606          
   1607              /* Wait until STOP flag is set */
   1608              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1609              {
   1610                /* Disable Address Acknowledge */
   1611                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??CrossCallReturnLabel_210: (+1)
   \       0xC0   0x6830             LDR      R0,[R6, #+0]
   \       0xC2   0xE7DE             B.N      ??HAL_I2C_Slave_Receive_8
   1612          
   1613                return HAL_ERROR;
   1614              }
   1615          
   1616              /* Clear STOP flag */
   1617              __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_9: (+1)
   \       0xC4   0x2200             MOVS     R2,#+0
   \       0xC6   0x9200             STR      R2,[SP, #+0]
   \       0xC8   0x6949             LDR      R1,[R1, #+20]
   \       0xCA   0x9100             STR      R1,[SP, #+0]
   \       0xCC   0x....'....        BL       ?Subroutine47
   \                     ??CrossCallReturnLabel_128: (+1)
   \       0xD0   0x9800             LDR      R0,[SP, #+0]
   1618          
   1619              /* Disable Address Acknowledge */
   1620              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xD2   0x....'....        BL       ?Subroutine60
   1621          
   1622              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??CrossCallReturnLabel_171: (+1)
   \       0xD6   0x....'....        BL       ?Subroutine83
   1623              hi2c->Mode = HAL_I2C_MODE_NONE;
   1624          
   1625              /* Process Unlocked */
   1626              __HAL_UNLOCK(hi2c);
   1627          
   1628              return HAL_OK;
   \                     ??CrossCallReturnLabel_255: (+1)
   \       0xDA   0xE000             B.N      ??HAL_I2C_Slave_Receive_3
   1629            }
   1630            else
   1631            {
   1632              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_0: (+1)
   \       0xDC   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_3: (+1)
   \       0xDE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1633            }
   1634          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine112: (+1)
   \        0x0   0x6901             LDR      R1,[R0, #+16]
   \        0x2   0x6A70             LDR      R0,[R6, #+36]
   \        0x4   0x7001             STRB     R1,[R0, #+0]
   \        0x6   0x6A71             LDR      R1,[R6, #+36]
   \        0x8   0x8D30             LDRH     R0,[R6, #+40]
   \        0xA   0x1C4A             ADDS     R2,R1,#+1
   \        0xC   0x1E41             SUBS     R1,R0,#+1
   \        0xE   0x6272             STR      R2,[R6, #+36]
   \       0x10   0x8531             STRH     R1,[R6, #+40]
   \       0x12   0x8D70             LDRH     R0,[R6, #+42]
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine114: (+1)
   \        0x0   0x1E42             SUBS     R2,R0,#+1
   \        0x2   0x8572             STRH     R2,[R6, #+42]
   \        0x4   0x6830             LDR      R0,[R6, #+0]
   \        0x6   0x6942             LDR      R2,[R0, #+20]
   \        0x8   0x0753             LSLS     R3,R2,#+29
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine69: (+1)
   \        0x0   0x2120             MOVS     R1,#+32
   \        0x2   0x7079             STRB     R1,[R7, #+1]
   \        0x4   0x70B8             STRB     R0,[R7, #+2]
   \        0x6   0x6879             LDR      R1,[R7, #+4]
   \        0x8   0xF041 0x0120      ORR      R1,R1,#0x20
   \        0xC   0x6079             STR      R1,[R7, #+4]
   \        0xE   0x7038             STRB     R0,[R7, #+0]
   \       0x10   0x4770             BX       LR
   1635          
   1636          /**
   1637            * @brief  Transmit in master mode an amount of data in non-blocking mode with Interrupt
   1638            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1639            *                the configuration information for the specified I2C.
   1640            * @param  DevAddress Target device address: The device 7 bits address value
   1641            *         in datasheet must be shifted to the left before calling the interface
   1642            * @param  pData Pointer to data buffer
   1643            * @param  Size Amount of data to be sent
   1644            * @retval HAL status
   1645            */

   \                                 In section .text, align 2, keep-with-next
   1646          HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1647          {
   \                     HAL_I2C_Master_Transmit_IT: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine4
   1648            __IO uint32_t count = 0U;
   1649          
   1650            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x8   0xD128             BNE.N    ??HAL_I2C_Master_Transmit_IT_0
   1651            {
   1652              /* Wait until BUSY flag is reset */
   1653              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \        0xA   0x....'....        BL       ?Subroutine113
   \                     ??CrossCallReturnLabel_331: (+1)
   \        0xE   0xF04F 0x0E19      MOV      LR,#+25
   \       0x12   0xFBB7 0xFEFE      UDIV     LR,R7,LR
   \       0x16   0xF44F 0x787A      MOV      R8,#+1000
   \       0x1A   0xFBBE 0xF8F8      UDIV     R8,LR,R8
   \       0x1E   0x....'....        BL       ?Subroutine65
   1654              do
   1655              {
   1656                count--;
   \                     ??CrossCallReturnLabel_192: (+1)
   \       0x22   0x9800             LDR      R0,[SP, #+0]
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0x9000             STR      R0,[SP, #+0]
   1657                if (count == 0U)
   \       0x28   0x9800             LDR      R0,[SP, #+0]
   \       0x2A   0xB1A0             CBZ.N    R0,??HAL_I2C_Master_Transmit_IT_1
   1658                {
   1659                  hi2c->PreviousState       = I2C_STATE_NONE;
   1660                  hi2c->State               = HAL_I2C_STATE_READY;
   1661                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   1662                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   1663          
   1664                  /* Process Unlocked */
   1665                  __HAL_UNLOCK(hi2c);
   1666          
   1667                  return HAL_ERROR;
   1668                }
   1669              }
   1670              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x2C   0x....'....        BL       ?Subroutine64
   \                     ??CrossCallReturnLabel_186: (+1)
   \       0x30   0xD4F7             BMI.N    ??CrossCallReturnLabel_192
   1671          
   1672              /* Process Locked */
   1673              __HAL_LOCK(hi2c);
   \       0x32   0x7828             LDRB     R0,[R5, #+0]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD011             BEQ.N    ??HAL_I2C_Master_Transmit_IT_0
   \       0x38   0x....'....        BL       ?Subroutine36
   1674          
   1675              /* Check if the I2C is already enabled */
   1676              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_97: (+1)
   \       0x3C   0xD401             BMI.N    ??CrossCallReturnLabel_71
   1677              {
   1678                /* Enable I2C peripheral */
   1679                __HAL_I2C_ENABLE(hi2c);
   \       0x3E   0x....'....        BL       ?Subroutine28
   1680              }
   1681          
   1682              /* Disable Pos */
   1683              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   1684          
   1685              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   1686              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \                     ??CrossCallReturnLabel_71: (+1)
   \       0x42   0x....'....        BL       ?Subroutine32
   \                     ??CrossCallReturnLabel_88: (+1)
   \       0x46   0x....'....        BL       ?Subroutine9
   1687              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1688          
   1689              /* Prepare transfer parameters */
   1690              hi2c->pBuffPtr    = pData;
   1691              hi2c->XferCount   = Size;
   1692              hi2c->XferSize    = hi2c->XferCount;
   1693              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1694              hi2c->Devaddress  = DevAddress;
   1695          
   1696              /* Generate Start */
   1697              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x4A   0xF441 0x7180      ORR      R1,R1,#0x100
   \       0x4E   0x6001             STR      R1,[R0, #+0]
   1698          
   1699              /* Process Unlocked */
   1700              __HAL_UNLOCK(hi2c);
   \       0x50   0x....'....        BL       ?Subroutine8
   1701          
   1702              /* Note : The I2C interrupts must be enabled after unlocking current process
   1703                        to avoid the risk of I2C interrupt handle execution before current
   1704                        process unlock */
   1705              /* Enable EVT, BUF and ERR interrupt */
   1706              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   1707          
   1708              return HAL_OK;
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x54   0xE003             B.N      ??HAL_I2C_Master_Transmit_IT_2
   \                     ??HAL_I2C_Master_Transmit_IT_1: (+1)
   \       0x56   0x....'....        BL       ?Subroutine24
   1709            }
   \                     ??CrossCallReturnLabel_49: (+1)
   \       0x5A   0xE000             B.N      ??HAL_I2C_Master_Transmit_IT_2
   1710            else
   1711            {
   1712              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_IT_0: (+1)
   \       0x5C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_IT_2: (+1)
   \       0x5E   0xE8BD 0x81F2      POP      {R1,R4-R8,PC}    ;; return
   1713            }
   1714          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine32: (+1)
   \        0x0   0x2610             MOVS     R6,#+16
   \                     ??Subroutine32_0: (+1)
   \        0x2   0x6820             LDR      R0,[R4, #+0]
   \        0x4   0x6807             LDR      R7,[R0, #+0]
   \        0x6   0xF427 0x6700      BIC      R7,R7,#0x800
   \        0xA   0x6007             STR      R7,[R0, #+0]
   \        0xC   0x2021             MOVS     R0,#+33
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x7068             STRB     R0,[R5, #+1]
   \        0x2   0x70AE             STRB     R6,[R5, #+2]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x6068             STR      R0,[R5, #+4]
   \        0x8   0x6262             STR      R2,[R4, #+36]
   \        0xA   0x8563             STRH     R3,[R4, #+42]
   \        0xC   0x8D60             LDRH     R0,[R4, #+42]
   \        0xE   0x....'....        LDR.W    R2,??DataTable15_1  ;; 0xffff0000
   \       0x12   0x8520             STRH     R0,[R4, #+40]
   \       0x14   0x62E2             STR      R2,[R4, #+44]
   \       0x16   0x60A9             STR      R1,[R5, #+8]
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x7028             STRB     R0,[R5, #+0]
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6841             LDR      R1,[R0, #+4]
   \        0x8   0xF441 0x61E0      ORR      R1,R1,#0x700
   \        0xC   0x6041             STR      R1,[R0, #+4]
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \                     ??Subroutine4_0: (+1)
   \        0x6   0xF104 0x053C      ADD      R5,R4,#+60
   \        0xA   0x7868             LDRB     R0,[R5, #+1]
   \        0xC   0x2820             CMP      R0,#+32
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine113: (+1)
   \        0x0   0x....'....        LDR.W    R6,??DataTable25
   \        0x4   0x6837             LDR      R7,[R6, #+0]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine64: (+1)
   \        0x0   0x6826             LDR      R6,[R4, #+0]
   \        0x2   0x69B0             LDR      R0,[R6, #+24]
   \        0x4   0x0786             LSLS     R6,R0,#+30
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine36: (+1)
   \        0x0   0x2601             MOVS     R6,#+1
   \        0x2   0x702E             STRB     R6,[R5, #+0]
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6807             LDR      R7,[R0, #+0]
   \        0x8   0x07FE             LSLS     R6,R7,#+31
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine28: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6807             LDR      R7,[R0, #+0]
   \        0x4   0xF047 0x0701      ORR      R7,R7,#0x1
   \        0x8   0x6007             STR      R7,[R0, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine24: (+1)
   \        0x0   0x6320             STR      R0,[R4, #+48]
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x7069             STRB     R1,[R5, #+1]
   \        0x6   0x70A8             STRB     R0,[R5, #+2]
   \        0x8   0x6869             LDR      R1,[R5, #+4]
   \        0xA   0xF041 0x0120      ORR      R1,R1,#0x20
   \        0xE   0x6069             STR      R1,[R5, #+4]
   \       0x10   0x7028             STRB     R0,[R5, #+0]
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine65: (+1)
   \        0x0   0x2019             MOVS     R0,#+25
   \        0x2   0xFB00 0xF008      MUL      R0,R0,R8
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x4770             BX       LR
   1715          
   1716          /**
   1717            * @brief  Receive in master mode an amount of data in non-blocking mode with Interrupt
   1718            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1719            *                the configuration information for the specified I2C.
   1720            * @param  DevAddress Target device address: The device 7 bits address value
   1721            *         in datasheet must be shifted to the left before calling the interface
   1722            * @param  pData Pointer to data buffer
   1723            * @param  Size Amount of data to be sent
   1724            * @retval HAL status
   1725            */

   \                                 In section .text, align 2, keep-with-next
   1726          HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1727          {
   \                     HAL_I2C_Master_Receive_IT: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine4
   1728            __IO uint32_t count = 0U;
   1729          
   1730            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x8   0xD127             BNE.N    ??HAL_I2C_Master_Receive_IT_0
   1731            {
   1732              /* Wait until BUSY flag is reset */
   1733              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \        0xA   0x....'....        BL       ?Subroutine113
   \                     ??CrossCallReturnLabel_332: (+1)
   \        0xE   0xF04F 0x0E19      MOV      LR,#+25
   \       0x12   0xFBB7 0xFEFE      UDIV     LR,R7,LR
   \       0x16   0xF44F 0x787A      MOV      R8,#+1000
   \       0x1A   0xFBBE 0xF8F8      UDIV     R8,LR,R8
   \       0x1E   0x....'....        BL       ?Subroutine65
   1734              do
   1735              {
   1736                count--;
   \                     ??CrossCallReturnLabel_193: (+1)
   \       0x22   0x9800             LDR      R0,[SP, #+0]
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0x9000             STR      R0,[SP, #+0]
   1737                if (count == 0U)
   \       0x28   0x9800             LDR      R0,[SP, #+0]
   \       0x2A   0xB198             CBZ.N    R0,??HAL_I2C_Master_Receive_IT_1
   1738                {
   1739                  hi2c->PreviousState       = I2C_STATE_NONE;
   1740                  hi2c->State               = HAL_I2C_STATE_READY;
   1741                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   1742                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   1743          
   1744                  /* Process Unlocked */
   1745                  __HAL_UNLOCK(hi2c);
   1746          
   1747                  return HAL_ERROR;
   1748                }
   1749              }
   1750              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x2C   0x....'....        BL       ?Subroutine64
   \                     ??CrossCallReturnLabel_187: (+1)
   \       0x30   0xD4F7             BMI.N    ??CrossCallReturnLabel_193
   1751          
   1752              /* Process Locked */
   1753              __HAL_LOCK(hi2c);
   \       0x32   0x7828             LDRB     R0,[R5, #+0]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD010             BEQ.N    ??HAL_I2C_Master_Receive_IT_0
   \       0x38   0x....'....        BL       ?Subroutine36
   1754          
   1755              /* Check if the I2C is already enabled */
   1756              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_98: (+1)
   \       0x3C   0xD401             BMI.N    ??CrossCallReturnLabel_72
   1757              {
   1758                /* Enable I2C peripheral */
   1759                __HAL_I2C_ENABLE(hi2c);
   \       0x3E   0x....'....        BL       ?Subroutine28
   1760              }
   1761          
   1762              /* Disable Pos */
   1763              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   1764          
   1765              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   1766              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \                     ??CrossCallReturnLabel_72: (+1)
   \       0x42   0x....'....        BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_113: (+1)
   \       0x46   0x....'....        BL       ?Subroutine9
   1767              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1768          
   1769              /* Prepare transfer parameters */
   1770              hi2c->pBuffPtr    = pData;
   1771              hi2c->XferCount   = Size;
   1772              hi2c->XferSize    = hi2c->XferCount;
   1773              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1774              hi2c->Devaddress  = DevAddress;
   1775          
   1776              /* Enable Acknowledge */
   1777              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x4A   0x....'....        BL       ?Subroutine42
   1778          
   1779              /* Generate Start */
   1780              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   1781          
   1782              /* Process Unlocked */
   1783              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_115: (+1)
   \       0x4E   0x....'....        BL       ?Subroutine8
   1784          
   1785              /* Note : The I2C interrupts must be enabled after unlocking current process
   1786              to avoid the risk of I2C interrupt handle execution before current
   1787              process unlock */
   1788          
   1789              /* Enable EVT, BUF and ERR interrupt */
   1790              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   1791          
   1792              return HAL_OK;
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x52   0xE003             B.N      ??HAL_I2C_Master_Receive_IT_2
   \                     ??HAL_I2C_Master_Receive_IT_1: (+1)
   \       0x54   0x....'....        BL       ?Subroutine24
   1793            }
   \                     ??CrossCallReturnLabel_50: (+1)
   \       0x58   0xE000             B.N      ??HAL_I2C_Master_Receive_IT_2
   1794            else
   1795            {
   1796              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_IT_0: (+1)
   \       0x5A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_IT_2: (+1)
   \       0x5C   0xE8BD 0x81F2      POP      {R1,R4-R8,PC}    ;; return
   1797            }
   1798          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine41: (+1)
   \        0x0   0x2610             MOVS     R6,#+16
   \        0x2   0x6820             LDR      R0,[R4, #+0]
   \        0x4   0x6807             LDR      R7,[R0, #+0]
   \        0x6   0xF427 0x6700      BIC      R7,R7,#0x800
   \        0xA   0x6007             STR      R7,[R0, #+0]
   \        0xC   0x2022             MOVS     R0,#+34
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine42: (+1)
   \        0x0   0xF441 0x6180      ORR      R1,R1,#0x400
   \        0x4   0x6001             STR      R1,[R0, #+0]
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x6802             LDR      R2,[R0, #+0]
   \        0xA   0xF442 0x7280      ORR      R2,R2,#0x100
   \        0xE   0x6002             STR      R2,[R0, #+0]
   \       0x10   0x4770             BX       LR
   1799          
   1800          /**
   1801            * @brief  Transmit in slave mode an amount of data in non-blocking mode with Interrupt
   1802            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1803            *         the configuration information for the specified I2C.
   1804            * @param  pData Pointer to data buffer
   1805            * @param  Size Amount of data to be sent
   1806            * @retval HAL status
   1807            */

   \                                 In section .text, align 2, keep-with-next
   1808          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1809          {
   \                     HAL_I2C_Slave_Transmit_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   1810          
   1811            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x2   0xF100 0x033C      ADD      R3,R0,#+60
   \        0x6   0x785C             LDRB     R4,[R3, #+1]
   \        0x8   0x2C20             CMP      R4,#+32
   \        0xA   0xD10B             BNE.N    ??HAL_I2C_Slave_Transmit_IT_0
   1812            {
   1813              if ((pData == NULL) || (Size == 0U))
   \        0xC   0xB109             CBZ.N    R1,??HAL_I2C_Slave_Transmit_IT_1
   \        0xE   0x0014             MOVS     R4,R2
   \       0x10   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_IT_2
   1814              {
   1815                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_IT_1: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xBD70             POP      {R4-R6,PC}
   1816              }
   1817          
   1818              /* Process Locked */
   1819              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_IT_2: (+1)
   \       0x16   0x781C             LDRB     R4,[R3, #+0]
   \       0x18   0x2C01             CMP      R4,#+1
   \       0x1A   0xD003             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_0
   \       0x1C   0x....'....        BL       ?Subroutine62
   1820          
   1821              /* Check if the I2C is already enabled */
   1822              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   1823              {
   1824                /* Enable I2C peripheral */
   1825                __HAL_I2C_ENABLE(hi2c);
   1826              }
   1827          
   1828              /* Disable Pos */
   1829              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   1830          
   1831              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \                     ??CrossCallReturnLabel_181: (+1)
   \       0x20   0x2421             MOVS     R4,#+33
   \       0x22   0x....             B.N      ?Subroutine1
   1832              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   1833              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1834          
   1835              /* Prepare transfer parameters */
   1836              hi2c->pBuffPtr    = pData;
   1837              hi2c->XferCount   = Size;
   1838              hi2c->XferSize    = hi2c->XferCount;
   1839              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1840          
   1841              /* Enable Address Acknowledge */
   1842              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   1843          
   1844              /* Process Unlocked */
   1845              __HAL_UNLOCK(hi2c);
   1846          
   1847              /* Note : The I2C interrupts must be enabled after unlocking current process
   1848                        to avoid the risk of I2C interrupt handle execution before current
   1849                        process unlock */
   1850          
   1851              /* Enable EVT, BUF and ERR interrupt */
   1852              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   1853          
   1854              return HAL_OK;
   1855            }
   1856            else
   1857            {
   1858              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_IT_0: (+1)
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return
   1859            }
   1860          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine62: (+1)
   \        0x0   0x2501             MOVS     R5,#+1
   \        0x2   0x701D             STRB     R5,[R3, #+0]
   \        0x4   0x6804             LDR      R4,[R0, #+0]
   \        0x6   0x6826             LDR      R6,[R4, #+0]
   \        0x8   0x07F5             LSLS     R5,R6,#+31
   \        0xA   0xD403             BMI.N    ??Subroutine62_0
   \        0xC   0x6826             LDR      R6,[R4, #+0]
   \        0xE   0xF046 0x0601      ORR      R6,R6,#0x1
   \       0x12   0x6026             STR      R6,[R4, #+0]
   \                     ??Subroutine62_0: (+1)
   \       0x14   0x6804             LDR      R4,[R0, #+0]
   \       0x16   0x6825             LDR      R5,[R4, #+0]
   \       0x18   0xF425 0x6500      BIC      R5,R5,#0x800
   \       0x1C   0x6025             STR      R5,[R4, #+0]
   \       0x1E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x705C             STRB     R4,[R3, #+1]
   \        0x2   0x2520             MOVS     R5,#+32
   \        0x4   0x709D             STRB     R5,[R3, #+2]
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0x605C             STR      R4,[R3, #+4]
   \        0xA   0x6241             STR      R1,[R0, #+36]
   \        0xC   0x8542             STRH     R2,[R0, #+42]
   \        0xE   0x8D41             LDRH     R1,[R0, #+42]
   \       0x10   0x....'....        LDR.W    R2,??DataTable15_1  ;; 0xffff0000
   \       0x14   0x8501             STRH     R1,[R0, #+40]
   \       0x16   0x62C2             STR      R2,[R0, #+44]
   \       0x18   0x....'....        BL       ?Subroutine56
   \                     ??CrossCallReturnLabel_159: (+1)
   \       0x1C   0x7019             STRB     R1,[R3, #+0]
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0x6842             LDR      R2,[R0, #+4]
   \       0x22   0xF442 0x62E0      ORR      R2,R2,#0x700
   \       0x26   0x6042             STR      R2,[R0, #+4]
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine56: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x680C             LDR      R4,[R1, #+0]
   \        0x4   0xF444 0x6480      ORR      R4,R4,#0x400
   \        0x8   0x600C             STR      R4,[R1, #+0]
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x4770             BX       LR
   1861          
   1862          /**
   1863            * @brief  Receive in slave mode an amount of data in non-blocking mode with Interrupt
   1864            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1865            *                the configuration information for the specified I2C.
   1866            * @param  pData Pointer to data buffer
   1867            * @param  Size Amount of data to be sent
   1868            * @retval HAL status
   1869            */

   \                                 In section .text, align 2, keep-with-next
   1870          HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1871          {
   \                     HAL_I2C_Slave_Receive_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   1872          
   1873            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x2   0xF100 0x033C      ADD      R3,R0,#+60
   \        0x6   0x785C             LDRB     R4,[R3, #+1]
   \        0x8   0x2C20             CMP      R4,#+32
   \        0xA   0xD10B             BNE.N    ??HAL_I2C_Slave_Receive_IT_0
   1874            {
   1875              if ((pData == NULL) || (Size == 0U))
   \        0xC   0xB109             CBZ.N    R1,??HAL_I2C_Slave_Receive_IT_1
   \        0xE   0x0014             MOVS     R4,R2
   \       0x10   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_IT_2
   1876              {
   1877                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_IT_1: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xBD70             POP      {R4-R6,PC}
   1878              }
   1879          
   1880              /* Process Locked */
   1881              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_IT_2: (+1)
   \       0x16   0x781C             LDRB     R4,[R3, #+0]
   \       0x18   0x2C01             CMP      R4,#+1
   \       0x1A   0xD003             BEQ.N    ??HAL_I2C_Slave_Receive_IT_0
   \       0x1C   0x....'....        BL       ?Subroutine62
   1882          
   1883              /* Check if the I2C is already enabled */
   1884              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   1885              {
   1886                /* Enable I2C peripheral */
   1887                __HAL_I2C_ENABLE(hi2c);
   1888              }
   1889          
   1890              /* Disable Pos */
   1891              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   1892          
   1893              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \                     ??CrossCallReturnLabel_182: (+1)
   \       0x20   0x2422             MOVS     R4,#+34
   \       0x22   0x....             B.N      ?Subroutine1
   1894              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   1895              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1896          
   1897              /* Prepare transfer parameters */
   1898              hi2c->pBuffPtr    = pData;
   1899              hi2c->XferCount   = Size;
   1900              hi2c->XferSize    = hi2c->XferCount;
   1901              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1902          
   1903              /* Enable Address Acknowledge */
   1904              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   1905          
   1906              /* Process Unlocked */
   1907              __HAL_UNLOCK(hi2c);
   1908          
   1909              /* Note : The I2C interrupts must be enabled after unlocking current process
   1910                        to avoid the risk of I2C interrupt handle execution before current
   1911                        process unlock */
   1912          
   1913              /* Enable EVT, BUF and ERR interrupt */
   1914              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   1915          
   1916              return HAL_OK;
   1917            }
   1918            else
   1919            {
   1920              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_IT_0: (+1)
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return
   1921            }
   1922          }
   1923          
   1924          /**
   1925            * @brief  Transmit in master mode an amount of data in non-blocking mode with DMA
   1926            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1927            *                the configuration information for the specified I2C.
   1928            * @param  DevAddress Target device address: The device 7 bits address value
   1929            *         in datasheet must be shifted to the left before calling the interface
   1930            * @param  pData Pointer to data buffer
   1931            * @param  Size Amount of data to be sent
   1932            * @retval HAL status
   1933            */

   \                                 In section .text, align 2, keep-with-next
   1934          HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1935          {
   \                     HAL_I2C_Master_Transmit_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine4
   1936            __IO uint32_t count = 0U;
   1937            HAL_StatusTypeDef dmaxferstatus;
   1938          
   1939            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0x8   0xD135             BNE.N    ??HAL_I2C_Master_Transmit_DMA_0
   1940            {
   1941              /* Wait until BUSY flag is reset */
   1942              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \        0xA   0x....'....        BL       ?Subroutine113
   \                     ??CrossCallReturnLabel_333: (+1)
   \        0xE   0xF04F 0x0E19      MOV      LR,#+25
   \       0x12   0xFBB7 0xFEFE      UDIV     LR,R7,LR
   \       0x16   0xF44F 0x787A      MOV      R8,#+1000
   \       0x1A   0xFBBE 0xF8F8      UDIV     R8,LR,R8
   \       0x1E   0x....'....        BL       ?Subroutine65
   1943              do
   1944              {
   1945                count--;
   \                     ??CrossCallReturnLabel_194: (+1)
   \       0x22   0x....'....        BL       ?Subroutine98
   1946                if (count == 0U)
   \                     ??CrossCallReturnLabel_287: (+1)
   \       0x26   0xD018             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_1
   1947                {
   1948                  hi2c->PreviousState       = I2C_STATE_NONE;
   1949                  hi2c->State               = HAL_I2C_STATE_READY;
   1950                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   1951                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   1952          
   1953                  /* Process Unlocked */
   1954                  __HAL_UNLOCK(hi2c);
   1955          
   1956                  return HAL_ERROR;
   1957                }
   1958              }
   1959              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x28   0x....'....        BL       ?Subroutine64
   \                     ??CrossCallReturnLabel_188: (+1)
   \       0x2C   0xD4F9             BMI.N    ??CrossCallReturnLabel_194
   1960          
   1961              /* Process Locked */
   1962              __HAL_LOCK(hi2c);
   \       0x2E   0x7828             LDRB     R0,[R5, #+0]
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD020             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_0
   \       0x34   0x....'....        BL       ?Subroutine36
   1963          
   1964              /* Check if the I2C is already enabled */
   1965              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_99: (+1)
   \       0x38   0xD401             BMI.N    ??CrossCallReturnLabel_73
   1966              {
   1967                /* Enable I2C peripheral */
   1968                __HAL_I2C_ENABLE(hi2c);
   \       0x3A   0x....'....        BL       ?Subroutine28
   1969              }
   1970          
   1971              /* Disable Pos */
   1972              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   1973          
   1974              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   1975              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \                     ??CrossCallReturnLabel_73: (+1)
   \       0x3E   0x....'....        BL       ?Subroutine32
   \                     ??CrossCallReturnLabel_89: (+1)
   \       0x42   0x....'....        BL       ?Subroutine10
   1976              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1977          
   1978              /* Prepare transfer parameters */
   1979              hi2c->pBuffPtr    = pData;
   1980              hi2c->XferCount   = Size;
   1981              hi2c->XferSize    = hi2c->XferCount;
   1982              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1983              hi2c->Devaddress  = DevAddress;
   1984          
   1985              if (hi2c->XferSize > 0U)
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x46   0xD011             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_2
   1986              {
   1987                /* Set the I2C DMA transfer complete callback */
   1988                hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \       0x48   0x6B61             LDR      R1,[R4, #+52]
   \       0x4A   0x....'....        LDR.W    R0,??DataTable24
   \       0x4E   0x....'....        BL       ?Subroutine7
   1989          
   1990                /* Set the DMA error callback */
   1991                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   1992          
   1993                /* Set the unused DMA callbacks to NULL */
   1994                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   1995                hi2c->hdmatx->XferM1CpltCallback = NULL;
   1996                hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
   1997                hi2c->hdmatx->XferAbortCallback = NULL;
   1998          
   1999                /* Enable the DMA stream */
   2000                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   2001          
   2002                if (dmaxferstatus == HAL_OK)
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x52   0xB928             CBNZ.N   R0,??HAL_I2C_Master_Transmit_DMA_3
   2003                {
   2004                  /* Enable Acknowledge */
   2005                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x54   0x....'....        BL       ?Subroutine6
   2006          
   2007                  /* Generate Start */
   2008                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   2009          
   2010                  /* Process Unlocked */
   2011                  __HAL_UNLOCK(hi2c);
   2012          
   2013                  /* Note : The I2C interrupts must be enabled after unlocking current process
   2014                  to avoid the risk of I2C interrupt handle execution before current
   2015                  process unlock */
   2016          
   2017                  /* Enable EVT and ERR interrupt */
   2018                  __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   2019          
   2020                  /* Enable DMA Request */
   2021                  SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   2022                }
   \                     ??CrossCallReturnLabel_363: (+1)
   \       0x58   0xE00A             B.N      ??CrossCallReturnLabel_37
   \                     ??HAL_I2C_Master_Transmit_DMA_1: (+1)
   \       0x5A   0x....'....        BL       ?Subroutine26
   \                     ??CrossCallReturnLabel_64: (+1)
   \       0x5E   0xE001             B.N      ??CrossCallReturnLabel_45
   2023                else
   2024                {
   2025                  /* Update I2C state */
   2026                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Transmit_DMA_3: (+1)
   \       0x60   0x....'....        BL       ?Subroutine22
   2027                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   2028          
   2029                  /* Update I2C error code */
   2030                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \                     ??CrossCallReturnLabel_45: (+1)
   \       0x64   0x6069             STR      R1,[R5, #+4]
   2031          
   2032                  /* Process Unlocked */
   2033                  __HAL_UNLOCK(hi2c);
   \       0x66   0x7028             STRB     R0,[R5, #+0]
   2034          
   2035                  return HAL_ERROR;
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xE005             B.N      ??HAL_I2C_Master_Transmit_DMA_4
   2036                }
   2037              }
   2038              else
   2039              {
   2040                /* Enable Acknowledge */
   2041                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Transmit_DMA_2: (+1)
   \       0x6C   0x....'....        BL       ?Subroutine18
   2042          
   2043                /* Generate Start */
   2044                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   2045          
   2046                /* Process Unlocked */
   2047                __HAL_UNLOCK(hi2c);
   2048          
   2049                /* Note : The I2C interrupts must be enabled after unlocking current process
   2050                to avoid the risk of I2C interrupt handle execution before current
   2051                process unlock */
   2052          
   2053                /* Enable EVT, BUF and ERR interrupt */
   2054                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   2055              }
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x70   0x6041             STR      R1,[R0, #+4]
   2056          
   2057              return HAL_OK;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xE000             B.N      ??HAL_I2C_Master_Transmit_DMA_4
   2058            }
   2059            else
   2060            {
   2061              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_DMA_0: (+1)
   \       0x76   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_DMA_4: (+1)
   \       0x78   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2062            }
   2063          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine26: (+1)
   \        0x0   0x6320             STR      R0,[R4, #+48]
   \                     ??Subroutine26_0: (+1)
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x7069             STRB     R1,[R5, #+1]
   \        0x6   0x70A8             STRB     R0,[R5, #+2]
   \        0x8   0x6869             LDR      R1,[R5, #+4]
   \        0xA   0xF041 0x0120      ORR      R1,R1,#0x20
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x6180      ORR      R1,R1,#0x400
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6802             LDR      R2,[R0, #+0]
   \        0xE   0xF442 0x7280      ORR      R2,R2,#0x100
   \       0x12   0x6002             STR      R2,[R0, #+0]
   \       0x14                      REQUIRE ??Subroutine126_0
   \       0x14                      ;; // Fall through to label ??Subroutine126_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine126_0: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x7028             STRB     R0,[R5, #+0]
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6841             LDR      R1,[R0, #+4]
   \        0x8   0xF441 0x7140      ORR      R1,R1,#0x300
   \        0xC   0x6041             STR      R1,[R0, #+4]
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6841             LDR      R1,[R0, #+4]
   \       0x12   0xF441 0x6100      ORR      R1,R1,#0x800
   \       0x16   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine22: (+1)
   \        0x0   0x2120             MOVS     R1,#+32
   \        0x2   0x7069             STRB     R1,[R5, #+1]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x70A8             STRB     R0,[R5, #+2]
   \        0x8   0x6869             LDR      R1,[R5, #+4]
   \        0xA   0xF041 0x0110      ORR      R1,R1,#0x10
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x6180      ORR      R1,R1,#0x400
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6802             LDR      R2,[R0, #+0]
   \        0xE   0xF442 0x7280      ORR      R2,R2,#0x100
   \       0x12   0x6002             STR      R2,[R0, #+0]
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x7028             STRB     R0,[R5, #+0]
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6841             LDR      R1,[R0, #+4]
   \       0x1C   0xF441 0x61E0      ORR      R1,R1,#0x700
   \       0x20   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x7068             STRB     R0,[R5, #+1]
   \        0x2   0x70AE             STRB     R6,[R5, #+2]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x6068             STR      R0,[R5, #+4]
   \        0x8   0x6262             STR      R2,[R4, #+36]
   \        0xA   0x8563             STRH     R3,[R4, #+42]
   \        0xC   0x8D60             LDRH     R0,[R4, #+42]
   \        0xE   0x....'....        LDR.W    R2,??DataTable15_1  ;; 0xffff0000
   \       0x12   0x8520             STRH     R0,[R4, #+40]
   \       0x14   0x62E2             STR      R2,[R4, #+44]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0x60A9             STR      R1,[R5, #+8]
   \       0x1A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x63C8             STR      R0,[R1, #+60]
   \        0x2   0x6B61             LDR      R1,[R4, #+52]
   \        0x4   0x....'....        LDR.W    R0,??DataTable25_1
   \        0x8   0x64C8             STR      R0,[R1, #+76]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x6B61             LDR      R1,[R4, #+52]
   \        0xE   0x6408             STR      R0,[R1, #+64]
   \       0x10   0x6B61             LDR      R1,[R4, #+52]
   \       0x12   0x6448             STR      R0,[R1, #+68]
   \       0x14   0x6B61             LDR      R1,[R4, #+52]
   \       0x16   0x6488             STR      R0,[R1, #+72]
   \       0x18   0x6B61             LDR      R1,[R4, #+52]
   \       0x1A   0x6508             STR      R0,[R1, #+80]
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x8D23             LDRH     R3,[R4, #+40]
   \       0x20   0x6A61             LDR      R1,[R4, #+36]
   \       0x22   0xF100 0x0210      ADD      R2,R0,#+16
   \       0x26   0x6B60             LDR      R0,[R4, #+52]
   \       0x28   0x....'....        B.W      HAL_DMA_Start_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine98: (+1)
   \        0x0   0x9800             LDR      R0,[SP, #+0]
   \        0x2   0x1E40             SUBS     R0,R0,#+1
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x9800             LDR      R0,[SP, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0x4770             BX       LR
   2064          
   2065          /**
   2066            * @brief  Receive in master mode an amount of data in non-blocking mode with DMA
   2067            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2068            *                the configuration information for the specified I2C.
   2069            * @param  DevAddress Target device address: The device 7 bits address value
   2070            *         in datasheet must be shifted to the left before calling the interface
   2071            * @param  pData Pointer to data buffer
   2072            * @param  Size Amount of data to be sent
   2073            * @retval HAL status
   2074            */

   \                                 In section .text, align 2, keep-with-next
   2075          HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   2076          {
   \                     HAL_I2C_Master_Receive_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine4
   2077            __IO uint32_t count = 0U;
   2078            HAL_StatusTypeDef dmaxferstatus;
   2079          
   2080            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0x8   0xD13D             BNE.N    ??HAL_I2C_Master_Receive_DMA_0
   2081            {
   2082              /* Wait until BUSY flag is reset */
   2083              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \        0xA   0x....'....        BL       ?Subroutine113
   \                     ??CrossCallReturnLabel_334: (+1)
   \        0xE   0xF04F 0x0E19      MOV      LR,#+25
   \       0x12   0xFBB7 0xFEFE      UDIV     LR,R7,LR
   \       0x16   0xF44F 0x787A      MOV      R8,#+1000
   \       0x1A   0xFBBE 0xF8F8      UDIV     R8,LR,R8
   \       0x1E   0x....'....        BL       ?Subroutine65
   2084              do
   2085              {
   2086                count--;
   \                     ??CrossCallReturnLabel_195: (+1)
   \       0x22   0x....'....        BL       ?Subroutine98
   2087                if (count == 0U)
   \                     ??CrossCallReturnLabel_288: (+1)
   \       0x26   0xD020             BEQ.N    ??HAL_I2C_Master_Receive_DMA_1
   2088                {
   2089                  hi2c->PreviousState       = I2C_STATE_NONE;
   2090                  hi2c->State               = HAL_I2C_STATE_READY;
   2091                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   2092                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   2093          
   2094                  /* Process Unlocked */
   2095                  __HAL_UNLOCK(hi2c);
   2096          
   2097                  return HAL_ERROR;
   2098                }
   2099              }
   2100              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x28   0x....'....        BL       ?Subroutine64
   \                     ??CrossCallReturnLabel_189: (+1)
   \       0x2C   0xD4F9             BMI.N    ??CrossCallReturnLabel_195
   2101          
   2102              /* Process Locked */
   2103              __HAL_LOCK(hi2c);
   \       0x2E   0x7828             LDRB     R0,[R5, #+0]
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD028             BEQ.N    ??HAL_I2C_Master_Receive_DMA_0
   \       0x34   0x....'....        BL       ?Subroutine36
   2104          
   2105              /* Check if the I2C is already enabled */
   2106              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_100: (+1)
   \       0x38   0xD401             BMI.N    ??CrossCallReturnLabel_74
   2107              {
   2108                /* Enable I2C peripheral */
   2109                __HAL_I2C_ENABLE(hi2c);
   \       0x3A   0x....'....        BL       ?Subroutine28
   2110              }
   2111          
   2112              /* Disable Pos */
   2113              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   2114          
   2115              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   2116              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \                     ??CrossCallReturnLabel_74: (+1)
   \       0x3E   0x....'....        BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_114: (+1)
   \       0x42   0x....'....        BL       ?Subroutine10
   2117              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   2118          
   2119              /* Prepare transfer parameters */
   2120              hi2c->pBuffPtr    = pData;
   2121              hi2c->XferCount   = Size;
   2122              hi2c->XferSize    = hi2c->XferCount;
   2123              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2124              hi2c->Devaddress  = DevAddress;
   2125          
   2126              if (hi2c->XferSize > 0U)
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x46   0xD019             BEQ.N    ??HAL_I2C_Master_Receive_DMA_2
   2127              {
   2128                /* Set the I2C DMA transfer complete callback */
   2129                hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \       0x48   0x6BA1             LDR      R1,[R4, #+56]
   \       0x4A   0x....'....        LDR.W    R0,??DataTable24
   \       0x4E   0x....'....        BL       ?Subroutine15
   2130          
   2131                /* Set the DMA error callback */
   2132                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   2133          
   2134                /* Set the unused DMA callbacks to NULL */
   2135                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   2136                hi2c->hdmarx->XferM1CpltCallback = NULL;
   2137                hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
   2138                hi2c->hdmarx->XferAbortCallback = NULL;
   2139          
   2140                /* Enable the DMA stream */
   2141                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   2142          
   2143                if (dmaxferstatus == HAL_OK)
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x52   0x6826             LDR      R6,[R4, #+0]
   \       0x54   0x8D23             LDRH     R3,[R4, #+40]
   \       0x56   0x6A62             LDR      R2,[R4, #+36]
   \       0x58   0x6BA0             LDR      R0,[R4, #+56]
   \       0x5A   0xF106 0x0110      ADD      R1,R6,#+16
   \       0x5E   0x....'....        BL       HAL_DMA_Start_IT
   \       0x62   0xB928             CBNZ.N   R0,??HAL_I2C_Master_Receive_DMA_3
   2144                {
   2145                  /* Enable Acknowledge */
   2146                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x64   0x....'....        BL       ?Subroutine6
   2147          
   2148                  /* Generate Start */
   2149                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   2150          
   2151                  /* Process Unlocked */
   2152                  __HAL_UNLOCK(hi2c);
   2153          
   2154                  /* Note : The I2C interrupts must be enabled after unlocking current process
   2155                  to avoid the risk of I2C interrupt handle execution before current
   2156                  process unlock */
   2157          
   2158                  /* Enable EVT and ERR interrupt */
   2159                  __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   2160          
   2161                  /* Enable DMA Request */
   2162                  SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   2163                }
   \                     ??CrossCallReturnLabel_364: (+1)
   \       0x68   0xE00A             B.N      ??CrossCallReturnLabel_38
   \                     ??HAL_I2C_Master_Receive_DMA_1: (+1)
   \       0x6A   0x....'....        BL       ?Subroutine26
   \                     ??CrossCallReturnLabel_65: (+1)
   \       0x6E   0xE001             B.N      ??CrossCallReturnLabel_46
   2164                else
   2165                {
   2166                  /* Update I2C state */
   2167                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Receive_DMA_3: (+1)
   \       0x70   0x....'....        BL       ?Subroutine22
   2168                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   2169          
   2170                  /* Update I2C error code */
   2171                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \                     ??CrossCallReturnLabel_46: (+1)
   \       0x74   0x6069             STR      R1,[R5, #+4]
   2172          
   2173                  /* Process Unlocked */
   2174                  __HAL_UNLOCK(hi2c);
   \       0x76   0x7028             STRB     R0,[R5, #+0]
   2175          
   2176                  return HAL_ERROR;
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0xE005             B.N      ??HAL_I2C_Master_Receive_DMA_4
   2177                }
   2178              }
   2179              else
   2180              {
   2181                /* Enable Acknowledge */
   2182                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Receive_DMA_2: (+1)
   \       0x7C   0x....'....        BL       ?Subroutine18
   2183          
   2184                /* Generate Start */
   2185                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   2186          
   2187                /* Process Unlocked */
   2188                __HAL_UNLOCK(hi2c);
   2189          
   2190                /* Note : The I2C interrupts must be enabled after unlocking current process
   2191                to avoid the risk of I2C interrupt handle execution before current
   2192                process unlock */
   2193          
   2194                /* Enable EVT, BUF and ERR interrupt */
   2195                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   2196              }
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0x80   0x6041             STR      R1,[R0, #+4]
   2197          
   2198              return HAL_OK;
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xE000             B.N      ??HAL_I2C_Master_Receive_DMA_4
   2199            }
   2200            else
   2201            {
   2202              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_DMA_0: (+1)
   \       0x86   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_DMA_4: (+1)
   \       0x88   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2203            }
   2204          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0x63C8             STR      R0,[R1, #+60]
   \        0x2   0x6BA1             LDR      R1,[R4, #+56]
   \        0x4   0x....'....        LDR.W    R0,??DataTable25_1
   \        0x8   0x64C8             STR      R0,[R1, #+76]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x6BA1             LDR      R1,[R4, #+56]
   \        0xE   0x6408             STR      R0,[R1, #+64]
   \       0x10   0x6BA1             LDR      R1,[R4, #+56]
   \       0x12   0x6448             STR      R0,[R1, #+68]
   \       0x14   0x6BA1             LDR      R1,[R4, #+56]
   \       0x16   0x6488             STR      R0,[R1, #+72]
   \       0x18   0x6BA1             LDR      R1,[R4, #+56]
   \       0x1A   0x6508             STR      R0,[R1, #+80]
   \       0x1C   0x4770             BX       LR
   2205          
   2206          /**
   2207            * @brief  Transmit in slave mode an amount of data in non-blocking mode with DMA
   2208            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2209            *                the configuration information for the specified I2C.
   2210            * @param  pData Pointer to data buffer
   2211            * @param  Size Amount of data to be sent
   2212            * @retval HAL status
   2213            */

   \                                 In section .text, align 2, keep-with-next
   2214          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   2215          {
   \                     HAL_I2C_Slave_Transmit_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   2216            HAL_StatusTypeDef dmaxferstatus;
   2217          
   2218            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x4   0x....'....        BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_6: (+1)
   \        0x8   0xD114             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_0
   2219            {
   2220              if ((pData == NULL) || (Size == 0U))
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD010             BEQ.N    ??CrossCallReturnLabel_213
   \        0xE   0x0010             MOVS     R0,R2
   \       0x10   0xD00E             BEQ.N    ??CrossCallReturnLabel_213
   2221              {
   2222                return  HAL_ERROR;
   2223              }
   2224          
   2225              /* Process Locked */
   2226              __HAL_LOCK(hi2c);
   \       0x12   0x7828             LDRB     R0,[R5, #+0]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD00D             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_0
   \       0x18   0x....'....        BL       ?Subroutine31
   2227          
   2228              /* Check if the I2C is already enabled */
   2229              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   2230              {
   2231                /* Enable I2C peripheral */
   2232                __HAL_I2C_ENABLE(hi2c);
   2233              }
   2234          
   2235              /* Disable Pos */
   2236              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   2237          
   2238              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \                     ??CrossCallReturnLabel_85: (+1)
   \       0x1C   0x2021             MOVS     R0,#+33
   \       0x1E   0x....'....        BL       ?Subroutine11
   2239              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   2240              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   2241          
   2242              /* Prepare transfer parameters */
   2243              hi2c->pBuffPtr    = pData;
   2244              hi2c->XferCount   = Size;
   2245              hi2c->XferSize    = hi2c->XferCount;
   2246              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2247          
   2248              /* Set the I2C DMA transfer complete callback */
   2249              hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x22   0x6B61             LDR      R1,[R4, #+52]
   \       0x24   0x....'....        BL       ?Subroutine7
   2250          
   2251              /* Set the DMA error callback */
   2252              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   2253          
   2254              /* Set the unused DMA callbacks to NULL */
   2255              hi2c->hdmatx->XferHalfCpltCallback = NULL;
   2256              hi2c->hdmatx->XferM1CpltCallback = NULL;
   2257              hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
   2258              hi2c->hdmatx->XferAbortCallback = NULL;
   2259          
   2260              /* Enable the DMA stream */
   2261              dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   2262          
   2263              if (dmaxferstatus == HAL_OK)
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x28   0xB900             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_DMA_1
   2264              {
   2265                /* Enable Address Acknowledge */
   2266                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x2A   0x....             B.N      ?Subroutine2
   2267          
   2268                /* Process Unlocked */
   2269                __HAL_UNLOCK(hi2c);
   2270          
   2271                /* Note : The I2C interrupts must be enabled after unlocking current process
   2272                to avoid the risk of I2C interrupt handle execution before current
   2273                process unlock */
   2274                /* Enable EVT and ERR interrupt */
   2275                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   2276          
   2277                /* Enable DMA Request */
   2278                hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   2279          
   2280                return HAL_OK;
   2281              }
   2282              else
   2283              {
   2284                /* Update I2C state */
   2285                hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_1: (+1)
   \       0x2C   0x....'....        BL       ?Subroutine71
   2286                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2287          
   2288                /* Update I2C error code */
   2289                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   2290          
   2291                /* Process Unlocked */
   2292                __HAL_UNLOCK(hi2c);
   2293          
   2294                return HAL_ERROR;
   \                     ??CrossCallReturnLabel_213: (+1)
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xBD70             POP      {R4-R6,PC}
   2295              }
   2296            }
   2297            else
   2298            {
   2299              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_0: (+1)
   \       0x34   0x2002             MOVS     R0,#+2
   \       0x36   0xBD70             POP      {R4-R6,PC}       ;; return
   2300            }
   2301          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine71: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x7068             STRB     R0,[R5, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70A9             STRB     R1,[R5, #+2]
   \        0x8   0x6868             LDR      R0,[R5, #+4]
   \        0xA   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xE   0x6068             STR      R0,[R5, #+4]
   \       0x10   0x7029             STRB     R1,[R5, #+0]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine31: (+1)
   \        0x0   0x2301             MOVS     R3,#+1
   \        0x2   0x702B             STRB     R3,[R5, #+0]
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6806             LDR      R6,[R0, #+0]
   \        0x8   0x07F3             LSLS     R3,R6,#+31
   \        0xA   0xD403             BMI.N    ??Subroutine31_0
   \        0xC   0x6806             LDR      R6,[R0, #+0]
   \        0xE   0xF046 0x0601      ORR      R6,R6,#0x1
   \       0x12   0x6006             STR      R6,[R0, #+0]
   \                     ??Subroutine31_0: (+1)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6803             LDR      R3,[R0, #+0]
   \       0x18   0xF423 0x6300      BIC      R3,R3,#0x800
   \       0x1C   0x6003             STR      R3,[R0, #+0]
   \       0x1E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x7068             STRB     R0,[R5, #+1]
   \        0x2   0x2320             MOVS     R3,#+32
   \        0x4   0x70AB             STRB     R3,[R5, #+2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6068             STR      R0,[R5, #+4]
   \        0xA   0x6261             STR      R1,[R4, #+36]
   \        0xC   0x8562             STRH     R2,[R4, #+42]
   \        0xE   0x8D60             LDRH     R0,[R4, #+42]
   \       0x10   0x....             LDR.N    R1,??DataTable15_1  ;; 0xffff0000
   \       0x12   0x8520             STRH     R0,[R4, #+40]
   \       0x14   0x62E1             STR      R1,[R4, #+44]
   \       0x16   0x....'....        LDR.W    R0,??DataTable24
   \       0x1A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x....'....        BL       ?Subroutine58
   \                     ??CrossCallReturnLabel_166: (+1)
   \        0x6   0x....'....        BL       ??Subroutine126_0
   \                     ??CrossCallReturnLabel_365: (+1)
   \        0xA   0x6041             STR      R1,[R0, #+4]
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine58: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF441 0x6180      ORR      R1,R1,#0x400
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x4770             BX       LR
   2302          
   2303          /**
   2304            * @brief  Receive in slave mode an amount of data in non-blocking mode with DMA
   2305            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2306            *                the configuration information for the specified I2C.
   2307            * @param  pData Pointer to data buffer
   2308            * @param  Size Amount of data to be sent
   2309            * @retval HAL status
   2310            */

   \                                 In section .text, align 2, keep-with-next
   2311          HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   2312          {
   \                     HAL_I2C_Slave_Receive_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   2313            HAL_StatusTypeDef dmaxferstatus;
   2314          
   2315            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x4   0x....'....        BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0x8   0xD116             BNE.N    ??HAL_I2C_Slave_Receive_DMA_0
   2316            {
   2317              if ((pData == NULL) || (Size == 0U))
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD012             BEQ.N    ??CrossCallReturnLabel_214
   \        0xE   0x0010             MOVS     R0,R2
   \       0x10   0xD010             BEQ.N    ??CrossCallReturnLabel_214
   2318              {
   2319                return  HAL_ERROR;
   2320              }
   2321          
   2322              /* Process Locked */
   2323              __HAL_LOCK(hi2c);
   \       0x12   0x7828             LDRB     R0,[R5, #+0]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD00F             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_0
   \       0x18   0x....'....        BL       ?Subroutine31
   2324          
   2325              /* Check if the I2C is already enabled */
   2326              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   2327              {
   2328                /* Enable I2C peripheral */
   2329                __HAL_I2C_ENABLE(hi2c);
   2330              }
   2331          
   2332              /* Disable Pos */
   2333              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   2334          
   2335              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \                     ??CrossCallReturnLabel_86: (+1)
   \       0x1C   0x2022             MOVS     R0,#+34
   \       0x1E   0x....'....        BL       ?Subroutine11
   2336              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   2337              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   2338          
   2339              /* Prepare transfer parameters */
   2340              hi2c->pBuffPtr    = pData;
   2341              hi2c->XferCount   = Size;
   2342              hi2c->XferSize    = hi2c->XferCount;
   2343              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2344          
   2345              /* Set the I2C DMA transfer complete callback */
   2346              hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x22   0x6BA1             LDR      R1,[R4, #+56]
   \       0x24   0x....'....        BL       ?Subroutine15
   2347          
   2348              /* Set the DMA error callback */
   2349              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   2350          
   2351              /* Set the unused DMA callbacks to NULL */
   2352              hi2c->hdmarx->XferHalfCpltCallback = NULL;
   2353              hi2c->hdmarx->XferM1CpltCallback = NULL;
   2354              hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
   2355              hi2c->hdmarx->XferAbortCallback = NULL;
   2356          
   2357              /* Enable the DMA stream */
   2358              dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   2359          
   2360              if (dmaxferstatus == HAL_OK)
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x28   0x....'....        BL       ?Subroutine33
   \                     ??CrossCallReturnLabel_91: (+1)
   \       0x2C   0xB900             CBNZ.N   R0,??HAL_I2C_Slave_Receive_DMA_1
   2361              {
   2362                /* Enable Address Acknowledge */
   2363                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x2E   0x....             B.N      ?Subroutine2
   2364          
   2365                /* Process Unlocked */
   2366                __HAL_UNLOCK(hi2c);
   2367          
   2368                /* Note : The I2C interrupts must be enabled after unlocking current process
   2369                to avoid the risk of I2C interrupt handle execution before current
   2370                process unlock */
   2371                /* Enable EVT and ERR interrupt */
   2372                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   2373          
   2374                /* Enable DMA Request */
   2375                SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   2376          
   2377                return HAL_OK;
   2378              }
   2379              else
   2380              {
   2381                /* Update I2C state */
   2382                hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Receive_DMA_1: (+1)
   \       0x30   0x....'....        BL       ?Subroutine71
   2383                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2384          
   2385                /* Update I2C error code */
   2386                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   2387          
   2388                /* Process Unlocked */
   2389                __HAL_UNLOCK(hi2c);
   2390          
   2391                return HAL_ERROR;
   \                     ??CrossCallReturnLabel_214: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xBD70             POP      {R4-R6,PC}
   2392              }
   2393            }
   2394            else
   2395            {
   2396              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_DMA_0: (+1)
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0xBD70             POP      {R4-R6,PC}       ;; return
   2397            }
   2398          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine33: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x8D23             LDRH     R3,[R4, #+40]
   \        0x4   0x6A62             LDR      R2,[R4, #+36]
   \        0x6   0xF100 0x0110      ADD      R1,R0,#+16
   \        0xA   0x6BA0             LDR      R0,[R4, #+56]
   \        0xC   0x....'....        B.W      HAL_DMA_Start_IT
   2399          
   2400          /**
   2401            * @brief  Write an amount of data in blocking mode to a specific memory address
   2402            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2403            *                the configuration information for the specified I2C.
   2404            * @param  DevAddress Target device address: The device 7 bits address value
   2405            *         in datasheet must be shifted to the left before calling the interface
   2406            * @param  MemAddress Internal memory address
   2407            * @param  MemAddSize Size of internal memory address
   2408            * @param  pData Pointer to data buffer
   2409            * @param  Size Amount of data to be sent
   2410            * @param  Timeout Timeout duration
   2411            * @retval HAL status
   2412            */

   \                                 In section .text, align 2, keep-with-next
   2413          HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   2414          {
   \                     HAL_I2C_Mem_Write: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x....'....        BL       ?Subroutine75
   2415            /* Init tickstart for timeout management*/
   2416            uint32_t tickstart = HAL_GetTick();
   2417          
   2418            /* Check the parameters */
   2419            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2420          
   2421            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_227: (+1)
   \        0x8   0x....'....        BL       ?Subroutine73
   \                     ??CrossCallReturnLabel_220: (+1)
   \        0xC   0xD158             BNE.N    ??HAL_I2C_Mem_Write_0
   2422            {
   2423              /* Wait until BUSY flag is reset */
   2424              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \        0xE   0x....'....        BL       ?Subroutine77
   \                     ??CrossCallReturnLabel_232: (+1)
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD154             BNE.N    ??HAL_I2C_Mem_Write_0
   2425              {
   2426                return HAL_BUSY;
   2427              }
   2428          
   2429              /* Process Locked */
   2430              __HAL_LOCK(hi2c);
   \       0x16   0x7838             LDRB     R0,[R7, #+0]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD051             BEQ.N    ??HAL_I2C_Mem_Write_0
   \       0x1C   0x....'....        BL       ?Subroutine80
   2431          
   2432              /* Check if the I2C is already enabled */
   2433              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_247: (+1)
   \       0x20   0xD401             BMI.N    ??CrossCallReturnLabel_129
   2434              {
   2435                /* Enable I2C peripheral */
   2436                __HAL_I2C_ENABLE(hi2c);
   \       0x22   0x....'....        BL       ??Subroutine47_0
   2437              }
   \                     ??CrossCallReturnLabel_129: (+1)
   \       0x26   0x4641             MOV      R1,R8
   2438          
   2439              /* Disable Pos */
   2440              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \       0x28   0xF8D6 0xE000      LDR      LR,[R6, #+0]
   \       0x2C   0x9D0C             LDR      R5,[SP, #+48]
   \       0x2E   0x980B             LDR      R0,[SP, #+44]
   \       0x30   0xF8DD 0xC028      LDR      R12,[SP, #+40]
   \       0x34   0xF8DE 0x8000      LDR      R8,[LR, #+0]
   \       0x38   0xF428 0x6800      BIC      R8,R8,#0x800
   \       0x3C   0xF8CE 0x8000      STR      R8,[LR, #+0]
   2441          
   2442              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x40   0xF04F 0x0E21      MOV      LR,#+33
   \       0x44   0xF887 0xE001      STRB     LR,[R7, #+1]
   2443              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0x48   0xF04F 0x0840      MOV      R8,#+64
   \       0x4C   0xF887 0x8002      STRB     R8,[R7, #+2]
   2444              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x50   0xF04F 0x0E00      MOV      LR,#+0
   \       0x54   0xF8C7 0xE004      STR      LR,[R7, #+4]
   2445          
   2446              /* Prepare transfer parameters */
   2447              hi2c->pBuffPtr    = pData;
   \       0x58   0x....'....        BL       ?Subroutine89
   2448              hi2c->XferCount   = Size;
   2449              hi2c->XferSize    = hi2c->XferCount;
   2450              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2451          
   2452              /* Send Slave Address and Memory Address */
   2453              if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_269: (+1)
   \       0x5C   0x....'....        BL       I2C_RequestMemoryWrite
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD126             BNE.N    ??CrossCallReturnLabel_149
   \       0x64   0xE006             B.N      ??HAL_I2C_Mem_Write_1
   2454              {
   2455                return HAL_ERROR;
   2456              }
   2457          
   2458              while (hi2c->XferSize > 0U)
   2459              {
   2460                /* Wait until TXE flag is set */
   2461                if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   2462                {
   2463                  if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   2464                  {
   2465                    /* Generate Stop */
   2466                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   2467                  }
   2468                  return HAL_ERROR;
   2469                }
   2470          
   2471                /* Write data to DR */
   2472                hi2c->Instance->DR = *hi2c->pBuffPtr;
   2473          
   2474                /* Increment Buffer pointer */
   2475                hi2c->pBuffPtr++;
   2476          
   2477                /* Update counter */
   2478                hi2c->XferSize--;
   2479                hi2c->XferCount--;
   2480          
   2481                if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
   2482                {
   2483                  /* Write data to DR */
   2484                  hi2c->Instance->DR = *hi2c->pBuffPtr;
   \                     ??HAL_I2C_Mem_Write_2: (+1)
   \       0x66   0x6A71             LDR      R1,[R6, #+36]
   \       0x68   0x780A             LDRB     R2,[R1, #+0]
   \       0x6A   0x6102             STR      R2,[R0, #+16]
   2485          
   2486                  /* Increment Buffer pointer */
   2487                  hi2c->pBuffPtr++;
   \       0x6C   0x....'....        BL       ?Subroutine102
   2488          
   2489                  /* Update counter */
   2490                  hi2c->XferSize--;
   2491                  hi2c->XferCount--;
   2492                }
   \                     ??CrossCallReturnLabel_305: (+1)
   \       0x70   0x1E41             SUBS     R1,R0,#+1
   \       0x72   0x8571             STRH     R1,[R6, #+42]
   \                     ??HAL_I2C_Mem_Write_1: (+1)
   \       0x74   0x8D30             LDRH     R0,[R6, #+40]
   \       0x76   0xB188             CBZ.N    R0,??HAL_I2C_Mem_Write_3
   \       0x78   0x4622             MOV      R2,R4
   \       0x7A   0x4629             MOV      R1,R5
   \       0x7C   0x4630             MOV      R0,R6
   \       0x7E   0x....'....        BL       I2C_WaitOnTXEFlagUntilTimeout
   \       0x82   0xB988             CBNZ.N   R0,??HAL_I2C_Mem_Write_4
   \       0x84   0x6A70             LDR      R0,[R6, #+36]
   \       0x86   0x6832             LDR      R2,[R6, #+0]
   \       0x88   0x7801             LDRB     R1,[R0, #+0]
   \       0x8A   0x6111             STR      R1,[R2, #+16]
   \       0x8C   0x....'....        BL       ?Subroutine102
   2493              }
   \                     ??CrossCallReturnLabel_306: (+1)
   \       0x90   0x....'....        BL       ?Subroutine114
   \                     ??CrossCallReturnLabel_338: (+1)
   \       0x94   0xD5EE             BPL.N    ??HAL_I2C_Mem_Write_1
   \       0x96   0xB289             UXTH     R1,R1
   \       0x98   0x2900             CMP      R1,#+0
   \       0x9A   0xD1E4             BNE.N    ??HAL_I2C_Mem_Write_2
   2494          
   2495              /* Wait until BTF flag is set */
   2496              if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_3: (+1)
   \       0x9C   0x4622             MOV      R2,R4
   \       0x9E   0x4629             MOV      R1,R5
   \       0xA0   0x4630             MOV      R0,R6
   \       0xA2   0x....'....        BL       I2C_WaitOnBTFFlagUntilTimeout
   \       0xA6   0xB130             CBZ.N    R0,??HAL_I2C_Mem_Write_5
   2497              {
   2498                if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Write_4: (+1)
   \       0xA8   0x6878             LDR      R0,[R7, #+4]
   \       0xAA   0x2804             CMP      R0,#+4
   \       0xAC   0xD101             BNE.N    ??CrossCallReturnLabel_149
   2499                {
   2500                  /* Generate Stop */
   2501                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xAE   0x....'....        BL       ?Subroutine53
   2502                }
   2503                return HAL_ERROR;
   \                     ??CrossCallReturnLabel_149: (+1)
   \       0xB2   0x2001             MOVS     R0,#+1
   \       0xB4   0xE005             B.N      ??HAL_I2C_Mem_Write_6
   2504              }
   2505          
   2506              /* Generate Stop */
   2507              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Mem_Write_5: (+1)
   \       0xB6   0x....'....        BL       ?Subroutine53
   2508          
   2509              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??CrossCallReturnLabel_150: (+1)
   \       0xBA   0x....'....        BL       ?Subroutine83
   2510              hi2c->Mode = HAL_I2C_MODE_NONE;
   2511          
   2512              /* Process Unlocked */
   2513              __HAL_UNLOCK(hi2c);
   2514          
   2515              return HAL_OK;
   \                     ??CrossCallReturnLabel_256: (+1)
   \       0xBE   0xE000             B.N      ??HAL_I2C_Mem_Write_6
   2516            }
   2517            else
   2518            {
   2519              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_0: (+1)
   \       0xC0   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_6: (+1)
   \       0xC2   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2520            }
   2521          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine102: (+1)
   \        0x0   0x6A70             LDR      R0,[R6, #+36]
   \        0x2   0x1C41             ADDS     R1,R0,#+1
   \        0x4   0x6271             STR      R1,[R6, #+36]
   \        0x6   0x8D30             LDRH     R0,[R6, #+40]
   \        0x8   0x1E41             SUBS     R1,R0,#+1
   \        0xA   0x8531             STRH     R1,[R6, #+40]
   \        0xC   0x8D70             LDRH     R0,[R6, #+42]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine75: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \        0x2   0x4688             MOV      R8,R1
   \                     ??Subroutine75_0: (+1)
   \        0x4   0x4691             MOV      R9,R2
   \        0x6   0x469A             MOV      R10,R3
   \        0x8   0x....'....        B.W      HAL_GetTick

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine89: (+1)
   \        0x0   0xF8C6 0xC024      STR      R12,[R6, #+36]
   \        0x4   0x8570             STRH     R0,[R6, #+42]
   \        0x6   0x4653             MOV      R3,R10
   \        0x8   0x8D70             LDRH     R0,[R6, #+42]
   \        0xA   0x8530             STRH     R0,[R6, #+40]
   \        0xC   0x464A             MOV      R2,R9
   \        0xE   0x....'....        LDR.W    R0,??DataTable29  ;; 0xffff0000
   \       0x12   0x62F0             STR      R0,[R6, #+44]
   \       0x14   0x9401             STR      R4,[SP, #+4]
   \       0x16   0x9500             STR      R5,[SP, #+0]
   \       0x18   0x4630             MOV      R0,R6
   \       0x1A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine53: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \                     ??Subroutine53_0: (+1)
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x7100      ORR      R1,R1,#0x200
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x4770             BX       LR
   2522          
   2523          /**
   2524            * @brief  Read an amount of data in blocking mode from a specific memory address
   2525            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2526            *                the configuration information for the specified I2C.
   2527            * @param  DevAddress Target device address: The device 7 bits address value
   2528            *         in datasheet must be shifted to the left before calling the interface
   2529            * @param  MemAddress Internal memory address
   2530            * @param  MemAddSize Size of internal memory address
   2531            * @param  pData Pointer to data buffer
   2532            * @param  Size Amount of data to be sent
   2533            * @param  Timeout Timeout duration
   2534            * @retval HAL status
   2535            */

   \                                 In section .text, align 2, keep-with-next
   2536          HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   2537          {
   \                     HAL_I2C_Mem_Read: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x....'....        BL       ?Subroutine75
   2538            /* Init tickstart for timeout management*/
   2539            uint32_t tickstart = HAL_GetTick();
   2540          
   2541            /* Check the parameters */
   2542            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2543          
   2544            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_226: (+1)
   \        0x8   0x....'....        BL       ?Subroutine73
   \                     ??CrossCallReturnLabel_221: (+1)
   \        0xC   0xD102             BNE.N    ??HAL_I2C_Mem_Read_0
   2545            {
   2546              /* Wait until BUSY flag is reset */
   2547              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \        0xE   0x....'....        BL       ?Subroutine77
   \                     ??CrossCallReturnLabel_231: (+1)
   \       0x12   0x2800             CMP      R0,#+0
   \                     ??HAL_I2C_Mem_Read_0: (+1)
   \       0x14   0xF040 0x8081      BNE.W    ??HAL_I2C_Mem_Read_1
   2548              {
   2549                return HAL_BUSY;
   2550              }
   2551          
   2552              /* Process Locked */
   2553              __HAL_LOCK(hi2c);
   \       0x18   0x7838             LDRB     R0,[R7, #+0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD07D             BEQ.N    ??HAL_I2C_Mem_Read_1
   \       0x1E   0x....'....        BL       ?Subroutine80
   2554          
   2555              /* Check if the I2C is already enabled */
   2556              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_248: (+1)
   \       0x22   0xD401             BMI.N    ??CrossCallReturnLabel_130
   2557              {
   2558                /* Enable I2C peripheral */
   2559                __HAL_I2C_ENABLE(hi2c);
   \       0x24   0x....'....        BL       ??Subroutine47_0
   2560              }
   \                     ??CrossCallReturnLabel_130: (+1)
   \       0x28   0x4641             MOV      R1,R8
   2561          
   2562              /* Disable Pos */
   2563              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \       0x2A   0xF8D6 0xE000      LDR      LR,[R6, #+0]
   \       0x2E   0x9D0C             LDR      R5,[SP, #+48]
   \       0x30   0x980B             LDR      R0,[SP, #+44]
   \       0x32   0xF8DD 0xC028      LDR      R12,[SP, #+40]
   \       0x36   0xF8DE 0x8000      LDR      R8,[LR, #+0]
   \       0x3A   0xF428 0x6800      BIC      R8,R8,#0x800
   \       0x3E   0xF8CE 0x8000      STR      R8,[LR, #+0]
   2564          
   2565              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x42   0xF04F 0x0E22      MOV      LR,#+34
   \       0x46   0xF887 0xE001      STRB     LR,[R7, #+1]
   2566              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0x4A   0xF04F 0x0840      MOV      R8,#+64
   \       0x4E   0xF887 0x8002      STRB     R8,[R7, #+2]
   2567              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x52   0xF04F 0x0E00      MOV      LR,#+0
   \       0x56   0xF8C7 0xE004      STR      LR,[R7, #+4]
   2568          
   2569              /* Prepare transfer parameters */
   2570              hi2c->pBuffPtr    = pData;
   \       0x5A   0x....'....        BL       ?Subroutine89
   2571              hi2c->XferCount   = Size;
   2572              hi2c->XferSize    = hi2c->XferCount;
   2573              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2574          
   2575              /* Send Slave Address and Memory Address */
   2576              if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_270: (+1)
   \       0x5E   0x....'....        BL       I2C_RequestMemoryRead
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD14F             BNE.N    ??HAL_I2C_Mem_Read_2
   2577              {
   2578                return HAL_ERROR;
   2579              }
   2580          
   2581              if (hi2c->XferSize == 0U)
   \       0x66   0x8D30             LDRH     R0,[R6, #+40]
   \       0x68   0xB118             CBZ.N    R0,??CrossCallReturnLabel_168
   2582              {
   2583                /* Clear ADDR flag */
   2584                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   2585          
   2586                /* Generate Stop */
   2587                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   2588              }
   2589              else if (hi2c->XferSize == 1U)
   \       0x6A   0x2801             CMP      R0,#+1
   \       0x6C   0xD104             BNE.N    ??HAL_I2C_Mem_Read_3
   2590              {
   2591                /* Disable Acknowledge */
   2592                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x6E   0x....'....        BL       ?Subroutine59
   2593          
   2594                /* Clear ADDR flag */
   2595                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   2596          
   2597                /* Generate Stop */
   2598                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   2599              }
   \                     ??CrossCallReturnLabel_168: (+1)
   \       0x72   0x....'....        BL       ?Subroutine97
   \                     ??CrossCallReturnLabel_286: (+1)
   \       0x76   0xE017             B.N      ??CrossCallReturnLabel_313
   2600              else if (hi2c->XferSize == 2U)
   \                     ??HAL_I2C_Mem_Read_3: (+1)
   \       0x78   0x2802             CMP      R0,#+2
   \       0x7A   0xD106             BNE.N    ??HAL_I2C_Mem_Read_4
   2601              {
   2602                /* Disable Acknowledge */
   2603                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x7C   0x....'....        BL       ?Subroutine60
   2604          
   2605                /* Enable Pos */
   2606                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??CrossCallReturnLabel_172: (+1)
   \       0x80   0x....'....        BL       ?Subroutine110
   2607          
   2608                /* Clear ADDR flag */
   2609                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??CrossCallReturnLabel_326: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0x9000             STR      R0,[SP, #+0]
   \       0x88   0xE001             B.N      ??HAL_I2C_Mem_Read_5
   2610              }
   2611              else
   2612              {
   2613                /* Clear ADDR flag */
   2614                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Mem_Read_4: (+1)
   \       0x8A   0x2100             MOVS     R1,#+0
   \       0x8C   0x9100             STR      R1,[SP, #+0]
   \                     ??HAL_I2C_Mem_Read_5: (+1)
   \       0x8E   0x....'....        BL       ??Subroutine99_0
   \                     ??CrossCallReturnLabel_299: (+1)
   \       0x92   0xE009             B.N      ??CrossCallReturnLabel_313
   2615              }
   2616          
   2617              while (hi2c->XferSize > 0U)
   2618              {
   2619                if (hi2c->XferSize <= 3U)
   2620                {
   2621                  /* One byte */
   2622                  if (hi2c->XferSize == 1U)
   2623                  {
   2624                    /* Wait until RXNE flag is set */
   2625                    if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_6: (+1)
   \       0x94   0x4622             MOV      R2,R4
   \       0x96   0x4629             MOV      R1,R5
   \       0x98   0x....'....        BL       ??Subroutine107_0
   \                     ??CrossCallReturnLabel_317: (+1)
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD132             BNE.N    ??HAL_I2C_Mem_Read_2
   2626                    {
   2627                      return HAL_ERROR;
   2628                    }
   2629          
   2630                    /* Read data from DR */
   2631                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \       0xA0   0x....'....        BL       ?Subroutine109
   2632          
   2633                    /* Increment Buffer pointer */
   2634                    hi2c->pBuffPtr++;
   2635          
   2636                    /* Update counter */
   2637                    hi2c->XferSize--;
   \                     ??CrossCallReturnLabel_324: (+1)
   \       0xA4   0x....'....        BL       ?Subroutine105
   2638                    hi2c->XferCount--;
   2639                  }
   \                     ??CrossCallReturnLabel_313: (+1)
   \       0xA8   0x8D30             LDRH     R0,[R6, #+40]
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD032             BEQ.N    ??HAL_I2C_Mem_Read_7
   \       0xAE   0x2804             CMP      R0,#+4
   \       0xB0   0xD224             BCS.N    ??HAL_I2C_Mem_Read_8
   \       0xB2   0x2801             CMP      R0,#+1
   \       0xB4   0xD0EE             BEQ.N    ??HAL_I2C_Mem_Read_6
   2640                  /* Two bytes */
   2641                  else if (hi2c->XferSize == 2U)
   \       0xB6   0x2802             CMP      R0,#+2
   \       0xB8   0x....'....        LDR.W    R8,??DataTable17  ;; 0x10004
   \       0xBC   0x9400             STR      R4,[SP, #+0]
   \       0xBE   0x462B             MOV      R3,R5
   \       0xC0   0xD10C             BNE.N    ??HAL_I2C_Mem_Read_9
   2642                  {
   2643                    /* Wait until BTF flag is set */
   2644                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \       0xC2   0x2200             MOVS     R2,#+0
   \       0xC4   0x4641             MOV      R1,R8
   \       0xC6   0x....'....        BL       ??Subroutine78_1
   \                     ??CrossCallReturnLabel_236: (+1)
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD11B             BNE.N    ??HAL_I2C_Mem_Read_2
   2645                    {
   2646                      return HAL_ERROR;
   2647                    }
   2648          
   2649                    /* Generate Stop */
   2650                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Mem_Read_10: (+1)
   \       0xCE   0x....'....        BL       ?Subroutine51
   2651          
   2652                    /* Read data from DR */
   2653                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   2654          
   2655                    /* Increment Buffer pointer */
   2656                    hi2c->pBuffPtr++;
   2657          
   2658                    /* Update counter */
   2659                    hi2c->XferSize--;
   2660                    hi2c->XferCount--;
   2661          
   2662                    /* Read data from DR */
   2663                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??CrossCallReturnLabel_142: (+1)
   \       0xD2   0x6A71             LDR      R1,[R6, #+36]
   \       0xD4   0x7008             STRB     R0,[R1, #+0]
   2664          
   2665                    /* Increment Buffer pointer */
   2666                    hi2c->pBuffPtr++;
   \       0xD6   0x6A70             LDR      R0,[R6, #+36]
   \       0xD8   0x1C42             ADDS     R2,R0,#+1
   \       0xDA   0xE7E3             B.N      ??CrossCallReturnLabel_324
   2667          
   2668                    /* Update counter */
   2669                    hi2c->XferSize--;
   2670                    hi2c->XferCount--;
   2671                  }
   2672                  /* 3 Last bytes */
   2673                  else
   2674                  {
   2675                    /* Wait until BTF flag is set */
   2676                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_9: (+1)
   \       0xDC   0x2200             MOVS     R2,#+0
   \       0xDE   0x4641             MOV      R1,R8
   \       0xE0   0x....'....        BL       ??Subroutine78_1
   \                     ??CrossCallReturnLabel_235: (+1)
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD10E             BNE.N    ??HAL_I2C_Mem_Read_2
   2677                    {
   2678                      return HAL_ERROR;
   2679                    }
   2680          
   2681                    /* Disable Acknowledge */
   2682                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xE8   0x....'....        BL       ?Subroutine60
   2683          
   2684                    /* Read data from DR */
   2685                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   2686          
   2687                    /* Increment Buffer pointer */
   2688                    hi2c->pBuffPtr++;
   2689          
   2690                    /* Update counter */
   2691                    hi2c->XferSize--;
   2692                    hi2c->XferCount--;
   2693          
   2694                    /* Wait until BTF flag is set */
   2695                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_173: (+1)
   \       0xEC   0x462B             MOV      R3,R5
   \       0xEE   0x....'....        BL       ?Subroutine93
   \                     ??CrossCallReturnLabel_276: (+1)
   \       0xF2   0x4641             MOV      R1,R8
   \       0xF4   0x....'....        BL       ??Subroutine78_1
   \                     ??CrossCallReturnLabel_234: (+1)
   \       0xF8   0xB928             CBNZ.N   R0,??HAL_I2C_Mem_Read_2
   2696                    {
   2697                      return HAL_ERROR;
   2698                    }
   2699          
   2700                    /* Generate Stop */
   2701                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xFA   0xE7E8             B.N      ??HAL_I2C_Mem_Read_10
   2702          
   2703                    /* Read data from DR */
   2704                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   2705          
   2706                    /* Increment Buffer pointer */
   2707                    hi2c->pBuffPtr++;
   2708          
   2709                    /* Update counter */
   2710                    hi2c->XferSize--;
   2711                    hi2c->XferCount--;
   2712          
   2713                    /* Read data from DR */
   2714                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   2715          
   2716                    /* Increment Buffer pointer */
   2717                    hi2c->pBuffPtr++;
   2718          
   2719                    /* Update counter */
   2720                    hi2c->XferSize--;
   2721                    hi2c->XferCount--;
   2722                  }
   2723                }
   2724                else
   2725                {
   2726                  /* Wait until RXNE flag is set */
   2727                  if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_8: (+1)
   \       0xFC   0x4622             MOV      R2,R4
   \       0xFE   0x4629             MOV      R1,R5
   \      0x100   0x....'....        BL       ??Subroutine107_0
   \                     ??CrossCallReturnLabel_316: (+1)
   \      0x104   0xB108             CBZ.N    R0,??HAL_I2C_Mem_Read_11
   2728                  {
   2729                    return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_2: (+1)
   \      0x106   0x2001             MOVS     R0,#+1
   \      0x108   0xE008             B.N      ??HAL_I2C_Mem_Read_12
   2730                  }
   2731          
   2732                  /* Read data from DR */
   2733                  *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??HAL_I2C_Mem_Read_11: (+1)
   \      0x10A   0x....'....        BL       ?Subroutine104
   2734          
   2735                  /* Increment Buffer pointer */
   2736                  hi2c->pBuffPtr++;
   2737          
   2738                  /* Update counter */
   2739                  hi2c->XferSize--;
   2740                  hi2c->XferCount--;
   2741          
   2742                  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \                     ??CrossCallReturnLabel_311: (+1)
   \      0x10E   0xD5CB             BPL.N    ??CrossCallReturnLabel_313
   2743                  {
   2744                    /* Read data from DR */
   2745                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x110   0x6900             LDR      R0,[R0, #+16]
   \      0x112   0xE7DE             B.N      ??CrossCallReturnLabel_142
   2746          
   2747                    /* Increment Buffer pointer */
   2748                    hi2c->pBuffPtr++;
   2749          
   2750                    /* Update counter */
   2751                    hi2c->XferSize--;
   2752                    hi2c->XferCount--;
   2753                  }
   2754                }
   2755              }
   2756          
   2757              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Mem_Read_7: (+1)
   \      0x114   0x....'....        BL       ?Subroutine83
   2758              hi2c->Mode = HAL_I2C_MODE_NONE;
   2759          
   2760              /* Process Unlocked */
   2761              __HAL_UNLOCK(hi2c);
   2762          
   2763              return HAL_OK;
   \                     ??CrossCallReturnLabel_257: (+1)
   \      0x118   0xE000             B.N      ??HAL_I2C_Mem_Read_12
   2764            }
   2765            else
   2766            {
   2767              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_1: (+1)
   \      0x11A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_12: (+1)
   \      0x11C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2768            }
   2769          }
   2770          
   2771          /**
   2772            * @brief  Write an amount of data in non-blocking mode with Interrupt to a specific memory address
   2773            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2774            *                the configuration information for the specified I2C.
   2775            * @param  DevAddress Target device address: The device 7 bits address value
   2776            *         in datasheet must be shifted to the left before calling the interface
   2777            * @param  MemAddress Internal memory address
   2778            * @param  MemAddSize Size of internal memory address
   2779            * @param  pData Pointer to data buffer
   2780            * @param  Size Amount of data to be sent
   2781            * @retval HAL status
   2782            */

   \                                 In section .text, align 2, keep-with-next
   2783          HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2784          {
   \                     HAL_I2C_Mem_Write_IT: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine4
   2785            __IO uint32_t count = 0U;
   2786          
   2787            /* Check the parameters */
   2788            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2789          
   2790            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0x8   0xD128             BNE.N    ??HAL_I2C_Mem_Write_IT_0
   2791            {
   2792              /* Wait until BUSY flag is reset */
   2793              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \        0xA   0x....'....        BL       ?Subroutine113
   \                     ??CrossCallReturnLabel_335: (+1)
   \        0xE   0xF04F 0x0E19      MOV      LR,#+25
   \       0x12   0xFBB7 0xFEFE      UDIV     LR,R7,LR
   \       0x16   0xF44F 0x787A      MOV      R8,#+1000
   \       0x1A   0xFBBE 0xF8F8      UDIV     R8,LR,R8
   \       0x1E   0x....'....        BL       ?Subroutine65
   2794              do
   2795              {
   2796                count--;
   \                     ??CrossCallReturnLabel_196: (+1)
   \       0x22   0x....'....        BL       ?Subroutine98
   2797                if (count == 0U)
   \                     ??CrossCallReturnLabel_289: (+1)
   \       0x26   0xD016             BEQ.N    ??HAL_I2C_Mem_Write_IT_1
   2798                {
   2799                  hi2c->PreviousState       = I2C_STATE_NONE;
   2800                  hi2c->State               = HAL_I2C_STATE_READY;
   2801                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   2802                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   2803          
   2804                  /* Process Unlocked */
   2805                  __HAL_UNLOCK(hi2c);
   2806          
   2807                  return HAL_ERROR;
   2808                }
   2809              }
   2810              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x28   0x....'....        BL       ?Subroutine64
   \                     ??CrossCallReturnLabel_190: (+1)
   \       0x2C   0xD4F9             BMI.N    ??CrossCallReturnLabel_196
   2811          
   2812              /* Process Locked */
   2813              __HAL_LOCK(hi2c);
   \       0x2E   0x7828             LDRB     R0,[R5, #+0]
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD013             BEQ.N    ??HAL_I2C_Mem_Write_IT_0
   \       0x34   0x....'....        BL       ?Subroutine36
   2814          
   2815              /* Check if the I2C is already enabled */
   2816              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_101: (+1)
   \       0x38   0xD401             BMI.N    ??CrossCallReturnLabel_75
   2817              {
   2818                /* Enable I2C peripheral */
   2819                __HAL_I2C_ENABLE(hi2c);
   \       0x3A   0x....'....        BL       ?Subroutine28
   2820              }
   2821          
   2822              /* Disable Pos */
   2823              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??CrossCallReturnLabel_75: (+1)
   \       0x3E   0x....'....        BL       ?Subroutine118
   2824          
   2825              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \                     ??CrossCallReturnLabel_346: (+1)
   \       0x42   0x2721             MOVS     R7,#+33
   \       0x44   0x....'....        BL       ?Subroutine87
   2826              hi2c->Mode      = HAL_I2C_MODE_MEM;
   2827              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   2828          
   2829              /* Prepare transfer parameters */
   2830              hi2c->pBuffPtr    = pData;
   2831              hi2c->XferCount   = Size;
   2832              hi2c->XferSize    = hi2c->XferCount;
   2833              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2834              hi2c->Devaddress  = DevAddress;
   2835              hi2c->Memaddress  = MemAddress;
   2836              hi2c->MemaddSize  = MemAddSize;
   2837              hi2c->EventCount  = 0U;
   2838          
   2839              /* Generate Start */
   2840              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??CrossCallReturnLabel_265: (+1)
   \       0x48   0x....'....        BL       ?Subroutine29
   2841          
   2842              /* Process Unlocked */
   2843              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_79: (+1)
   \       0x4C   0x702F             STRB     R7,[R5, #+0]
   2844          
   2845              /* Note : The I2C interrupts must be enabled after unlocking current process
   2846              to avoid the risk of I2C interrupt handle execution before current
   2847              process unlock */
   2848          
   2849              /* Enable EVT, BUF and ERR interrupt */
   2850              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x4E   0x....'....        BL       ?Subroutine44
   2851          
   2852              return HAL_OK;
   \                     ??CrossCallReturnLabel_119: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xE003             B.N      ??HAL_I2C_Mem_Write_IT_2
   \                     ??HAL_I2C_Mem_Write_IT_1: (+1)
   \       0x56   0x....'....        BL       ?Subroutine24
   2853            }
   \                     ??CrossCallReturnLabel_51: (+1)
   \       0x5A   0xE000             B.N      ??HAL_I2C_Mem_Write_IT_2
   2854            else
   2855            {
   2856              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_IT_0: (+1)
   \       0x5C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_IT_2: (+1)
   \       0x5E   0xE8BD 0x81F2      POP      {R1,R4-R8,PC}    ;; return
   2857            }
   2858          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine118: (+1)
   \        0x0   0x6827             LDR      R7,[R4, #+0]
   \        0x2   0x9808             LDR      R0,[SP, #+32]
   \        0x4   0x9E07             LDR      R6,[SP, #+28]
   \        0x6   0xF8D7 0xC000      LDR      R12,[R7, #+0]
   \        0xA   0xF42C 0x6C00      BIC      R12,R12,#0x800
   \        0xE   0xF8C7 0xC000      STR      R12,[R7, #+0]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine87: (+1)
   \        0x0   0x706F             STRB     R7,[R5, #+1]
   \        0x2   0x2740             MOVS     R7,#+64
   \        0x4   0x70AF             STRB     R7,[R5, #+2]
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0x606F             STR      R7,[R5, #+4]
   \        0xA   0x6266             STR      R6,[R4, #+36]
   \        0xC   0x8560             STRH     R0,[R4, #+42]
   \        0xE   0x....'....        LDR.W    R6,??DataTable30  ;; 0xffff0000
   \       0x12   0x8D60             LDRH     R0,[R4, #+42]
   \       0x14   0x8520             STRH     R0,[R4, #+40]
   \       0x16   0x62E6             STR      R6,[R4, #+44]
   \       0x18   0x60A9             STR      R1,[R5, #+8]
   \       0x1A   0x60EA             STR      R2,[R5, #+12]
   \       0x1C   0x612B             STR      R3,[R5, #+16]
   \       0x1E   0x616F             STR      R7,[R5, #+20]
   \       0x20   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine44: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0xF441 0x61E0      ORR      R1,R1,#0x700
   \        0x8   0x6041             STR      R1,[R0, #+4]
   \        0xA   0x4770             BX       LR
   2859          
   2860          /**
   2861            * @brief  Read an amount of data in non-blocking mode with Interrupt from a specific memory address
   2862            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2863            *                the configuration information for the specified I2C.
   2864            * @param  DevAddress Target device address
   2865            * @param  MemAddress Internal memory address
   2866            * @param  MemAddSize Size of internal memory address
   2867            * @param  pData Pointer to data buffer
   2868            * @param  Size Amount of data to be sent
   2869            * @retval HAL status
   2870            */

   \                                 In section .text, align 2, keep-with-next
   2871          HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2872          {
   \                     HAL_I2C_Mem_Read_IT: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine4
   2873            __IO uint32_t count = 0U;
   2874          
   2875            /* Check the parameters */
   2876            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2877          
   2878            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0x8   0xD12C             BNE.N    ??HAL_I2C_Mem_Read_IT_0
   2879            {
   2880              /* Wait until BUSY flag is reset */
   2881              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \        0xA   0x....'....        BL       ?Subroutine113
   \                     ??CrossCallReturnLabel_336: (+1)
   \        0xE   0xF04F 0x0E19      MOV      LR,#+25
   \       0x12   0xFBB7 0xFEFE      UDIV     LR,R7,LR
   \       0x16   0xF44F 0x787A      MOV      R8,#+1000
   \       0x1A   0xFBBE 0xF8F8      UDIV     R8,LR,R8
   \       0x1E   0x....'....        BL       ?Subroutine65
   2882              do
   2883              {
   2884                count--;
   \                     ??CrossCallReturnLabel_197: (+1)
   \       0x22   0x....'....        BL       ?Subroutine98
   2885                if (count == 0U)
   \                     ??CrossCallReturnLabel_290: (+1)
   \       0x26   0xD01A             BEQ.N    ??HAL_I2C_Mem_Read_IT_1
   2886                {
   2887                  hi2c->PreviousState       = I2C_STATE_NONE;
   2888                  hi2c->State               = HAL_I2C_STATE_READY;
   2889                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   2890                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   2891          
   2892                  /* Process Unlocked */
   2893                  __HAL_UNLOCK(hi2c);
   2894          
   2895                  return HAL_ERROR;
   2896                }
   2897              }
   2898              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x28   0x....'....        BL       ?Subroutine64
   \                     ??CrossCallReturnLabel_191: (+1)
   \       0x2C   0xD4F9             BMI.N    ??CrossCallReturnLabel_197
   2899          
   2900              /* Process Locked */
   2901              __HAL_LOCK(hi2c);
   \       0x2E   0x7828             LDRB     R0,[R5, #+0]
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD017             BEQ.N    ??HAL_I2C_Mem_Read_IT_0
   \       0x34   0x....'....        BL       ?Subroutine36
   2902          
   2903              /* Check if the I2C is already enabled */
   2904              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_102: (+1)
   \       0x38   0xD401             BMI.N    ??CrossCallReturnLabel_76
   2905              {
   2906                /* Enable I2C peripheral */
   2907                __HAL_I2C_ENABLE(hi2c);
   \       0x3A   0x....'....        BL       ?Subroutine28
   2908              }
   2909          
   2910              /* Disable Pos */
   2911              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??CrossCallReturnLabel_76: (+1)
   \       0x3E   0x....'....        BL       ?Subroutine118
   2912          
   2913              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \                     ??CrossCallReturnLabel_347: (+1)
   \       0x42   0x2722             MOVS     R7,#+34
   \       0x44   0x....'....        BL       ?Subroutine87
   2914              hi2c->Mode      = HAL_I2C_MODE_MEM;
   2915              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   2916          
   2917              /* Prepare transfer parameters */
   2918              hi2c->pBuffPtr    = pData;
   2919              hi2c->XferCount   = Size;
   2920              hi2c->XferSize    = hi2c->XferCount;
   2921              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2922              hi2c->Devaddress  = DevAddress;
   2923              hi2c->Memaddress  = MemAddress;
   2924              hi2c->MemaddSize  = MemAddSize;
   2925              hi2c->EventCount  = 0U;
   2926          
   2927              /* Enable Acknowledge */
   2928              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??CrossCallReturnLabel_266: (+1)
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0x....'....        BL       ?Subroutine42
   2929          
   2930              /* Generate Start */
   2931              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   2932          
   2933              /* Process Unlocked */
   2934              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_116: (+1)
   \       0x50   0x702F             STRB     R7,[R5, #+0]
   2935          
   2936              if (hi2c->XferSize > 0U)
   \       0x52   0x8D20             LDRH     R0,[R4, #+40]
   \       0x54   0xB108             CBZ.N    R0,??CrossCallReturnLabel_120
   2937              {
   2938                /* Note : The I2C interrupts must be enabled after unlocking current process
   2939                to avoid the risk of I2C interrupt handle execution before current
   2940                process unlock */
   2941          
   2942                /* Enable EVT, BUF and ERR interrupt */
   2943                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x56   0x....'....        BL       ?Subroutine44
   2944              }
   2945              return HAL_OK;
   \                     ??CrossCallReturnLabel_120: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xE003             B.N      ??HAL_I2C_Mem_Read_IT_2
   \                     ??HAL_I2C_Mem_Read_IT_1: (+1)
   \       0x5E   0x....'....        BL       ?Subroutine24
   2946            }
   \                     ??CrossCallReturnLabel_52: (+1)
   \       0x62   0xE000             B.N      ??HAL_I2C_Mem_Read_IT_2
   2947            else
   2948            {
   2949              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_IT_0: (+1)
   \       0x64   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_IT_2: (+1)
   \       0x66   0xE8BD 0x81F2      POP      {R1,R4-R8,PC}    ;; return
   2950            }
   2951          }
   2952          
   2953          /**
   2954            * @brief  Write an amount of data in non-blocking mode with DMA to a specific memory address
   2955            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2956            *                the configuration information for the specified I2C.
   2957            * @param  DevAddress Target device address: The device 7 bits address value
   2958            *         in datasheet must be shifted to the left before calling the interface
   2959            * @param  MemAddress Internal memory address
   2960            * @param  MemAddSize Size of internal memory address
   2961            * @param  pData Pointer to data buffer
   2962            * @param  Size Amount of data to be sent
   2963            * @retval HAL status
   2964            */

   \                                 In section .text, align 2, keep-with-next
   2965          HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2966          {
   \                     HAL_I2C_Mem_Write_DMA: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   2967            __IO uint32_t count = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9000             STR      R0,[SP, #+0]
   \        0xA   0x460C             MOV      R4,R1
   \        0xC   0x....'....        BL       ?Subroutine76
   2968            HAL_StatusTypeDef dmaxferstatus;
   2969          
   2970            /* Init tickstart for timeout management*/
   2971            uint32_t tickstart = HAL_GetTick();
   2972          
   2973            /* Check the parameters */
   2974            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2975          
   2976            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_230: (+1)
   \       0x10   0xF106 0x053C      ADD      R5,R6,#+60
   \       0x14   0x4607             MOV      R7,R0
   \       0x16   0x7868             LDRB     R0,[R5, #+1]
   \       0x18   0x2820             CMP      R0,#+32
   \       0x1A   0xD16A             BNE.N    ??HAL_I2C_Mem_Write_DMA_0
   2977            {
   2978              /* Wait until BUSY flag is reset */
   2979              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x1C   0x....'....        BL       ?Subroutine119
   \                     ??CrossCallReturnLabel_348: (+1)
   \       0x20   0xF44F 0x7E7A      MOV      LR,#+1000
   \       0x24   0xFBB3 0xFEFE      UDIV     LR,R3,LR
   \       0x28   0x2019             MOVS     R0,#+25
   \       0x2A   0xFB00 0xF00E      MUL      R0,R0,LR
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   2980              do
   2981              {
   2982                count--;
   \                     ??HAL_I2C_Mem_Write_DMA_1: (+1)
   \       0x30   0x....'....        BL       ?Subroutine98
   2983                if (count == 0U)
   \                     ??CrossCallReturnLabel_291: (+1)
   \       0x34   0xD038             BEQ.N    ??HAL_I2C_Mem_Write_DMA_2
   2984                {
   2985                  hi2c->PreviousState       = I2C_STATE_NONE;
   2986                  hi2c->State               = HAL_I2C_STATE_READY;
   2987                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   2988                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   2989          
   2990                  /* Process Unlocked */
   2991                  __HAL_UNLOCK(hi2c);
   2992          
   2993                  return HAL_ERROR;
   2994                }
   2995              }
   2996              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x36   0x6831             LDR      R1,[R6, #+0]
   \       0x38   0x6988             LDR      R0,[R1, #+24]
   \       0x3A   0x0781             LSLS     R1,R0,#+30
   \       0x3C   0xD4F8             BMI.N    ??HAL_I2C_Mem_Write_DMA_1
   2997          
   2998              /* Process Locked */
   2999              __HAL_LOCK(hi2c);
   \       0x3E   0x7828             LDRB     R0,[R5, #+0]
   \       0x40   0x2801             CMP      R0,#+1
   \       0x42   0xD056             BEQ.N    ??HAL_I2C_Mem_Write_DMA_0
   \       0x44   0x2101             MOVS     R1,#+1
   \       0x46   0x7029             STRB     R1,[R5, #+0]
   3000          
   3001              /* Check if the I2C is already enabled */
   3002              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x48   0x6830             LDR      R0,[R6, #+0]
   \       0x4A   0x6802             LDR      R2,[R0, #+0]
   \       0x4C   0x07D1             LSLS     R1,R2,#+31
   \       0x4E   0xD401             BMI.N    ??CrossCallReturnLabel_131
   3003              {
   3004                /* Enable I2C peripheral */
   3005                __HAL_I2C_ENABLE(hi2c);
   \       0x50   0x....'....        BL       ?Subroutine47
   3006              }
   3007          
   3008              /* Disable Pos */
   3009              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??CrossCallReturnLabel_131: (+1)
   \       0x54   0x6832             LDR      R2,[R6, #+0]
   \       0x56   0x....'....        BL       ?Subroutine120
   3010          
   3011              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \                     ??CrossCallReturnLabel_350: (+1)
   \       0x5A   0x2221             MOVS     R2,#+33
   \       0x5C   0x706A             STRB     R2,[R5, #+1]
   3012              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0x5E   0x2340             MOVS     R3,#+64
   \       0x60   0x70AB             STRB     R3,[R5, #+2]
   3013              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x62   0x2200             MOVS     R2,#+0
   \       0x64   0x606A             STR      R2,[R5, #+4]
   3014          
   3015              /* Prepare transfer parameters */
   3016              hi2c->pBuffPtr    = pData;
   \       0x66   0x6271             STR      R1,[R6, #+36]
   3017              hi2c->XferCount   = Size;
   \       0x68   0x8570             STRH     R0,[R6, #+42]
   3018              hi2c->XferSize    = hi2c->XferCount;
   3019              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x6A   0x....'....        LDR.W    R1,??DataTable30  ;; 0xffff0000
   \       0x6E   0x8D70             LDRH     R0,[R6, #+42]
   \       0x70   0x8530             STRH     R0,[R6, #+40]
   3020          
   3021              if (hi2c->XferSize > 0U)
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0x62F1             STR      R1,[R6, #+44]
   \       0x76   0xD032             BEQ.N    ??HAL_I2C_Mem_Write_DMA_3
   3022              {
   3023                /* Set the I2C DMA transfer complete callback */
   3024                hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \       0x78   0x....'....        BL       ?Subroutine117
   3025          
   3026                /* Set the DMA error callback */
   3027                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   3028          
   3029                /* Set the unused DMA callbacks to NULL */
   3030                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \                     ??CrossCallReturnLabel_344: (+1)
   \       0x7C   0x6B71             LDR      R1,[R6, #+52]
   \       0x7E   0x640A             STR      R2,[R1, #+64]
   3031                hi2c->hdmatx->XferM1CpltCallback = NULL;
   \       0x80   0x6B71             LDR      R1,[R6, #+52]
   \       0x82   0x644A             STR      R2,[R1, #+68]
   3032                hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
   \       0x84   0x6B71             LDR      R1,[R6, #+52]
   \       0x86   0x648A             STR      R2,[R1, #+72]
   3033                hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x88   0x6B71             LDR      R1,[R6, #+52]
   \       0x8A   0x650A             STR      R2,[R1, #+80]
   3034          
   3035                /* Enable the DMA stream */
   3036                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   3037          
   3038                if (dmaxferstatus == HAL_OK)
   \       0x8C   0x....'....        BL       ?Subroutine108
   \                     ??CrossCallReturnLabel_322: (+1)
   \       0x90   0xBB10             CBNZ.N   R0,??HAL_I2C_Mem_Write_DMA_4
   3039                {
   3040                  /* Send Slave Address and Memory Address */
   3041                  if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \       0x92   0x2023             MOVS     R0,#+35
   \       0x94   0x9000             STR      R0,[SP, #+0]
   \       0x96   0x9701             STR      R7,[SP, #+4]
   \       0x98   0x464B             MOV      R3,R9
   \       0x9A   0x4642             MOV      R2,R8
   \       0x9C   0x4621             MOV      R1,R4
   \       0x9E   0x4630             MOV      R0,R6
   \       0xA0   0x....'....        BL       I2C_RequestMemoryWrite
   \       0xA4   0xB130             CBZ.N    R0,??HAL_I2C_Mem_Write_DMA_5
   3042                  {
   3043                    return HAL_ERROR;
   \       0xA6   0xE022             B.N      ??HAL_I2C_Mem_Write_DMA_6
   3044                  }
   \                     ??HAL_I2C_Mem_Write_DMA_2: (+1)
   \       0xA8   0x6330             STR      R0,[R6, #+48]
   \       0xAA   0x....'....        BL       ??Subroutine26_0
   \                     ??CrossCallReturnLabel_66: (+1)
   \       0xAE   0x6069             STR      R1,[R5, #+4]
   \       0xB0   0x7028             STRB     R0,[R5, #+0]
   \       0xB2   0xE01C             B.N      ??HAL_I2C_Mem_Write_DMA_6
   3045          
   3046                  /* Clear ADDR flag */
   3047                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Mem_Write_DMA_5: (+1)
   \       0xB4   0x2100             MOVS     R1,#+0
   \       0xB6   0x9100             STR      R1,[SP, #+0]
   \       0xB8   0x6831             LDR      R1,[R6, #+0]
   \       0xBA   0x694A             LDR      R2,[R1, #+20]
   \       0xBC   0x9200             STR      R2,[SP, #+0]
   3048          
   3049                  /* Process Unlocked */
   3050                  __HAL_UNLOCK(hi2c);
   \       0xBE   0x2200             MOVS     R2,#+0
   \       0xC0   0x698B             LDR      R3,[R1, #+24]
   \       0xC2   0x9300             STR      R3,[SP, #+0]
   \       0xC4   0x9800             LDR      R0,[SP, #+0]
   \       0xC6   0x702A             STRB     R2,[R5, #+0]
   3051          
   3052                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3053                  to avoid the risk of I2C interrupt handle execution before current
   3054                  process unlock */
   3055                  /* Enable ERR interrupt */
   3056                  __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
   \       0xC8   0x684B             LDR      R3,[R1, #+4]
   \       0xCA   0xF443 0x7380      ORR      R3,R3,#0x100
   \       0xCE   0x604B             STR      R3,[R1, #+4]
   3057          
   3058                  /* Enable DMA Request */
   3059                  SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \       0xD0   0x....'....        BL       ?Subroutine111
   3060          
   3061                  return HAL_OK;
   \                     ??CrossCallReturnLabel_327: (+1)
   \       0xD4   0x2000             MOVS     R0,#+0
   \       0xD6   0xE00D             B.N      ??HAL_I2C_Mem_Write_DMA_7
   3062                }
   3063                else
   3064                {
   3065                  /* Update I2C state */
   3066                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Mem_Write_DMA_4: (+1)
   \       0xD8   0x....'....        BL       ?Subroutine71
   3067                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   3068          
   3069                  /* Update I2C error code */
   3070                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   3071          
   3072                  /* Process Unlocked */
   3073                  __HAL_UNLOCK(hi2c);
   3074          
   3075                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_215: (+1)
   \       0xDC   0xE007             B.N      ??HAL_I2C_Mem_Write_DMA_6
   3076                }
   3077              }
   3078              else
   3079              {
   3080                /* Update I2C state */
   3081                hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Mem_Write_DMA_3: (+1)
   \       0xDE   0x2020             MOVS     R0,#+32
   \       0xE0   0x7068             STRB     R0,[R5, #+1]
   3082                hi2c->Mode      = HAL_I2C_MODE_NONE;
   \       0xE2   0x70AA             STRB     R2,[R5, #+2]
   3083          
   3084                /* Update I2C error code */
   3085                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \       0xE4   0x6868             LDR      R0,[R5, #+4]
   \       0xE6   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0xEA   0x6068             STR      R0,[R5, #+4]
   3086          
   3087                /* Process Unlocked */
   3088                __HAL_UNLOCK(hi2c);
   \       0xEC   0x702A             STRB     R2,[R5, #+0]
   3089          
   3090                return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_DMA_6: (+1)
   \       0xEE   0x2001             MOVS     R0,#+1
   \       0xF0   0xE000             B.N      ??HAL_I2C_Mem_Write_DMA_7
   3091              }
   3092            }
   3093            else
   3094            {
   3095              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_DMA_0: (+1)
   \       0xF2   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_DMA_7: (+1)
   \       0xF4   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   3096            }
   3097          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine120: (+1)
   \        0x0   0x980B             LDR      R0,[SP, #+44]
   \        0x2   0x990A             LDR      R1,[SP, #+40]
   \        0x4   0x6813             LDR      R3,[R2, #+0]
   \        0x6   0xF423 0x6300      BIC      R3,R3,#0x800
   \        0xA   0x6013             STR      R3,[R2, #+0]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine119: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable25
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x2319             MOVS     R3,#+25
   \        0x8   0xFBB2 0xF3F3      UDIV     R3,R2,R3
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine117: (+1)
   \        0x0   0x6B71             LDR      R1,[R6, #+52]
   \        0x2   0x....             LDR.N    R0,??DataTable24
   \        0x4   0x63C8             STR      R0,[R1, #+60]
   \        0x6   0x6B71             LDR      R1,[R6, #+52]
   \        0x8   0x....             LDR.N    R0,??DataTable25_1
   \        0xA   0x64C8             STR      R0,[R1, #+76]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine111: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0xF441 0x6100      ORR      R1,R1,#0x800
   \        0x8   0x6041             STR      R1,[R0, #+4]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine108: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x8D33             LDRH     R3,[R6, #+40]
   \        0x4   0x6A71             LDR      R1,[R6, #+36]
   \        0x6   0xF100 0x0210      ADD      R2,R0,#+16
   \        0xA   0x6B70             LDR      R0,[R6, #+52]
   \        0xC   0x....'....        B.W      HAL_DMA_Start_IT
   3098          
   3099          /**
   3100            * @brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.
   3101            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3102            *                the configuration information for the specified I2C.
   3103            * @param  DevAddress Target device address: The device 7 bits address value
   3104            *         in datasheet must be shifted to the left before calling the interface
   3105            * @param  MemAddress Internal memory address
   3106            * @param  MemAddSize Size of internal memory address
   3107            * @param  pData Pointer to data buffer
   3108            * @param  Size Amount of data to be read
   3109            * @retval HAL status
   3110            */

   \                                 In section .text, align 2, keep-with-next
   3111          HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   3112          {
   \                     HAL_I2C_Mem_Read_DMA: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x....'....        BL       ?Subroutine76
   3113            /* Init tickstart for timeout management*/
   3114            uint32_t tickstart = HAL_GetTick();
   \                     ??CrossCallReturnLabel_229: (+1)
   \        0xC   0x4606             MOV      R6,R0
   3115            __IO uint32_t count = 0U;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9000             STR      R0,[SP, #+0]
   3116            HAL_StatusTypeDef dmaxferstatus;
   3117          
   3118            /* Check the parameters */
   3119            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   3120          
   3121            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x12   0xF104 0x073C      ADD      R7,R4,#+60
   \       0x16   0x7878             LDRB     R0,[R7, #+1]
   \       0x18   0x2820             CMP      R0,#+32
   \       0x1A   0xD171             BNE.N    ??HAL_I2C_Mem_Read_DMA_0
   3122            {
   3123              /* Wait until BUSY flag is reset */
   3124              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x1C   0x....'....        BL       ?Subroutine119
   \                     ??CrossCallReturnLabel_349: (+1)
   \       0x20   0xF44F 0x7E7A      MOV      LR,#+1000
   \       0x24   0xFBB3 0xFEFE      UDIV     LR,R3,LR
   \       0x28   0x2019             MOVS     R0,#+25
   \       0x2A   0xFB00 0xF00E      MUL      R0,R0,LR
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   3125              do
   3126              {
   3127                count--;
   \                     ??HAL_I2C_Mem_Read_DMA_1: (+1)
   \       0x30   0x....'....        BL       ?Subroutine98
   3128                if (count == 0U)
   \                     ??CrossCallReturnLabel_292: (+1)
   \       0x34   0xD03B             BEQ.N    ??HAL_I2C_Mem_Read_DMA_2
   3129                {
   3130                  hi2c->PreviousState       = I2C_STATE_NONE;
   3131                  hi2c->State               = HAL_I2C_STATE_READY;
   3132                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   3133                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   3134          
   3135                  /* Process Unlocked */
   3136                  __HAL_UNLOCK(hi2c);
   3137          
   3138                  return HAL_ERROR;
   3139                }
   3140              }
   3141              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x6988             LDR      R0,[R1, #+24]
   \       0x3A   0x0781             LSLS     R1,R0,#+30
   \       0x3C   0xD4F8             BMI.N    ??HAL_I2C_Mem_Read_DMA_1
   3142          
   3143              /* Process Locked */
   3144              __HAL_LOCK(hi2c);
   \       0x3E   0x7838             LDRB     R0,[R7, #+0]
   \       0x40   0x2801             CMP      R0,#+1
   \       0x42   0xD05D             BEQ.N    ??HAL_I2C_Mem_Read_DMA_0
   \       0x44   0x....'....        BL       ?Subroutine82
   3145          
   3146              /* Check if the I2C is already enabled */
   3147              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??CrossCallReturnLabel_252: (+1)
   \       0x48   0xD401             BMI.N    ??CrossCallReturnLabel_117
   3148              {
   3149                /* Enable I2C peripheral */
   3150                __HAL_I2C_ENABLE(hi2c);
   \       0x4A   0x....'....        BL       ?Subroutine43
   3151              }
   3152          
   3153              /* Disable Pos */
   3154              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??CrossCallReturnLabel_117: (+1)
   \       0x4E   0x6822             LDR      R2,[R4, #+0]
   \       0x50   0x....'....        BL       ?Subroutine120
   3155          
   3156              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \                     ??CrossCallReturnLabel_351: (+1)
   \       0x54   0x2222             MOVS     R2,#+34
   \       0x56   0x707A             STRB     R2,[R7, #+1]
   3157              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0x58   0x2340             MOVS     R3,#+64
   \       0x5A   0x70BB             STRB     R3,[R7, #+2]
   3158              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x5C   0x2200             MOVS     R2,#+0
   \       0x5E   0x607A             STR      R2,[R7, #+4]
   3159          
   3160              /* Prepare transfer parameters */
   3161              hi2c->pBuffPtr    = pData;
   \       0x60   0x6261             STR      R1,[R4, #+36]
   3162              hi2c->XferCount   = Size;
   \       0x62   0x8560             STRH     R0,[R4, #+42]
   3163              hi2c->XferSize    = hi2c->XferCount;
   3164              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x64   0x....'....        LDR.W    R1,??DataTable29  ;; 0xffff0000
   \       0x68   0x8D60             LDRH     R0,[R4, #+42]
   \       0x6A   0x8520             STRH     R0,[R4, #+40]
   3165          
   3166              if (hi2c->XferSize > 0U)
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0x62E1             STR      R1,[R4, #+44]
   \       0x70   0xD037             BEQ.N    ??HAL_I2C_Mem_Read_DMA_3
   3167              {
   3168                /* Set the I2C DMA transfer complete callback */
   3169                hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \       0x72   0x6BA1             LDR      R1,[R4, #+56]
   \       0x74   0x....'....        LDR.W    R0,??DataTable24
   \       0x78   0x63C8             STR      R0,[R1, #+60]
   3170          
   3171                /* Set the DMA error callback */
   3172                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \       0x7A   0x6BA1             LDR      R1,[R4, #+56]
   \       0x7C   0x....'....        LDR.W    R0,??DataTable25_1
   \       0x80   0x64C8             STR      R0,[R1, #+76]
   3173          
   3174                /* Set the unused DMA callbacks to NULL */
   3175                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \       0x82   0x6BA1             LDR      R1,[R4, #+56]
   \       0x84   0x640A             STR      R2,[R1, #+64]
   3176                hi2c->hdmarx->XferM1CpltCallback = NULL;
   \       0x86   0x6BA1             LDR      R1,[R4, #+56]
   \       0x88   0x644A             STR      R2,[R1, #+68]
   3177                hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
   \       0x8A   0x6BA1             LDR      R1,[R4, #+56]
   \       0x8C   0x648A             STR      R2,[R1, #+72]
   3178                hi2c->hdmarx->XferAbortCallback = NULL;
   \       0x8E   0x6BA1             LDR      R1,[R4, #+56]
   \       0x90   0x650A             STR      R2,[R1, #+80]
   3179          
   3180                /* Enable the DMA stream */
   3181                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   3182          
   3183                if (dmaxferstatus == HAL_OK)
   \       0x92   0x....'....        BL       ?Subroutine33
   \                     ??CrossCallReturnLabel_90: (+1)
   \       0x96   0xBB08             CBNZ.N   R0,??HAL_I2C_Mem_Read_DMA_4
   3184                {
   3185                  /* Send Slave Address and Memory Address */
   3186                  if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \       0x98   0x....'....        BL       ?Subroutine100
   \                     ??CrossCallReturnLabel_302: (+1)
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD123             BNE.N    ??HAL_I2C_Mem_Read_DMA_5
   3187                  {
   3188                    return HAL_ERROR;
   3189                  }
   3190          
   3191                  if (hi2c->XferSize == 1U)
   \       0xA0   0x8D20             LDRH     R0,[R4, #+40]
   \       0xA2   0x2801             CMP      R0,#+1
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0xD106             BNE.N    ??HAL_I2C_Mem_Read_DMA_6
   3192                  {
   3193                    /* Disable Acknowledge */
   3194                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xA8   0x....'....        BL       ??Subroutine60_0
   3195                  }
   \                     ??CrossCallReturnLabel_174: (+1)
   \       0xAC   0xE005             B.N      ??CrossCallReturnLabel_339
   \                     ??HAL_I2C_Mem_Read_DMA_2: (+1)
   \       0xAE   0x6320             STR      R0,[R4, #+48]
   \       0xB0   0x....'....        BL       ?Subroutine69
   \                     ??CrossCallReturnLabel_209: (+1)
   \       0xB4   0xE018             B.N      ??HAL_I2C_Mem_Read_DMA_5
   3196                  else
   3197                  {
   3198                    /* Enable Last DMA bit */
   3199                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??HAL_I2C_Mem_Read_DMA_6: (+1)
   \       0xB6   0x....'....        BL       ?Subroutine115
   3200                  }
   3201          
   3202                  /* Clear ADDR flag */
   3203                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??CrossCallReturnLabel_339: (+1)
   \       0xBA   0x....'....        BL       ?Subroutine17
   3204          
   3205                  /* Process Unlocked */
   3206                  __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0xBE   0x2200             MOVS     R2,#+0
   \       0xC0   0x698B             LDR      R3,[R1, #+24]
   \       0xC2   0x9300             STR      R3,[SP, #+0]
   \       0xC4   0x9800             LDR      R0,[SP, #+0]
   \       0xC6   0x703A             STRB     R2,[R7, #+0]
   3207          
   3208                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3209                  to avoid the risk of I2C interrupt handle execution before current
   3210                  process unlock */
   3211                  /* Enable ERR interrupt */
   3212                  __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
   \       0xC8   0x684B             LDR      R3,[R1, #+4]
   \       0xCA   0xF443 0x7380      ORR      R3,R3,#0x100
   \       0xCE   0x604B             STR      R3,[R1, #+4]
   3213          
   3214                  /* Enable DMA Request */
   3215                  hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   \       0xD0   0x6820             LDR      R0,[R4, #+0]
   \       0xD2   0x6841             LDR      R1,[R0, #+4]
   \       0xD4   0xF441 0x6100      ORR      R1,R1,#0x800
   \       0xD8   0x6041             STR      R1,[R0, #+4]
   \       0xDA   0xE00F             B.N      ??HAL_I2C_Mem_Read_DMA_7
   3216                }
   3217                else
   3218                {
   3219                  /* Update I2C state */
   3220                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Mem_Read_DMA_4: (+1)
   \       0xDC   0x....'....        BL       ?Subroutine84
   3221                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   3222          
   3223                  /* Update I2C error code */
   3224                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   3225          
   3226                  /* Process Unlocked */
   3227                  __HAL_UNLOCK(hi2c);
   3228          
   3229                  return HAL_ERROR;
   3230                }
   3231              }
   \                     ??CrossCallReturnLabel_258: (+1)
   \       0xE0   0xE002             B.N      ??HAL_I2C_Mem_Read_DMA_5
   3232              else
   3233              {
   3234                /* Send Slave Address and Memory Address */
   3235                if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_DMA_3: (+1)
   \       0xE2   0x....'....        BL       ?Subroutine100
   \                     ??CrossCallReturnLabel_301: (+1)
   \       0xE6   0xB108             CBZ.N    R0,??HAL_I2C_Mem_Read_DMA_8
   3236                {
   3237                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_DMA_5: (+1)
   \       0xE8   0x2001             MOVS     R0,#+1
   \       0xEA   0xE00A             B.N      ??HAL_I2C_Mem_Read_DMA_9
   3238                }
   3239          
   3240                /* Clear ADDR flag */
   3241                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Mem_Read_DMA_8: (+1)
   \       0xEC   0x....'....        BL       ?Subroutine67
   3242          
   3243                /* Generate Stop */
   3244                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??CrossCallReturnLabel_206: (+1)
   \       0xF0   0x....'....        BL       ?Subroutine68
   3245          
   3246                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??CrossCallReturnLabel_207: (+1)
   \       0xF4   0x2120             MOVS     R1,#+32
   \       0xF6   0x7079             STRB     R1,[R7, #+1]
   3247          
   3248                /* Process Unlocked */
   3249                __HAL_UNLOCK(hi2c);
   \       0xF8   0x2200             MOVS     R2,#+0
   \       0xFA   0x703A             STRB     R2,[R7, #+0]
   3250              }
   3251          
   3252              return HAL_OK;
   \                     ??HAL_I2C_Mem_Read_DMA_7: (+1)
   \       0xFC   0x2000             MOVS     R0,#+0
   \       0xFE   0xE000             B.N      ??HAL_I2C_Mem_Read_DMA_9
   3253            }
   3254            else
   3255            {
   3256              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_DMA_0: (+1)
   \      0x100   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_DMA_9: (+1)
   \      0x102   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   3257            }
   3258          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine100: (+1)
   \        0x0   0x9601             STR      R6,[SP, #+4]
   \        0x2   0x2023             MOVS     R0,#+35
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x464B             MOV      R3,R9
   \        0x8   0x4642             MOV      R2,R8
   \        0xA   0x4629             MOV      R1,R5
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x....'....        B.W      I2C_RequestMemoryRead

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine115: (+1)
   \        0x0   0x6841             LDR      R1,[R0, #+4]
   \        0x2   0xF441 0x5180      ORR      R1,R1,#0x1000
   \        0x6   0x6041             STR      R1,[R0, #+4]
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine84: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x7078             STRB     R0,[R7, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70B9             STRB     R1,[R7, #+2]
   \        0x8   0x6878             LDR      R0,[R7, #+4]
   \        0xA   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xE   0x6078             STR      R0,[R7, #+4]
   \       0x10   0x7039             STRB     R1,[R7, #+0]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine68: (+1)
   \        0x0   0x6821             LDR      R1,[R4, #+0]
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF442 0x7200      ORR      R2,R2,#0x200
   \        0x8   0x600A             STR      R2,[R1, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine43: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   \        0x4   0xF042 0x0201      ORR      R2,R2,#0x1
   \        0x8   0x6002             STR      R2,[R0, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x9000             STR      R0,[SP, #+0]
   \        0x4   0x6821             LDR      R1,[R4, #+0]
   \        0x6   0x694A             LDR      R2,[R1, #+20]
   \        0x8   0x9200             STR      R2,[SP, #+0]
   \        0xA   0x4770             BX       LR
   3259          
   3260          /**
   3261            * @brief  Checks if target device is ready for communication.
   3262            * @note   This function is used with Memory devices
   3263            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3264            *                the configuration information for the specified I2C.
   3265            * @param  DevAddress Target device address: The device 7 bits address value
   3266            *         in datasheet must be shifted to the left before calling the interface
   3267            * @param  Trials Number of trials
   3268            * @param  Timeout Timeout duration
   3269            * @retval HAL status
   3270            */

   \                                 In section .text, align 2, keep-with-next
   3271          HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
   3272          {
   \                     HAL_I2C_IsDeviceReady: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x....'....        BL       ??Subroutine75_0
   3273            /* Get tick */
   3274            uint32_t tickstart = HAL_GetTick();
   3275            uint32_t I2C_Trials = 1U;
   3276            FlagStatus tmp1;
   3277            FlagStatus tmp2;
   3278          
   3279            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_225: (+1)
   \        0xC   0xF104 0x073C      ADD      R7,R4,#+60
   \       0x10   0x4605             MOV      R5,R0
   \       0x12   0x7878             LDRB     R0,[R7, #+1]
   \       0x14   0x2601             MOVS     R6,#+1
   \       0x16   0x2820             CMP      R0,#+32
   \       0x18   0xD179             BNE.N    ??HAL_I2C_IsDeviceReady_0
   3280            {
   3281              /* Wait until BUSY flag is reset */
   3282              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \       0x1A   0x....'....        LDR.W    R8,??DataTable30_1  ;; 0x100002
   \       0x1E   0x9500             STR      R5,[SP, #+0]
   \       0x20   0x2319             MOVS     R3,#+25
   \       0x22   0x2201             MOVS     R2,#+1
   \       0x24   0x4641             MOV      R1,R8
   \       0x26   0x....'....        BL       ??Subroutine25_1
   \                     ??CrossCallReturnLabel_56: (+1)
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD16F             BNE.N    ??HAL_I2C_IsDeviceReady_0
   3283              {
   3284                return HAL_BUSY;
   3285              }
   3286          
   3287              /* Process Locked */
   3288              __HAL_LOCK(hi2c);
   \       0x2E   0x7838             LDRB     R0,[R7, #+0]
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD06C             BEQ.N    ??HAL_I2C_IsDeviceReady_0
   \       0x34   0x703E             STRB     R6,[R7, #+0]
   3289          
   3290              /* Check if the I2C is already enabled */
   3291              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x36   0x....'....        BL       ?Subroutine30
   3292              {
   3293                /* Enable I2C peripheral */
   3294                __HAL_I2C_ENABLE(hi2c);
   3295              }
   3296          
   3297              /* Disable Pos */
   3298              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   3299          
   3300              hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??CrossCallReturnLabel_84: (+1)
   \       0x3A   0x2024             MOVS     R0,#+36
   \       0x3C   0x7078             STRB     R0,[R7, #+1]
   3301              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x6079             STR      R1,[R7, #+4]
   3302              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x42   0x....'....        LDR.W    R0,??DataTable30  ;; 0xffff0000
   \       0x46   0x62E0             STR      R0,[R4, #+44]
   3303          
   3304              do
   3305              {
   3306                /* Generate Start */
   3307                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_IsDeviceReady_1: (+1)
   \       0x48   0x....'....        BL       ?Subroutine29
   3308          
   3309                /* Wait until SB flag is set */
   3310                if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_80: (+1)
   \       0x4C   0x9500             STR      R5,[SP, #+0]
   \       0x4E   0x4653             MOV      R3,R10
   \       0x50   0x....'....        BL       ?Subroutine25
   \                     ??CrossCallReturnLabel_62: (+1)
   \       0x54   0xB938             CBNZ.N   R0,??HAL_I2C_IsDeviceReady_2
   3311                {
   3312                  if (hi2c->Instance->CR1 & I2C_CR1_START)
   3313                  {
   3314                    hi2c->ErrorCode = HAL_I2C_WRONG_START;
   3315                  }
   3316                  return HAL_TIMEOUT;
   3317                }
   3318          
   3319                /* Send slave address */
   3320                hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \       0x56   0x6821             LDR      R1,[R4, #+0]
   \       0x58   0xF00B 0x00FE      AND      R0,R11,#0xFE
   \       0x5C   0x6108             STR      R0,[R1, #+16]
   3321          
   3322                /* Wait until ADDR or AF flag are set */
   3323                /* Get tick */
   3324                tickstart = HAL_GetTick();
   \       0x5E   0x....'....        BL       HAL_GetTick
   \       0x62   0x4605             MOV      R5,R0
   3325          
   3326                tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
   \       0x64   0xE012             B.N      ??HAL_I2C_IsDeviceReady_3
   \                     ??HAL_I2C_IsDeviceReady_2: (+1)
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0x05CA             LSLS     R2,R1,#+23
   \       0x6C   0xBF44             ITT      MI
   \       0x6E   0xF44F 0x7000      MOVMI    R0,#+512
   \       0x72   0x6078             STRMI    R0,[R7, #+4]
   \       0x74   0x2003             MOVS     R0,#+3
   \       0x76   0xE04B             B.N      ??HAL_I2C_IsDeviceReady_4
   3327                tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   3328                while ((hi2c->State != HAL_I2C_STATE_TIMEOUT) && (tmp1 == RESET) && (tmp2 == RESET))
   3329                {
   3330                  if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \                     ??HAL_I2C_IsDeviceReady_5: (+1)
   \       0x78   0x....'....        BL       HAL_GetTick
   \       0x7C   0x1B40             SUBS     R0,R0,R5
   \       0x7E   0x4582             CMP      R10,R0
   \       0x80   0xD302             BCC.N    ??HAL_I2C_IsDeviceReady_6
   \       0x82   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x86   0xD101             BNE.N    ??HAL_I2C_IsDeviceReady_3
   3331                  {
   3332                    hi2c->State = HAL_I2C_STATE_TIMEOUT;
   \                     ??HAL_I2C_IsDeviceReady_6: (+1)
   \       0x88   0x20A0             MOVS     R0,#+160
   \       0x8A   0x7078             STRB     R0,[R7, #+1]
   3333                  }
   3334                  tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
   \                     ??HAL_I2C_IsDeviceReady_3: (+1)
   \       0x8C   0x6821             LDR      R1,[R4, #+0]
   \       0x8E   0x6948             LDR      R0,[R1, #+20]
   3335                  tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   \       0x90   0x6949             LDR      R1,[R1, #+20]
   3336                }
   \       0x92   0x787A             LDRB     R2,[R7, #+1]
   \       0x94   0x0840             LSRS     R0,R0,#+1
   \       0x96   0x0A89             LSRS     R1,R1,#+10
   \       0x98   0x2AA0             CMP      R2,#+160
   \       0x9A   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x9E   0xF001 0x0101      AND      R1,R1,#0x1
   \       0xA2   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_7
   \       0xA4   0x4308             ORRS     R0,R1,R0
   \       0xA6   0xD0E7             BEQ.N    ??HAL_I2C_IsDeviceReady_5
   3337          
   3338                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_7: (+1)
   \       0xA8   0x2020             MOVS     R0,#+32
   \       0xAA   0x7078             STRB     R0,[R7, #+1]
   3339          
   3340                /* Check if the ADDR flag has been set */
   3341                if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
   \       0xAC   0x6821             LDR      R1,[R4, #+0]
   \       0xAE   0x6948             LDR      R0,[R1, #+20]
   \       0xB0   0x0781             LSLS     R1,R0,#+30
   \       0xB2   0x6820             LDR      R0,[R4, #+0]
   \       0xB4   0xD412             BMI.N    ??HAL_I2C_IsDeviceReady_8
   3342                {
   3343                  /* Generate Stop */
   3344                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   3345          
   3346                  /* Clear ADDR Flag */
   3347                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   3348          
   3349                  /* Wait until BUSY flag is reset */
   3350                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   3351                  {
   3352                    return HAL_ERROR;
   3353                  }
   3354          
   3355                  hi2c->State = HAL_I2C_STATE_READY;
   3356          
   3357                  /* Process Unlocked */
   3358                  __HAL_UNLOCK(hi2c);
   3359          
   3360                  return HAL_OK;
   3361                }
   3362                else
   3363                {
   3364                  /* Generate Stop */
   3365                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xB6   0x....'....        BL       ?Subroutine50
   3366          
   3367                  /* Clear AF Flag */
   3368                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??CrossCallReturnLabel_139: (+1)
   \       0xBA   0x6822             LDR      R2,[R4, #+0]
   \       0xBC   0x6150             STR      R0,[R2, #+20]
   3369          
   3370                  /* Wait until BUSY flag is reset */
   3371                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \       0xBE   0x9500             STR      R5,[SP, #+0]
   \       0xC0   0x2319             MOVS     R3,#+25
   \       0xC2   0x2201             MOVS     R2,#+1
   \       0xC4   0x4641             MOV      R1,R8
   \       0xC6   0x....'....        BL       ??Subroutine25_1
   \                     ??CrossCallReturnLabel_55: (+1)
   \       0xCA   0xB9F0             CBNZ.N   R0,??HAL_I2C_IsDeviceReady_9
   3372                  {
   3373                    return HAL_ERROR;
   3374                  }
   3375                }
   3376          
   3377                /* Increment Trials */
   3378                I2C_Trials++;
   \       0xCC   0x1C76             ADDS     R6,R6,#+1
   3379              }
   3380              while (I2C_Trials < Trials);
   \       0xCE   0x454E             CMP      R6,R9
   \       0xD0   0xD3BA             BCC.N    ??HAL_I2C_IsDeviceReady_1
   3381          
   3382              hi2c->State = HAL_I2C_STATE_READY;
   \       0xD2   0x2020             MOVS     R0,#+32
   \       0xD4   0x7078             STRB     R0,[R7, #+1]
   3383          
   3384              /* Process Unlocked */
   3385              __HAL_UNLOCK(hi2c);
   \       0xD6   0x2100             MOVS     R1,#+0
   \       0xD8   0x7039             STRB     R1,[R7, #+0]
   3386          
   3387              return HAL_ERROR;
   \       0xDA   0xE016             B.N      ??HAL_I2C_IsDeviceReady_9
   \                     ??HAL_I2C_IsDeviceReady_8: (+1)
   \       0xDC   0x....'....        BL       ??Subroutine53_0
   \                     ??CrossCallReturnLabel_151: (+1)
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0x9000             STR      R0,[SP, #+0]
   \       0xE4   0x2319             MOVS     R3,#+25
   \       0xE6   0x6821             LDR      R1,[R4, #+0]
   \       0xE8   0x694A             LDR      R2,[R1, #+20]
   \       0xEA   0x9200             STR      R2,[SP, #+0]
   \       0xEC   0x2201             MOVS     R2,#+1
   \       0xEE   0x6989             LDR      R1,[R1, #+24]
   \       0xF0   0x9100             STR      R1,[SP, #+0]
   \       0xF2   0x4641             MOV      R1,R8
   \       0xF4   0x9800             LDR      R0,[SP, #+0]
   \       0xF6   0x9500             STR      R5,[SP, #+0]
   \       0xF8   0x....'....        BL       ??Subroutine25_1
   \                     ??CrossCallReturnLabel_54: (+1)
   \       0xFC   0xB928             CBNZ.N   R0,??HAL_I2C_IsDeviceReady_9
   \       0xFE   0x2020             MOVS     R0,#+32
   \      0x100   0x7078             STRB     R0,[R7, #+1]
   \      0x102   0x2100             MOVS     R1,#+0
   \      0x104   0x7039             STRB     R1,[R7, #+0]
   \      0x106   0x2000             MOVS     R0,#+0
   \      0x108   0xE002             B.N      ??HAL_I2C_IsDeviceReady_4
   \                     ??HAL_I2C_IsDeviceReady_9: (+1)
   \      0x10A   0x2001             MOVS     R0,#+1
   \      0x10C   0xE000             B.N      ??HAL_I2C_IsDeviceReady_4
   3388            }
   3389            else
   3390            {
   3391              return HAL_BUSY;
   \                     ??HAL_I2C_IsDeviceReady_0: (+1)
   \      0x10E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_IsDeviceReady_4: (+1)
   \      0x110   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   3392            }
   3393          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine50: (+1)
   \        0x0   0x6802             LDR      R2,[R0, #+0]
   \        0x2   0xF442 0x7200      ORR      R2,R2,#0x200
   \        0x6   0x6002             STR      R2,[R0, #+0]
   \        0x8   0xF46F 0x6080      MVN      R0,#+1024
   \        0xC   0x4770             BX       LR
   3394          
   3395          /**
   3396            * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with Interrupt.
   3397            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3398            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3399            *         the configuration information for the specified I2C.
   3400            * @param  DevAddress Target device address: The device 7 bits address value
   3401            *         in datasheet must be shifted to the left before calling the interface
   3402            * @param  pData Pointer to data buffer
   3403            * @param  Size Amount of data to be sent
   3404            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   3405            * @retval HAL status
   3406            */

   \                                 In section .text, align 2, keep-with-next
   3407          HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3408          {
   \                     HAL_I2C_Master_Seq_Transmit_IT: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   3409            __IO uint32_t Prev_State = 0x00U;
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x9500             STR      R5,[SP, #+0]
   3410            __IO uint32_t count      = 0x00U;
   \        0x8   0x9500             STR      R5,[SP, #+0]
   \        0xA   0x4604             MOV      R4,R0
   3411          
   3412            /* Check the parameters */
   3413            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3414          
   3415            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0xC   0x....'....        BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x10   0xD142             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_0
   \       0x12   0x9E07             LDR      R6,[SP, #+28]
   3416            {
   3417              /* Check Busy Flag only if FIRST call of Master interface */
   3418              if ((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
   \       0x14   0x2E08             CMP      R6,#+8
   \       0x16   0xBF18             IT       NE
   \       0x18   0x2E01             CMPNE    R6,#+1
   \       0x1A   0xD112             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_1
   3419              {
   3420                /* Wait until BUSY flag is reset */
   3421                count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x1C   0x....             LDR.N    R0,??DataTable25
   \       0x1E   0x6807             LDR      R7,[R0, #+0]
   \       0x20   0xF04F 0x0E19      MOV      LR,#+25
   \       0x24   0xFBB7 0xFEFE      UDIV     LR,R7,LR
   \       0x28   0xF44F 0x787A      MOV      R8,#+1000
   \       0x2C   0xFBBE 0xF8F8      UDIV     R8,LR,R8
   \       0x30   0x....'....        BL       ?Subroutine65
   3422                do
   3423                {
   3424                  count--;
   \                     ??CrossCallReturnLabel_198: (+1)
   \       0x34   0x....'....        BL       ?Subroutine98
   3425                  if (count == 0U)
   \                     ??CrossCallReturnLabel_293: (+1)
   \       0x38   0xD02B             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_IT_2
   3426                  {
   3427                    hi2c->PreviousState       = I2C_STATE_NONE;
   3428                    hi2c->State               = HAL_I2C_STATE_READY;
   3429                    hi2c->Mode                = HAL_I2C_MODE_NONE;
   3430                    hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   3431          
   3432                    /* Process Unlocked */
   3433                    __HAL_UNLOCK(hi2c);
   3434          
   3435                    return HAL_ERROR;
   3436                  }
   3437                }
   3438                while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x3A   0x6827             LDR      R7,[R4, #+0]
   \       0x3C   0x69B8             LDR      R0,[R7, #+24]
   \       0x3E   0x0787             LSLS     R7,R0,#+30
   \       0x40   0xD4F8             BMI.N    ??CrossCallReturnLabel_198
   3439              }
   3440          
   3441              /* Process Locked */
   3442              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_1: (+1)
   \       0x42   0x7828             LDRB     R0,[R5, #+0]
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD027             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_IT_0
   \       0x48   0x2701             MOVS     R7,#+1
   \       0x4A   0x702F             STRB     R7,[R5, #+0]
   3443          
   3444              /* Check if the I2C is already enabled */
   3445              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6800             LDR      R0,[R0, #+0]
   \       0x50   0x07C7             LSLS     R7,R0,#+31
   \       0x52   0xD401             BMI.N    ??CrossCallReturnLabel_77
   3446              {
   3447                /* Enable I2C peripheral */
   3448                __HAL_I2C_ENABLE(hi2c);
   \       0x54   0x....'....        BL       ?Subroutine28
   3449              }
   3450          
   3451              /* Disable Pos */
   3452              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??CrossCallReturnLabel_77: (+1)
   \       0x58   0x....'....        BL       ??Subroutine32_0
   3453          
   3454              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \                     ??CrossCallReturnLabel_87: (+1)
   \       0x5C   0x7068             STRB     R0,[R5, #+1]
   3455              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0x5E   0x2710             MOVS     R7,#+16
   \       0x60   0x70AF             STRB     R7,[R5, #+2]
   3456              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x6068             STR      R0,[R5, #+4]
   3457          
   3458              /* Prepare transfer parameters */
   3459              hi2c->pBuffPtr    = pData;
   \       0x66   0x6262             STR      R2,[R4, #+36]
   3460              hi2c->XferCount   = Size;
   \       0x68   0x8563             STRH     R3,[R4, #+42]
   3461              hi2c->XferSize    = hi2c->XferCount;
   \       0x6A   0x8D60             LDRH     R0,[R4, #+42]
   \       0x6C   0x8520             STRH     R0,[R4, #+40]
   3462              hi2c->XferOptions = XferOptions;
   \       0x6E   0x62E6             STR      R6,[R4, #+44]
   3463              hi2c->Devaddress  = DevAddress;
   \       0x70   0x60A9             STR      R1,[R5, #+8]
   3464          
   3465              Prev_State = hi2c->PreviousState;
   \       0x72   0x6B20             LDR      R0,[R4, #+48]
   \       0x74   0x9000             STR      R0,[SP, #+0]
   3466          
   3467              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3468              /* Mean Previous state is same as current state */
   3469              if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \       0x76   0x9900             LDR      R1,[SP, #+0]
   \       0x78   0x2911             CMP      R1,#+17
   \       0x7A   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_3
   \       0x7C   0xF5B6 0x0F2A      CMP      R6,#+11141120
   \       0x80   0xBF18             IT       NE
   \       0x82   0xF1B6 0x4F2A      CMPNE    R6,#-1442840576
   \       0x86   0xD101             BNE.N    ??CrossCallReturnLabel_81
   3470              {
   3471                /* Generate Start */
   3472                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_3: (+1)
   \       0x88   0x....'....        BL       ?Subroutine29
   3473              }
   3474          
   3475              /* Process Unlocked */
   3476              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_81: (+1)
   \       0x8C   0x....'....        BL       ?Subroutine8
   3477          
   3478              /* Note : The I2C interrupts must be enabled after unlocking current process
   3479              to avoid the risk of I2C interrupt handle execution before current
   3480              process unlock */
   3481          
   3482              /* Enable EVT, BUF and ERR interrupt */
   3483              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   3484          
   3485              return HAL_OK;
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x90   0xE003             B.N      ??HAL_I2C_Master_Seq_Transmit_IT_4
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_2: (+1)
   \       0x92   0x....'....        BL       ?Subroutine24
   3486            }
   \                     ??CrossCallReturnLabel_53: (+1)
   \       0x96   0xE000             B.N      ??HAL_I2C_Master_Seq_Transmit_IT_4
   3487            else
   3488            {
   3489              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_0: (+1)
   \       0x98   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_4: (+1)
   \       0x9A   0xE8BD 0x81F2      POP      {R1,R4-R8,PC}    ;; return
   3490            }
   3491          }
   3492          
   3493          /**
   3494            * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with DMA.
   3495            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3496            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3497            *         the configuration information for the specified I2C.
   3498            * @param  DevAddress Target device address: The device 7 bits address value
   3499            *         in datasheet must be shifted to the left before calling the interface
   3500            * @param  pData Pointer to data buffer
   3501            * @param  Size Amount of data to be sent
   3502            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   3503            * @retval HAL status
   3504            */

   \                                 In section .text, align 2, keep-with-next
   3505          HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3506          {
   \                     HAL_I2C_Master_Seq_Transmit_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   3507            __IO uint32_t Prev_State = 0x00U;
   \        0x4   0x....'....        BL       ?Subroutine106
   3508            __IO uint32_t count      = 0x00U;
   3509            HAL_StatusTypeDef dmaxferstatus;
   3510          
   3511            /* Check the parameters */
   3512            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3513          
   3514            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_314: (+1)
   \        0x8   0xD161             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_0
   \        0xA   0x9D08             LDR      R5,[SP, #+32]
   3515            {
   3516              /* Check Busy Flag only if FIRST call of Master interface */
   3517              if ((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
   \        0xC   0x2D08             CMP      R5,#+8
   \        0xE   0xBF18             IT       NE
   \       0x10   0x2D01             CMPNE    R5,#+1
   \       0x12   0xD112             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_1
   3518              {
   3519                /* Wait until BUSY flag is reset */
   3520                count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x14   0x....             LDR.N    R0,??DataTable25
   \       0x16   0x6807             LDR      R7,[R0, #+0]
   \       0x18   0xF04F 0x0E19      MOV      LR,#+25
   \       0x1C   0xFBB7 0xFEFE      UDIV     LR,R7,LR
   \       0x20   0xF44F 0x787A      MOV      R8,#+1000
   \       0x24   0xFBBE 0xF8F8      UDIV     R8,LR,R8
   \       0x28   0x....'....        BL       ?Subroutine65
   3521                do
   3522                {
   3523                  count--;
   \                     ??CrossCallReturnLabel_199: (+1)
   \       0x2C   0x....'....        BL       ?Subroutine98
   3524                  if (count == 0U)
   \                     ??CrossCallReturnLabel_294: (+1)
   \       0x30   0xD02F             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_2
   3525                  {
   3526                    hi2c->PreviousState       = I2C_STATE_NONE;
   3527                    hi2c->State               = HAL_I2C_STATE_READY;
   3528                    hi2c->Mode                = HAL_I2C_MODE_NONE;
   3529                    hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   3530          
   3531                    /* Process Unlocked */
   3532                    __HAL_UNLOCK(hi2c);
   3533          
   3534                    return HAL_ERROR;
   3535                  }
   3536                }
   3537                while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x32   0x6837             LDR      R7,[R6, #+0]
   \       0x34   0x69B8             LDR      R0,[R7, #+24]
   \       0x36   0x0787             LSLS     R7,R0,#+30
   \       0x38   0xD4F8             BMI.N    ??CrossCallReturnLabel_199
   3538              }
   3539          
   3540              /* Process Locked */
   3541              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_1: (+1)
   \       0x3A   0x7820             LDRB     R0,[R4, #+0]
   \       0x3C   0x2801             CMP      R0,#+1
   \       0x3E   0xD046             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_0
   \       0x40   0x....'....        BL       ?Subroutine85
   3542          
   3543              /* Check if the I2C is already enabled */
   3544              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   3545              {
   3546                /* Enable I2C peripheral */
   3547                __HAL_I2C_ENABLE(hi2c);
   3548              }
   3549          
   3550              /* Disable Pos */
   3551              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   3552          
   3553              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \                     ??CrossCallReturnLabel_261: (+1)
   \       0x44   0x2021             MOVS     R0,#+33
   \       0x46   0x....'....        BL       ?Subroutine13
   3554              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   3555              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3556          
   3557              /* Prepare transfer parameters */
   3558              hi2c->pBuffPtr    = pData;
   3559              hi2c->XferCount   = Size;
   3560              hi2c->XferSize    = hi2c->XferCount;
   3561              hi2c->XferOptions = XferOptions;
   3562              hi2c->Devaddress  = DevAddress;
   3563          
   3564              Prev_State = hi2c->PreviousState;
   3565          
   3566              if (hi2c->XferSize > 0U)
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x4A   0xD030             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_3
   3567              {
   3568                /* Set the I2C DMA transfer complete callback */
   3569                hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \       0x4C   0x....'....        BL       ?Subroutine117
   3570          
   3571                /* Set the DMA error callback */
   3572                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   3573          
   3574                /* Set the unused DMA callbacks to NULL */
   3575                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \                     ??CrossCallReturnLabel_345: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x6B71             LDR      R1,[R6, #+52]
   \       0x54   0x6408             STR      R0,[R1, #+64]
   3576                hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x56   0x6B71             LDR      R1,[R6, #+52]
   \       0x58   0x6508             STR      R0,[R1, #+80]
   3577          
   3578                /* Enable the DMA stream */
   3579                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   3580          
   3581                if (dmaxferstatus == HAL_OK)
   \       0x5A   0x....'....        BL       ?Subroutine108
   \                     ??CrossCallReturnLabel_321: (+1)
   \       0x5E   0xB9D8             CBNZ.N   R0,??HAL_I2C_Master_Seq_Transmit_DMA_4
   3582                {
   3583                  /* Enable Acknowledge */
   3584                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x60   0x....'....        BL       ?Subroutine57
   3585          
   3586                  /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3587                  /* Mean Previous state is same as current state */
   3588                  if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \                     ??CrossCallReturnLabel_161: (+1)
   \       0x64   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_5
   \       0x66   0xF5B5 0x0F2A      CMP      R5,#+11141120
   \       0x6A   0xBF18             IT       NE
   \       0x6C   0xF1B5 0x4F2A      CMPNE    R5,#-1442840576
   \       0x70   0xD101             BNE.N    ??CrossCallReturnLabel_144
   3589                  {
   3590                    /* Generate Start */
   3591                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_5: (+1)
   \       0x72   0x....'....        BL       ?Subroutine52
   3592                  }
   3593          
   3594                  /* Process Unlocked */
   3595                  __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_144: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   3596          
   3597                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3598                  to avoid the risk of I2C interrupt handle execution before current
   3599                  process unlock */
   3600          
   3601                  /* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */
   3602                  /* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */
   3603                  if ((XferOptions == I2C_NEXT_FRAME) || (XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
   \       0x78   0x2D04             CMP      R5,#+4
   \       0x7A   0xBF1C             ITT      NE
   \       0x7C   0x2D20             CMPNE    R5,#+32
   \       0x7E   0x2D10             CMPNE    R5,#+16
   \       0x80   0x7020             STRB     R0,[R4, #+0]
   \       0x82   0xD101             BNE.N    ??CrossCallReturnLabel_328
   3604                  {
   3605                    /* Enable DMA Request */
   3606                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \       0x84   0x....'....        BL       ?Subroutine111
   3607                  }
   3608          
   3609                  /* Enable EVT and ERR interrupt */
   3610                  __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \                     ??CrossCallReturnLabel_328: (+1)
   \       0x88   0x6830             LDR      R0,[R6, #+0]
   \       0x8A   0x6841             LDR      R1,[R0, #+4]
   \       0x8C   0xF441 0x7140      ORR      R1,R1,#0x300
   \       0x90   0xE01A             B.N      ??CrossCallReturnLabel_41
   3611                }
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_2: (+1)
   \       0x92   0x....'....        BL       ?Subroutine70
   \                     ??CrossCallReturnLabel_211: (+1)
   \       0x96   0xE006             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_6
   3612                else
   3613                {
   3614                  /* Update I2C state */
   3615                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_4: (+1)
   \       0x98   0x2120             MOVS     R1,#+32
   \       0x9A   0x7061             STRB     R1,[R4, #+1]
   3616                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0x70A0             STRB     R0,[R4, #+2]
   3617          
   3618                  /* Update I2C error code */
   3619                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \       0xA0   0x6861             LDR      R1,[R4, #+4]
   \       0xA2   0xF041 0x0110      ORR      R1,R1,#0x10
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_6: (+1)
   \       0xA6   0x6061             STR      R1,[R4, #+4]
   3620          
   3621                  /* Process Unlocked */
   3622                  __HAL_UNLOCK(hi2c);
   \       0xA8   0x7020             STRB     R0,[R4, #+0]
   3623          
   3624                  return HAL_ERROR;
   \       0xAA   0x2001             MOVS     R0,#+1
   \       0xAC   0xE010             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_7
   3625                }
   3626              }
   3627              else
   3628              {
   3629                /* Enable Acknowledge */
   3630                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_3: (+1)
   \       0xAE   0x....'....        BL       ?Subroutine57
   3631          
   3632                /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3633                /* Mean Previous state is same as current state */
   3634                if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \                     ??CrossCallReturnLabel_162: (+1)
   \       0xB2   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_8
   \       0xB4   0xF5B5 0x0F2A      CMP      R5,#+11141120
   \       0xB8   0xBF18             IT       NE
   \       0xBA   0xF1B5 0x4F2A      CMPNE    R5,#-1442840576
   \       0xBE   0xD101             BNE.N    ??CrossCallReturnLabel_145
   3635                {
   3636                  /* Generate Start */
   3637                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_8: (+1)
   \       0xC0   0x....'....        BL       ?Subroutine52
   3638                }
   3639          
   3640                /* Process Unlocked */
   3641                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_145: (+1)
   \       0xC4   0x....'....        BL       ?Subroutine20
   3642          
   3643                /* Note : The I2C interrupts must be enabled after unlocking current process
   3644                to avoid the risk of I2C interrupt handle execution before current
   3645                process unlock */
   3646          
   3647                /* Enable EVT, BUF and ERR interrupt */
   3648                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   3649              }
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0xC8   0x6041             STR      R1,[R0, #+4]
   3650          
   3651              return HAL_OK;
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0xE000             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_7
   3652            }
   3653            else
   3654            {
   3655              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_0: (+1)
   \       0xCE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_7: (+1)
   \       0xD0   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3656            }
   3657          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine57: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x6180      ORR      R1,R1,#0x400
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x9800             LDR      R0,[SP, #+0]
   \        0xC   0x2811             CMP      R0,#+17
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine106: (+1)
   \        0x0   0x2400             MOVS     R4,#+0
   \        0x2   0x9400             STR      R4,[SP, #+0]
   \        0x4   0x9400             STR      R4,[SP, #+0]
   \        0x6   0x4606             MOV      R6,R0
   \        0x8   0xF106 0x043C      ADD      R4,R6,#+60
   \        0xC   0x7860             LDRB     R0,[R4, #+1]
   \        0xE   0x2820             CMP      R0,#+32
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine85: (+1)
   \        0x0   0x2701             MOVS     R7,#+1
   \        0x2   0x7027             STRB     R7,[R4, #+0]
   \        0x4   0x6830             LDR      R0,[R6, #+0]
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x07C7             LSLS     R7,R0,#+31
   \        0xA   0xD404             BMI.N    ??Subroutine85_0
   \        0xC   0x6830             LDR      R0,[R6, #+0]
   \        0xE   0x6807             LDR      R7,[R0, #+0]
   \       0x10   0xF047 0x0701      ORR      R7,R7,#0x1
   \       0x14   0x6007             STR      R7,[R0, #+0]
   \                     ??Subroutine85_0: (+1)
   \       0x16   0x6830             LDR      R0,[R6, #+0]
   \       0x18   0x6807             LDR      R7,[R0, #+0]
   \       0x1A   0xF427 0x6700      BIC      R7,R7,#0x800
   \       0x1E   0x6007             STR      R7,[R0, #+0]
   \       0x20   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine70: (+1)
   \        0x0   0x6330             STR      R0,[R6, #+48]
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x7061             STRB     R1,[R4, #+1]
   \        0x6   0x70A0             STRB     R0,[R4, #+2]
   \        0x8   0x6861             LDR      R1,[R4, #+4]
   \        0xA   0xF041 0x0120      ORR      R1,R1,#0x20
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x7020             STRB     R0,[R4, #+0]
   \        0x4   0x6830             LDR      R0,[R6, #+0]
   \        0x6   0x6841             LDR      R1,[R0, #+4]
   \        0x8   0xF441 0x61E0      ORR      R1,R1,#0x700
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x7060             STRB     R0,[R4, #+1]
   \        0x2   0x2710             MOVS     R7,#+16
   \        0x4   0x70A7             STRB     R7,[R4, #+2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6060             STR      R0,[R4, #+4]
   \        0xA   0x6272             STR      R2,[R6, #+36]
   \        0xC   0x8573             STRH     R3,[R6, #+42]
   \        0xE   0x8D70             LDRH     R0,[R6, #+42]
   \       0x10   0x8530             STRH     R0,[R6, #+40]
   \       0x12   0x62F5             STR      R5,[R6, #+44]
   \       0x14   0x60A1             STR      R1,[R4, #+8]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0x6B31             LDR      R1,[R6, #+48]
   \       0x1A   0x9100             STR      R1,[SP, #+0]
   \       0x1C   0x4770             BX       LR
   3658          
   3659          /**
   3660            * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with Interrupt
   3661            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3662            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3663            *         the configuration information for the specified I2C.
   3664            * @param  DevAddress Target device address: The device 7 bits address value
   3665            *         in datasheet must be shifted to the left before calling the interface
   3666            * @param  pData Pointer to data buffer
   3667            * @param  Size Amount of data to be sent
   3668            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   3669            * @retval HAL status
   3670            */

   \                                 In section .text, align 2, keep-with-next
   3671          HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3672          {
   \                     HAL_I2C_Master_Seq_Receive_IT: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   3673            __IO uint32_t Prev_State = 0x00U;
   3674            __IO uint32_t count = 0U;
   3675            uint32_t enableIT = (I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   3676          
   3677            /* Check the parameters */
   3678            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3679          
   3680            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x6   0xF104 0x063C      ADD      R6,R4,#+60
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0x9500             STR      R5,[SP, #+0]
   \        0xE   0x9500             STR      R5,[SP, #+0]
   \       0x10   0xF44F 0x65E0      MOV      R5,#+1792
   \       0x14   0x7870             LDRB     R0,[R6, #+1]
   \       0x16   0x2820             CMP      R0,#+32
   \       0x18   0xD174             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_0
   \       0x1A   0x9F07             LDR      R7,[SP, #+28]
   3681            {
   3682              /* Check Busy Flag only if FIRST call of Master interface */
   3683              if ((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
   \       0x1C   0x2F08             CMP      R7,#+8
   \       0x1E   0xBF18             IT       NE
   \       0x20   0x2F01             CMPNE    R7,#+1
   \       0x22   0xD114             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_1
   3684              {
   3685                /* Wait until BUSY flag is reset */
   3686                count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x24   0x....             LDR.N    R0,??DataTable25
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0xF04F 0x0E19      MOV      LR,#+25
   \       0x2C   0xFBB0 0xFEFE      UDIV     LR,R0,LR
   \       0x30   0xF44F 0x787A      MOV      R8,#+1000
   \       0x34   0xFBBE 0xF8F8      UDIV     R8,LR,R8
   \       0x38   0x....'....        BL       ?Subroutine65
   3687                do
   3688                {
   3689                  count--;
   \                     ??CrossCallReturnLabel_200: (+1)
   \       0x3C   0x....'....        BL       ?Subroutine98
   3690                  if (count == 0U)
   \                     ??CrossCallReturnLabel_295: (+1)
   \       0x40   0xD03E             BEQ.N    ??HAL_I2C_Master_Seq_Receive_IT_2
   3691                  {
   3692                    hi2c->PreviousState       = I2C_STATE_NONE;
   3693                    hi2c->State               = HAL_I2C_STATE_READY;
   3694                    hi2c->Mode                = HAL_I2C_MODE_NONE;
   3695                    hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   3696          
   3697                    /* Process Unlocked */
   3698                    __HAL_UNLOCK(hi2c);
   3699          
   3700                    return HAL_ERROR;
   3701                  }
   3702                }
   3703                while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x42   0xF8D4 0xC000      LDR      R12,[R4, #+0]
   \       0x46   0xF8DC 0x0018      LDR      R0,[R12, #+24]
   \       0x4A   0x0780             LSLS     R0,R0,#+30
   \       0x4C   0xD4F6             BMI.N    ??CrossCallReturnLabel_200
   3704              }
   3705          
   3706              /* Process Locked */
   3707              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_1: (+1)
   \       0x4E   0x7830             LDRB     R0,[R6, #+0]
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xD057             BEQ.N    ??HAL_I2C_Master_Seq_Receive_IT_0
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0x7030             STRB     R0,[R6, #+0]
   3708          
   3709              /* Check if the I2C is already enabled */
   3710              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0x07C0             LSLS     R0,R0,#+31
   \       0x5E   0xD406             BMI.N    ??HAL_I2C_Master_Seq_Receive_IT_3
   3711              {
   3712                /* Enable I2C peripheral */
   3713                __HAL_I2C_ENABLE(hi2c);
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0xF8D0 0xE000      LDR      LR,[R0, #+0]
   \       0x66   0xF04E 0x0E01      ORR      LR,LR,#0x1
   \       0x6A   0xF8C0 0xE000      STR      LR,[R0, #+0]
   3714              }
   3715          
   3716              /* Disable Pos */
   3717              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_3: (+1)
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0xF8D0 0xE000      LDR      LR,[R0, #+0]
   \       0x74   0xF42E 0x6E00      BIC      LR,LR,#0x800
   \       0x78   0xF8C0 0xE000      STR      LR,[R0, #+0]
   3718          
   3719              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x7C   0x2022             MOVS     R0,#+34
   \       0x7E   0x7070             STRB     R0,[R6, #+1]
   3720              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0x80   0x2010             MOVS     R0,#+16
   \       0x82   0x70B0             STRB     R0,[R6, #+2]
   3721              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0x6070             STR      R0,[R6, #+4]
   3722          
   3723              /* Prepare transfer parameters */
   3724              hi2c->pBuffPtr    = pData;
   \       0x88   0x6262             STR      R2,[R4, #+36]
   3725              hi2c->XferCount   = Size;
   \       0x8A   0x8563             STRH     R3,[R4, #+42]
   3726              hi2c->XferSize    = hi2c->XferCount;
   \       0x8C   0x8D60             LDRH     R0,[R4, #+42]
   \       0x8E   0x8520             STRH     R0,[R4, #+40]
   3727              hi2c->XferOptions = XferOptions;
   \       0x90   0x62E7             STR      R7,[R4, #+44]
   3728              hi2c->Devaddress  = DevAddress;
   \       0x92   0x60B1             STR      R1,[R6, #+8]
   3729          
   3730              Prev_State = hi2c->PreviousState;
   \       0x94   0x6B20             LDR      R0,[R4, #+48]
   \       0x96   0x9000             STR      R0,[SP, #+0]
   3731          
   3732              if ((hi2c->XferCount == 2U) && ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP)))
   \       0x98   0x8D61             LDRH     R1,[R4, #+42]
   \       0x9A   0x2902             CMP      R1,#+2
   \       0x9C   0xD11B             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_4
   \       0x9E   0x2F20             CMP      R7,#+32
   \       0xA0   0xBF18             IT       NE
   \       0xA2   0x2F10             CMPNE    R7,#+16
   \       0xA4   0xD117             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_4
   3733              {
   3734                if (Prev_State == I2C_STATE_MASTER_BUSY_RX)
   \       0xA6   0x6820             LDR      R0,[R4, #+0]
   \       0xA8   0x9900             LDR      R1,[SP, #+0]
   \       0xAA   0x2912             CMP      R1,#+18
   \       0xAC   0xD114             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_5
   3735                {
   3736                  /* Disable Acknowledge */
   3737                  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xAE   0x....'....        BL       ?Subroutine49
   3738          
   3739                  /* Enable Pos */
   3740                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   3741          
   3742                  /* Remove Enabling of IT_BUF, mean RXNE treatment, treat the 2 bytes through BTF */
   3743                  enableIT &= ~I2C_IT_BUF;
   \                     ??CrossCallReturnLabel_137: (+1)
   \       0xB2   0xF44F 0x7540      MOV      R5,#+768
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x6801             LDR      R1,[R0, #+0]
   \       0xBA   0xF441 0x6100      ORR      R1,R1,#0x800
   \       0xBE   0xE00D             B.N      ??CrossCallReturnLabel_177
   3744                }
   3745                else
   3746                {
   3747                  /* Enable Acknowledge */
   3748                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   3749                }
   3750              }
   \                     ??HAL_I2C_Master_Seq_Receive_IT_2: (+1)
   \       0xC0   0x6320             STR      R0,[R4, #+48]
   \       0xC2   0x2120             MOVS     R1,#+32
   \       0xC4   0x7071             STRB     R1,[R6, #+1]
   \       0xC6   0x70B0             STRB     R0,[R6, #+2]
   \       0xC8   0x6871             LDR      R1,[R6, #+4]
   \       0xCA   0xF041 0x0120      ORR      R1,R1,#0x20
   \       0xCE   0x6071             STR      R1,[R6, #+4]
   \       0xD0   0x7030             STRB     R0,[R6, #+0]
   \       0xD2   0x2001             MOVS     R0,#+1
   \       0xD4   0xE017             B.N      ??HAL_I2C_Master_Seq_Receive_IT_6
   3751              else
   3752              {
   3753                /* Enable Acknowledge */
   3754                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_4: (+1)
   \       0xD6   0x6820             LDR      R0,[R4, #+0]
   3755              }
   \                     ??HAL_I2C_Master_Seq_Receive_IT_5: (+1)
   \       0xD8   0x....'....        BL       ??Subroutine61_0
   \                     ??CrossCallReturnLabel_177: (+1)
   \       0xDC   0x6001             STR      R1,[R0, #+0]
   3756          
   3757              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3758              /* Mean Previous state is same as current state */
   3759              if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \       0xDE   0x9800             LDR      R0,[SP, #+0]
   \       0xE0   0x2812             CMP      R0,#+18
   \       0xE2   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_7
   \       0xE4   0xF5B7 0x0F2A      CMP      R7,#+11141120
   \       0xE8   0xBF18             IT       NE
   \       0xEA   0xF1B7 0x4F2A      CMPNE    R7,#-1442840576
   \       0xEE   0xD101             BNE.N    ??CrossCallReturnLabel_82
   3760              {
   3761                /* Generate Start */
   3762                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_7: (+1)
   \       0xF0   0x....'....        BL       ?Subroutine29
   3763              }
   3764          
   3765              /* Process Unlocked */
   3766              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_82: (+1)
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0x7030             STRB     R0,[R6, #+0]
   3767          
   3768              /* Note : The I2C interrupts must be enabled after unlocking current process
   3769              to avoid the risk of I2C interrupt handle execution before current
   3770              process unlock */
   3771          
   3772              /* Enable interrupts */
   3773              __HAL_I2C_ENABLE_IT(hi2c, enableIT);
   \       0xF8   0x6820             LDR      R0,[R4, #+0]
   \       0xFA   0x6841             LDR      R1,[R0, #+4]
   \       0xFC   0x430D             ORRS     R5,R5,R1
   \       0xFE   0x6045             STR      R5,[R0, #+4]
   3774          
   3775              return HAL_OK;
   \      0x100   0x2000             MOVS     R0,#+0
   \      0x102   0xE000             B.N      ??HAL_I2C_Master_Seq_Receive_IT_6
   3776            }
   3777            else
   3778            {
   3779              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Receive_IT_0: (+1)
   \      0x104   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Receive_IT_6: (+1)
   \      0x106   0xE8BD 0x81F2      POP      {R1,R4-R8,PC}    ;; return
   3780            }
   3781          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine61: (+1)
   \        0x0   0x4608             MOV      R0,R1
   \                     ??Subroutine61_0: (+1)
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x6180      ORR      R1,R1,#0x400
   \        0x8   0x4770             BX       LR
   3782          
   3783          /**
   3784            * @brief  Sequential receive in master mode an amount of data in non-blocking mode with DMA
   3785            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3786            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3787            *         the configuration information for the specified I2C.
   3788            * @param  DevAddress Target device address: The device 7 bits address value
   3789            *         in datasheet must be shifted to the left before calling the interface
   3790            * @param  pData Pointer to data buffer
   3791            * @param  Size Amount of data to be sent
   3792            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   3793            * @retval HAL status
   3794            */

   \                                 In section .text, align 2, keep-with-next
   3795          HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3796          {
   \                     HAL_I2C_Master_Seq_Receive_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   3797            __IO uint32_t Prev_State = 0x00U;
   \        0x4   0x....'....        BL       ?Subroutine106
   3798            __IO uint32_t count = 0U;
   3799            uint32_t enableIT = (I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   3800            HAL_StatusTypeDef dmaxferstatus;
   3801          
   3802            /* Check the parameters */
   3803            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3804          
   3805            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_315: (+1)
   \        0x8   0xF040 0x80A5      BNE.W    ??HAL_I2C_Master_Seq_Receive_DMA_0
   \        0xC   0x9D08             LDR      R5,[SP, #+32]
   3806            {
   3807              /* Check Busy Flag only if FIRST call of Master interface */
   3808              if ((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
   \        0xE   0x2D08             CMP      R5,#+8
   \       0x10   0xBF18             IT       NE
   \       0x12   0x2D01             CMPNE    R5,#+1
   \       0x14   0xD113             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_1
   3809              {
   3810                /* Wait until BUSY flag is reset */
   3811                count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x16   0x....'....        LDR.W    R0,??DataTable31
   \       0x1A   0x6807             LDR      R7,[R0, #+0]
   \       0x1C   0xF04F 0x0E19      MOV      LR,#+25
   \       0x20   0xFBB7 0xFEFE      UDIV     LR,R7,LR
   \       0x24   0xF44F 0x787A      MOV      R8,#+1000
   \       0x28   0xFBBE 0xF8F8      UDIV     R8,LR,R8
   \       0x2C   0x....'....        BL       ?Subroutine65
   3812                do
   3813                {
   3814                  count--;
   \                     ??CrossCallReturnLabel_201: (+1)
   \       0x30   0x....'....        BL       ?Subroutine98
   3815                  if (count == 0U)
   \                     ??CrossCallReturnLabel_296: (+1)
   \       0x34   0xD025             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_2
   3816                  {
   3817                    hi2c->PreviousState       = I2C_STATE_NONE;
   3818                    hi2c->State               = HAL_I2C_STATE_READY;
   3819                    hi2c->Mode                = HAL_I2C_MODE_NONE;
   3820                    hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   3821          
   3822                    /* Process Unlocked */
   3823                    __HAL_UNLOCK(hi2c);
   3824          
   3825                    return HAL_ERROR;
   3826                  }
   3827                }
   3828                while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \       0x36   0x6837             LDR      R7,[R6, #+0]
   \       0x38   0x69B8             LDR      R0,[R7, #+24]
   \       0x3A   0x0787             LSLS     R7,R0,#+30
   \       0x3C   0xD4F8             BMI.N    ??CrossCallReturnLabel_201
   3829              }
   3830          
   3831              /* Process Locked */
   3832              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_1: (+1)
   \       0x3E   0x7820             LDRB     R0,[R4, #+0]
   \       0x40   0x2801             CMP      R0,#+1
   \       0x42   0xF000 0x8088      BEQ.W    ??HAL_I2C_Master_Seq_Receive_DMA_0
   \       0x46   0x....'....        BL       ?Subroutine85
   3833          
   3834              /* Check if the I2C is already enabled */
   3835              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   3836              {
   3837                /* Enable I2C peripheral */
   3838                __HAL_I2C_ENABLE(hi2c);
   3839              }
   3840          
   3841              /* Disable Pos */
   3842              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   3843          
   3844              /* Clear Last DMA bit */
   3845              CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??CrossCallReturnLabel_262: (+1)
   \       0x4A   0x6830             LDR      R0,[R6, #+0]
   \       0x4C   0x6847             LDR      R7,[R0, #+4]
   \       0x4E   0xF427 0x5780      BIC      R7,R7,#0x1000
   \       0x52   0x6047             STR      R7,[R0, #+4]
   3846          
   3847              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x54   0x2022             MOVS     R0,#+34
   \       0x56   0x....'....        BL       ?Subroutine13
   3848              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   3849              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3850          
   3851              /* Prepare transfer parameters */
   3852              hi2c->pBuffPtr    = pData;
   3853              hi2c->XferCount   = Size;
   3854              hi2c->XferSize    = hi2c->XferCount;
   3855              hi2c->XferOptions = XferOptions;
   3856              hi2c->Devaddress  = DevAddress;
   3857          
   3858              Prev_State = hi2c->PreviousState;
   3859          
   3860              if (hi2c->XferSize > 0U)
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x5A   0xD069             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_3
   3861              {
   3862                if ((hi2c->XferCount == 2U) && ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP)))
   \       0x5C   0x8D70             LDRH     R0,[R6, #+42]
   \       0x5E   0x2802             CMP      R0,#+2
   \       0x60   0xD117             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_4
   \       0x62   0x2D20             CMP      R5,#+32
   \       0x64   0xBF18             IT       NE
   \       0x66   0x2D10             CMPNE    R5,#+16
   \       0x68   0xD113             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_4
   3863                {
   3864                  if (Prev_State == I2C_STATE_MASTER_BUSY_RX)
   \       0x6A   0x6830             LDR      R0,[R6, #+0]
   \       0x6C   0x9900             LDR      R1,[SP, #+0]
   \       0x6E   0x2912             CMP      R1,#+18
   \       0x70   0xD10C             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_5
   3865                  {
   3866                    /* Disable Acknowledge */
   3867                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x72   0x....'....        BL       ?Subroutine49
   3868          
   3869                    /* Enable Pos */
   3870                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??CrossCallReturnLabel_138: (+1)
   \       0x76   0x6830             LDR      R0,[R6, #+0]
   \       0x78   0x6801             LDR      R1,[R0, #+0]
   \       0x7A   0xF441 0x6100      ORR      R1,R1,#0x800
   \       0x7E   0x6001             STR      R1,[R0, #+0]
   3871          
   3872                    /* Enable Last DMA bit */
   3873                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \       0x80   0xE012             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_6
   3874                  }
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_2: (+1)
   \       0x82   0x....'....        BL       ?Subroutine70
   \                     ??CrossCallReturnLabel_212: (+1)
   \       0x86   0x6061             STR      R1,[R4, #+4]
   \       0x88   0x7020             STRB     R0,[R4, #+0]
   \       0x8A   0xE04F             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_7
   3875                  else
   3876                  {
   3877                    /* Enable Acknowledge */
   3878                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_5: (+1)
   \       0x8C   0x....'....        BL       ?Subroutine58
   3879                  }
   3880                }
   \                     ??CrossCallReturnLabel_163: (+1)
   \       0x90   0xE00D             B.N      ??CrossCallReturnLabel_340
   3881                else
   3882                {
   3883                  /* Enable Acknowledge */
   3884                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_4: (+1)
   \       0x92   0x6830             LDR      R0,[R6, #+0]
   \       0x94   0x6801             LDR      R1,[R0, #+0]
   3885          
   3886                  if ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_OTHER_AND_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
   \       0x96   0x2D20             CMP      R5,#+32
   \       0x98   0xF441 0x6180      ORR      R1,R1,#0x400
   \       0x9C   0xBF1C             ITT      NE
   \       0x9E   0xF1B5 0x4F2A      CMPNE    R5,#-1442840576
   \       0xA2   0x2D10             CMPNE    R5,#+16
   \       0xA4   0x6001             STR      R1,[R0, #+0]
   \       0xA6   0xD102             BNE.N    ??CrossCallReturnLabel_340
   3887                  {
   3888                    /* Enable Last DMA bit */
   3889                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_6: (+1)
   \       0xA8   0x6830             LDR      R0,[R6, #+0]
   \       0xAA   0x....'....        BL       ?Subroutine115
   3890                  }
   3891                }
   3892          
   3893                /* Set the I2C DMA transfer complete callback */
   3894                hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \                     ??CrossCallReturnLabel_340: (+1)
   \       0xAE   0x6BB1             LDR      R1,[R6, #+56]
   \       0xB0   0x....'....        LDR.W    R0,??DataTable30_2
   \       0xB4   0x63C8             STR      R0,[R1, #+60]
   3895          
   3896                /* Set the DMA error callback */
   3897                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \       0xB6   0x6BB1             LDR      R1,[R6, #+56]
   \       0xB8   0x....'....        LDR.W    R0,??DataTable31_1
   \       0xBC   0x64C8             STR      R0,[R1, #+76]
   3898          
   3899                /* Set the unused DMA callbacks to NULL */
   3900                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0x6BB1             LDR      R1,[R6, #+56]
   \       0xC2   0x6408             STR      R0,[R1, #+64]
   3901                hi2c->hdmarx->XferAbortCallback = NULL;
   \       0xC4   0x6BB1             LDR      R1,[R6, #+56]
   \       0xC6   0x6508             STR      R0,[R1, #+80]
   3902          
   3903                /* Enable the DMA stream */
   3904                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   3905          
   3906                if (dmaxferstatus == HAL_OK)
   \       0xC8   0x6830             LDR      R0,[R6, #+0]
   \       0xCA   0x8D33             LDRH     R3,[R6, #+40]
   \       0xCC   0x6A72             LDR      R2,[R6, #+36]
   \       0xCE   0xF100 0x0110      ADD      R1,R0,#+16
   \       0xD2   0x6BB0             LDR      R0,[R6, #+56]
   \       0xD4   0x....'....        BL       HAL_DMA_Start_IT
   \       0xD8   0xB9F8             CBNZ.N   R0,??HAL_I2C_Master_Seq_Receive_DMA_8
   3907                {
   3908                  /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3909                  /* Mean Previous state is same as current state */
   3910                  if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \       0xDA   0x9800             LDR      R0,[SP, #+0]
   \       0xDC   0x2812             CMP      R0,#+18
   \       0xDE   0xD107             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_9
   \       0xE0   0xF5B5 0x0F2A      CMP      R5,#+11141120
   \       0xE4   0xBF1C             ITT      NE
   \       0xE6   0xF1B5 0x4F2A      CMPNE    R5,#-1442840576
   \       0xEA   0xF44F 0x7080      MOVNE    R0,#+256
   3911                  {
   3912                    /* Generate Start */
   3913                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   3914          
   3915                    /* Update interrupt for only EVT and ERR */
   3916                    enableIT = (I2C_IT_EVT | I2C_IT_ERR);
   3917                  }
   3918                  else
   3919                  {
   3920                    /* Update interrupt for only ERR */
   3921                    enableIT = I2C_IT_ERR;
   \       0xEE   0xD103             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_10
   3922                  }
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_9: (+1)
   \       0xF0   0x....'....        BL       ?Subroutine52
   \                     ??CrossCallReturnLabel_146: (+1)
   \       0xF4   0xF44F 0x7040      MOV      R0,#+768
   3923          
   3924                  /* Process Unlocked */
   3925                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_10: (+1)
   \       0xF8   0x2100             MOVS     R1,#+0
   3926          
   3927                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3928                  to avoid the risk of I2C interrupt handle execution before current
   3929                  process unlock */
   3930          
   3931                  /* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */
   3932                  /* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */
   3933                  if ((XferOptions == I2C_NEXT_FRAME) || (XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
   \       0xFA   0x2D04             CMP      R5,#+4
   \       0xFC   0xBF1C             ITT      NE
   \       0xFE   0x2D20             CMPNE    R5,#+32
   \      0x100   0x2D10             CMPNE    R5,#+16
   \      0x102   0x7021             STRB     R1,[R4, #+0]
   \      0x104   0xD104             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_11
   3934                  {
   3935                    /* Enable DMA Request */
   3936                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \      0x106   0x6831             LDR      R1,[R6, #+0]
   \      0x108   0x684A             LDR      R2,[R1, #+4]
   \      0x10A   0xF442 0x6200      ORR      R2,R2,#0x800
   \      0x10E   0x604A             STR      R2,[R1, #+4]
   3937                  }
   3938          
   3939                  /* Enable EVT and ERR interrupt */
   3940                  __HAL_I2C_ENABLE_IT(hi2c, enableIT);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_11: (+1)
   \      0x110   0x6831             LDR      R1,[R6, #+0]
   \      0x112   0x684A             LDR      R2,[R1, #+4]
   \      0x114   0x4310             ORRS     R0,R0,R2
   \      0x116   0x6048             STR      R0,[R1, #+4]
   \      0x118   0xE01B             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_12
   3941                }
   3942                else
   3943                {
   3944                  /* Update I2C state */
   3945                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_8: (+1)
   \      0x11A   0x2020             MOVS     R0,#+32
   \      0x11C   0x7060             STRB     R0,[R4, #+1]
   3946                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   \      0x11E   0x2100             MOVS     R1,#+0
   \      0x120   0x70A1             STRB     R1,[R4, #+2]
   3947          
   3948                  /* Update I2C error code */
   3949                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \      0x122   0x6860             LDR      R0,[R4, #+4]
   \      0x124   0xF040 0x0010      ORR      R0,R0,#0x10
   \      0x128   0x6060             STR      R0,[R4, #+4]
   3950          
   3951                  /* Process Unlocked */
   3952                  __HAL_UNLOCK(hi2c);
   \      0x12A   0x7021             STRB     R1,[R4, #+0]
   3953          
   3954                  return HAL_ERROR;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_7: (+1)
   \      0x12C   0x2001             MOVS     R0,#+1
   \      0x12E   0xE013             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_13
   3955                }
   3956              }
   3957              else
   3958              {
   3959                /* Enable Acknowledge */
   3960                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_3: (+1)
   \      0x130   0x6830             LDR      R0,[R6, #+0]
   \      0x132   0x....'....        BL       ?Subroutine58
   3961          
   3962                /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3963                /* Mean Previous state is same as current state */
   3964                if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \                     ??CrossCallReturnLabel_164: (+1)
   \      0x136   0x9800             LDR      R0,[SP, #+0]
   \      0x138   0x2812             CMP      R0,#+18
   \      0x13A   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_14
   \      0x13C   0xF5B5 0x0F2A      CMP      R5,#+11141120
   \      0x140   0xBF18             IT       NE
   \      0x142   0xF1B5 0x4F2A      CMPNE    R5,#-1442840576
   \      0x146   0xD101             BNE.N    ??CrossCallReturnLabel_147
   3965                {
   3966                  /* Generate Start */
   3967                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_14: (+1)
   \      0x148   0x....'....        BL       ?Subroutine52
   3968                }
   3969          
   3970                /* Process Unlocked */
   3971                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_147: (+1)
   \      0x14C   0x....'....        BL       ?Subroutine20
   3972          
   3973                /* Note : The I2C interrupts must be enabled after unlocking current process
   3974                to avoid the risk of I2C interrupt handle execution before current
   3975                process unlock */
   3976          
   3977                /* Enable interrupts */
   3978                __HAL_I2C_ENABLE_IT(hi2c, enableIT);
   3979              }
   \                     ??CrossCallReturnLabel_42: (+1)
   \      0x150   0x6041             STR      R1,[R0, #+4]
   3980              return HAL_OK;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_12: (+1)
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0xE000             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_13
   3981            }
   3982            else
   3983            {
   3984              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_0: (+1)
   \      0x156   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_13: (+1)
   \      0x158   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3985            }
   3986          }
   3987          
   3988          /**
   3989            * @brief  Sequential transmit in slave mode an amount of data in non-blocking mode with Interrupt
   3990            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3991            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3992            *         the configuration information for the specified I2C.
   3993            * @param  pData Pointer to data buffer
   3994            * @param  Size Amount of data to be sent
   3995            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   3996            * @retval HAL status
   3997            */

   \                                 In section .text, align 2, keep-with-next
   3998          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3999          {
   \                     HAL_I2C_Slave_Seq_Transmit_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   4000            /* Check the parameters */
   4001            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   4002          
   4003            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \        0x2   0x....'....        BL       ?Subroutine121
   \                     ??CrossCallReturnLabel_352: (+1)
   \        0x6   0xD10B             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_IT_0
   4004            {
   4005              if ((pData == NULL) || (Size == 0U))
   \        0x8   0xB109             CBZ.N    R1,??HAL_I2C_Slave_Seq_Transmit_IT_1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0xD101             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_IT_2
   4006              {
   4007                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_1: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xBDF2             POP      {R1,R4-R7,PC}
   4008              }
   4009          
   4010              /* Process Locked */
   4011              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_2: (+1)
   \       0x12   0x7825             LDRB     R5,[R4, #+0]
   \       0x14   0x2D01             CMP      R5,#+1
   \       0x16   0xD003             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_IT_0
   \       0x18   0x....'....        BL       ?Subroutine86
   4012          
   4013              /* Check if the I2C is already enabled */
   4014              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   4015              {
   4016                /* Enable I2C peripheral */
   4017                __HAL_I2C_ENABLE(hi2c);
   4018              }
   4019          
   4020              /* Disable Pos */
   4021              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   4022          
   4023              hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
   \                     ??CrossCallReturnLabel_263: (+1)
   \       0x1C   0x2529             MOVS     R5,#+41
   \       0x1E   0x....             B.N      ?Subroutine0
   4024              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   4025              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   4026          
   4027              /* Prepare transfer parameters */
   4028              hi2c->pBuffPtr    = pData;
   4029              hi2c->XferCount   = Size;
   4030              hi2c->XferSize    = hi2c->XferCount;
   4031              hi2c->XferOptions = XferOptions;
   4032          
   4033              /* Clear ADDR flag */
   4034              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   4035          
   4036              /* Process Unlocked */
   4037              __HAL_UNLOCK(hi2c);
   4038          
   4039              /* Note : The I2C interrupts must be enabled after unlocking current process
   4040                        to avoid the risk of I2C interrupt handle execution before current
   4041                        process unlock */
   4042          
   4043              /* Enable EVT, BUF and ERR interrupt */
   4044              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   4045          
   4046              return HAL_OK;
   4047            }
   4048            else
   4049            {
   4050              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_0: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4051            }
   4052          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine121: (+1)
   \        0x0   0xF100 0x043C      ADD      R4,R0,#+60
   \        0x4   0x7865             LDRB     R5,[R4, #+1]
   \        0x6   0xF005 0x0528      AND      R5,R5,#0x28
   \        0xA   0x2D28             CMP      R5,#+40
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine86: (+1)
   \        0x0   0x2601             MOVS     R6,#+1
   \        0x2   0x7026             STRB     R6,[R4, #+0]
   \        0x4   0x6805             LDR      R5,[R0, #+0]
   \        0x6   0x682F             LDR      R7,[R5, #+0]
   \        0x8   0x07FE             LSLS     R6,R7,#+31
   \        0xA   0xD403             BMI.N    ??Subroutine86_0
   \        0xC   0x682F             LDR      R7,[R5, #+0]
   \        0xE   0xF047 0x0701      ORR      R7,R7,#0x1
   \       0x12   0x602F             STR      R7,[R5, #+0]
   \                     ??Subroutine86_0: (+1)
   \       0x14   0x6805             LDR      R5,[R0, #+0]
   \       0x16   0x682E             LDR      R6,[R5, #+0]
   \       0x18   0xF426 0x6600      BIC      R6,R6,#0x800
   \       0x1C   0x602E             STR      R6,[R5, #+0]
   \       0x1E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x7065             STRB     R5,[R4, #+1]
   \        0x2   0x2620             MOVS     R6,#+32
   \        0x4   0x70A6             STRB     R6,[R4, #+2]
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x6065             STR      R5,[R4, #+4]
   \        0xA   0x6241             STR      R1,[R0, #+36]
   \        0xC   0x8542             STRH     R2,[R0, #+42]
   \        0xE   0x8D41             LDRH     R1,[R0, #+42]
   \       0x10   0x8501             STRH     R1,[R0, #+40]
   \       0x12   0x62C3             STR      R3,[R0, #+44]
   \       0x14   0x9500             STR      R5,[SP, #+0]
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x694A             LDR      R2,[R1, #+20]
   \       0x1A   0x9200             STR      R2,[SP, #+0]
   \       0x1C   0x698B             LDR      R3,[R1, #+24]
   \       0x1E   0x9300             STR      R3,[SP, #+0]
   \       0x20   0x9800             LDR      R0,[SP, #+0]
   \       0x22   0x7025             STRB     R5,[R4, #+0]
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x684B             LDR      R3,[R1, #+4]
   \       0x28   0xF443 0x63E0      ORR      R3,R3,#0x700
   \       0x2C   0x604B             STR      R3,[R1, #+4]
   \       0x2E   0xBDF2             POP      {R1,R4-R7,PC}
   4053          
   4054          /**
   4055            * @brief  Sequential transmit in slave mode an amount of data in non-blocking mode with DMA
   4056            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   4057            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4058            *         the configuration information for the specified I2C.
   4059            * @param  pData Pointer to data buffer
   4060            * @param  Size Amount of data to be sent
   4061            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   4062            * @retval HAL status
   4063            */

   \                                 In section .text, align 2, keep-with-next
   4064          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   4065          {
   \                     HAL_I2C_Slave_Seq_Transmit_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine72
   4066            HAL_StatusTypeDef dmaxferstatus;
   4067          
   4068            /* Check the parameters */
   4069            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   4070          
   4071            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_216: (+1)
   \        0x8   0xD155             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_0
   4072            {
   4073              if ((pData == NULL) || (Size == 0U))
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2E00             CMPNE    R6,#+0
   \       0x10   0xD04F             BEQ.N    ??CrossCallReturnLabel_259
   4074              {
   4075                return  HAL_ERROR;
   4076              }
   4077          
   4078              /* Process Locked */
   4079              __HAL_LOCK(hi2c);
   \       0x12   0x7838             LDRB     R0,[R7, #+0]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD04E             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_0
   \       0x18   0x....'....        BL       ?Subroutine81
   4080          
   4081              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   4082              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   4083          
   4084              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   4085              /* and then toggle the HAL slave RX state to TX state */
   4086              if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \                     ??CrossCallReturnLabel_249: (+1)
   \       0x1C   0xD10A             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_1
   4087              {
   4088                if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \       0x1E   0x682A             LDR      R2,[R5, #+0]
   \       0x20   0x6850             LDR      R0,[R2, #+4]
   \       0x22   0x0503             LSLS     R3,R0,#+20
   \       0x24   0xD518             BPL.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_2
   4089                {
   4090                  /* Abort DMA Xfer if any */
   4091                  if (hi2c->hdmarx != NULL)
   \       0x26   0x6BA8             LDR      R0,[R5, #+56]
   \       0x28   0xB1B0             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_2
   4092                  {
   4093                    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \       0x2A   0x....'....        BL       ?Subroutine122
   4094          
   4095                    /* Set the I2C DMA Abort callback :
   4096                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4097                    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   4098          
   4099                    /* Abort DMA RX */
   4100                    if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \                     ??CrossCallReturnLabel_355: (+1)
   \       0x2E   0xB198             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_2
   4101                    {
   4102                      /* Call Directly XferAbortCallback function in case of error */
   4103                      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x30   0x6BA8             LDR      R0,[R5, #+56]
   \       0x32   0xE00F             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_3
   4104                    }
   4105                  }
   4106                }
   4107              }
   4108              else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_1: (+1)
   \       0x34   0x7878             LDRB     R0,[R7, #+1]
   \       0x36   0x2829             CMP      R0,#+41
   \       0x38   0xD10E             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_2
   4109              {
   4110                if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x6842             LDR      R2,[R0, #+4]
   \       0x3E   0x0513             LSLS     R3,R2,#+20
   \       0x40   0xD50A             BPL.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_2
   4111                {
   4112                  CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \       0x42   0x....'....        BL       ?Subroutine116
   4113          
   4114                  /* Abort DMA Xfer if any */
   4115                  if (hi2c->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_342: (+1)
   \       0x46   0xB138             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_2
   4116                  {
   4117                    /* Set the I2C DMA Abort callback :
   4118                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4119                    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x48   0x6501             STR      R1,[R0, #+80]
   4120          
   4121                    /* Abort DMA TX */
   4122                    if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \       0x4A   0x6B68             LDR      R0,[R5, #+52]
   \       0x4C   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x50   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_2
   4123                    {
   4124                      /* Call Directly XferAbortCallback function in case of error */
   4125                      hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0x52   0x6B68             LDR      R0,[R5, #+52]
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_3: (+1)
   \       0x54   0x6D01             LDR      R1,[R0, #+80]
   \       0x56   0x4788             BLX      R1
   4126                    }
   4127                  }
   4128                }
   4129              }
   4130              else
   4131              {
   4132                /* Nothing to do */
   4133              }
   4134          
   4135              /* Check if the I2C is already enabled */
   4136              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_2: (+1)
   \       0x58   0x6828             LDR      R0,[R5, #+0]
   \       0x5A   0x6802             LDR      R2,[R0, #+0]
   \       0x5C   0x07D1             LSLS     R1,R2,#+31
   \       0x5E   0xD401             BMI.N    ??CrossCallReturnLabel_132
   4137              {
   4138                /* Enable I2C peripheral */
   4139                __HAL_I2C_ENABLE(hi2c);
   \       0x60   0x....'....        BL       ??Subroutine47_0
   4140              }
   4141          
   4142              /* Disable Pos */
   4143              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??CrossCallReturnLabel_132: (+1)
   \       0x64   0x....'....        BL       ?Subroutine55
   4144          
   4145              hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
   \                     ??CrossCallReturnLabel_157: (+1)
   \       0x68   0x2029             MOVS     R0,#+41
   \       0x6A   0x....'....        BL       ?Subroutine14
   4146              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   4147              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   4148          
   4149              /* Prepare transfer parameters */
   4150              hi2c->pBuffPtr    = pData;
   4151              hi2c->XferCount   = Size;
   4152              hi2c->XferSize    = hi2c->XferCount;
   4153              hi2c->XferOptions = XferOptions;
   4154          
   4155              /* Set the I2C DMA transfer complete callback */
   4156              hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x6E   0x6B68             LDR      R0,[R5, #+52]
   \       0x70   0x63C1             STR      R1,[R0, #+60]
   4157          
   4158              /* Set the DMA error callback */
   4159              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \       0x72   0x6B68             LDR      R0,[R5, #+52]
   \       0x74   0x....'....        LDR.W    R1,??DataTable31_1
   \       0x78   0x64C1             STR      R1,[R0, #+76]
   4160          
   4161              /* Set the unused DMA callbacks to NULL */
   4162              hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \       0x7A   0x2100             MOVS     R1,#+0
   \       0x7C   0x6B68             LDR      R0,[R5, #+52]
   \       0x7E   0x6401             STR      R1,[R0, #+64]
   4163              hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x80   0x6B68             LDR      R0,[R5, #+52]
   \       0x82   0x6501             STR      R1,[R0, #+80]
   4164          
   4165              /* Enable the DMA stream */
   4166              dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   4167          
   4168              if (dmaxferstatus == HAL_OK)
   \       0x84   0x6828             LDR      R0,[R5, #+0]
   \       0x86   0x8D2B             LDRH     R3,[R5, #+40]
   \       0x88   0x6A69             LDR      R1,[R5, #+36]
   \       0x8A   0xF100 0x0210      ADD      R2,R0,#+16
   \       0x8E   0x6B68             LDR      R0,[R5, #+52]
   \       0x90   0x....'....        BL       HAL_DMA_Start_IT
   \       0x94   0xB958             CBNZ.N   R0,??HAL_I2C_Slave_Seq_Transmit_DMA_4
   4169              {
   4170                /* Enable Address Acknowledge */
   4171                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x96   0x....'....        BL       ?Subroutine12
   4172          
   4173                /* Clear ADDR flag */
   4174                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   4175          
   4176                /* Process Unlocked */
   4177                __HAL_UNLOCK(hi2c);
   4178          
   4179                /* Note : The I2C interrupts must be enabled after unlocking current process
   4180                to avoid the risk of I2C interrupt handle execution before current
   4181                process unlock */
   4182                /* Enable EVT and ERR interrupt */
   4183                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x9A   0xF443 0x7340      ORR      R3,R3,#0x300
   \       0x9E   0x604B             STR      R3,[R1, #+4]
   4184          
   4185                /* Enable DMA Request */
   4186                hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   \       0xA0   0x6828             LDR      R0,[R5, #+0]
   \       0xA2   0x6841             LDR      R1,[R0, #+4]
   \       0xA4   0xF441 0x6100      ORR      R1,R1,#0x800
   \       0xA8   0x6041             STR      R1,[R0, #+4]
   4187          
   4188                return HAL_OK;
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xE004             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_5
   4189              }
   4190              else
   4191              {
   4192                /* Update I2C state */
   4193                hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_4: (+1)
   \       0xAE   0x....'....        BL       ?Subroutine84
   4194                hi2c->Mode      = HAL_I2C_MODE_NONE;
   4195          
   4196                /* Update I2C error code */
   4197                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   4198          
   4199                /* Process Unlocked */
   4200                __HAL_UNLOCK(hi2c);
   4201          
   4202                return HAL_ERROR;
   \                     ??CrossCallReturnLabel_259: (+1)
   \       0xB2   0x2001             MOVS     R0,#+1
   \       0xB4   0xE000             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_5
   4203              }
   4204            }
   4205            else
   4206            {
   4207              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_0: (+1)
   \       0xB6   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_5: (+1)
   \       0xB8   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   4208            }
   4209          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine122: (+1)
   \        0x0   0x6850             LDR      R0,[R2, #+4]
   \        0x2   0xF420 0x6000      BIC      R0,R0,#0x800
   \        0x6   0x6050             STR      R0,[R2, #+4]
   \        0x8   0x6BA8             LDR      R0,[R5, #+56]
   \        0xA   0x6501             STR      R1,[R0, #+80]
   \        0xC   0x6BA8             LDR      R0,[R5, #+56]
   \        0xE   0x....'....        B.W      HAL_DMA_Abort_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine116: (+1)
   \        0x0   0x6842             LDR      R2,[R0, #+4]
   \        0x2   0xF422 0x6200      BIC      R2,R2,#0x800
   \        0x6   0x6042             STR      R2,[R0, #+4]
   \        0x8   0x6B68             LDR      R0,[R5, #+52]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine81: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x7039             STRB     R1,[R7, #+0]
   \        0x4   0x6828             LDR      R0,[R5, #+0]
   \        0x6   0x....'....        LDR.W    R1,??DataTable34
   \        0xA   0x6842             LDR      R2,[R0, #+4]
   \        0xC   0xF422 0x7240      BIC      R2,R2,#0x300
   \       0x10   0x6042             STR      R2,[R0, #+4]
   \       0x12   0x7878             LDRB     R0,[R7, #+1]
   \       0x14   0x282A             CMP      R0,#+42
   \       0x16   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine72: (+1)
   \        0x0   0x4605             MOV      R5,R0
   \        0x2   0xF105 0x073C      ADD      R7,R5,#+60
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x7878             LDRB     R0,[R7, #+1]
   \        0xA   0xF000 0x0028      AND      R0,R0,#0x28
   \        0xE   0x2828             CMP      R0,#+40
   \       0x10   0x4616             MOV      R6,R2
   \       0x12   0x4698             MOV      R8,R3
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x7078             STRB     R0,[R7, #+1]
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x70B9             STRB     R1,[R7, #+2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6078             STR      R0,[R7, #+4]
   \        0xA   0x626C             STR      R4,[R5, #+36]
   \        0xC   0x856E             STRH     R6,[R5, #+42]
   \        0xE   0x8D68             LDRH     R0,[R5, #+42]
   \       0x10   0x....             LDR.N    R1,??DataTable30_2
   \       0x12   0x8528             STRH     R0,[R5, #+40]
   \       0x14   0xF8C5 0x802C      STR      R8,[R5, #+44]
   \       0x18   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x6828             LDR      R0,[R5, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x6180      ORR      R1,R1,#0x400
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9000             STR      R0,[SP, #+0]
   \        0xE   0x6829             LDR      R1,[R5, #+0]
   \       0x10   0x694A             LDR      R2,[R1, #+20]
   \       0x12   0x9200             STR      R2,[SP, #+0]
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0x698B             LDR      R3,[R1, #+24]
   \       0x18   0x9300             STR      R3,[SP, #+0]
   \       0x1A   0x9800             LDR      R0,[SP, #+0]
   \       0x1C   0x703A             STRB     R2,[R7, #+0]
   \       0x1E   0x684B             LDR      R3,[R1, #+4]
   \       0x20   0x4770             BX       LR
   4210          
   4211          /**
   4212            * @brief  Sequential receive in slave mode an amount of data in non-blocking mode with Interrupt
   4213            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   4214            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4215            *         the configuration information for the specified I2C.
   4216            * @param  pData Pointer to data buffer
   4217            * @param  Size Amount of data to be sent
   4218            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   4219            * @retval HAL status
   4220            */

   \                                 In section .text, align 2, keep-with-next
   4221          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   4222          {
   \                     HAL_I2C_Slave_Seq_Receive_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   4223            /* Check the parameters */
   4224            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   4225          
   4226            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \        0x2   0x....'....        BL       ?Subroutine121
   \                     ??CrossCallReturnLabel_353: (+1)
   \        0x6   0xD10B             BNE.N    ??HAL_I2C_Slave_Seq_Receive_IT_0
   4227            {
   4228              if ((pData == NULL) || (Size == 0U))
   \        0x8   0xB109             CBZ.N    R1,??HAL_I2C_Slave_Seq_Receive_IT_1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0xD101             BNE.N    ??HAL_I2C_Slave_Seq_Receive_IT_2
   4229              {
   4230                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_1: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xBDF2             POP      {R1,R4-R7,PC}
   4231              }
   4232          
   4233              /* Process Locked */
   4234              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_2: (+1)
   \       0x12   0x7825             LDRB     R5,[R4, #+0]
   \       0x14   0x2D01             CMP      R5,#+1
   \       0x16   0xD003             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_IT_0
   \       0x18   0x....'....        BL       ?Subroutine86
   4235          
   4236              /* Check if the I2C is already enabled */
   4237              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   4238              {
   4239                /* Enable I2C peripheral */
   4240                __HAL_I2C_ENABLE(hi2c);
   4241              }
   4242          
   4243              /* Disable Pos */
   4244              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   4245          
   4246              hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
   \                     ??CrossCallReturnLabel_264: (+1)
   \       0x1C   0x252A             MOVS     R5,#+42
   \       0x1E   0x....             B.N      ?Subroutine0
   4247              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   4248              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   4249          
   4250              /* Prepare transfer parameters */
   4251              hi2c->pBuffPtr    = pData;
   4252              hi2c->XferCount   = Size;
   4253              hi2c->XferSize    = hi2c->XferCount;
   4254              hi2c->XferOptions = XferOptions;
   4255          
   4256              /* Clear ADDR flag */
   4257              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   4258          
   4259              /* Process Unlocked */
   4260              __HAL_UNLOCK(hi2c);
   4261          
   4262              /* Note : The I2C interrupts must be enabled after unlocking current process
   4263                        to avoid the risk of I2C interrupt handle execution before current
   4264                        process unlock */
   4265          
   4266              /* Enable EVT, BUF and ERR interrupt */
   4267              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   4268          
   4269              return HAL_OK;
   4270            }
   4271            else
   4272            {
   4273              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_0: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4274            }
   4275          }
   4276          
   4277          /**
   4278            * @brief  Sequential receive in slave mode an amount of data in non-blocking mode with DMA
   4279            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   4280            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4281            *         the configuration information for the specified I2C.
   4282            * @param  pData Pointer to data buffer
   4283            * @param  Size Amount of data to be sent
   4284            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   4285            * @retval HAL status
   4286            */

   \                                 In section .text, align 2, keep-with-next
   4287          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   4288          {
   \                     HAL_I2C_Slave_Seq_Receive_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine72
   4289            HAL_StatusTypeDef dmaxferstatus;
   4290          
   4291            /* Check the parameters */
   4292            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   4293          
   4294            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_217: (+1)
   \        0x8   0xD155             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_0
   4295            {
   4296              if ((pData == NULL) || (Size == 0U))
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2E00             CMPNE    R6,#+0
   \       0x10   0xD04F             BEQ.N    ??CrossCallReturnLabel_260
   4297              {
   4298                return  HAL_ERROR;
   4299              }
   4300          
   4301              /* Process Locked */
   4302              __HAL_LOCK(hi2c);
   \       0x12   0x7838             LDRB     R0,[R7, #+0]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD04E             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_DMA_0
   \       0x18   0x....'....        BL       ?Subroutine81
   4303          
   4304              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   4305              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   4306          
   4307              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   4308              /* and then toggle the HAL slave RX state to TX state */
   4309              if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \                     ??CrossCallReturnLabel_250: (+1)
   \       0x1C   0xD10A             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_1
   4310              {
   4311                if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \       0x1E   0x682A             LDR      R2,[R5, #+0]
   \       0x20   0x6850             LDR      R0,[R2, #+4]
   \       0x22   0x0503             LSLS     R3,R0,#+20
   \       0x24   0xD518             BPL.N    ??HAL_I2C_Slave_Seq_Receive_DMA_2
   4312                {
   4313                  /* Abort DMA Xfer if any */
   4314                  if (hi2c->hdmarx != NULL)
   \       0x26   0x6BA8             LDR      R0,[R5, #+56]
   \       0x28   0xB1B0             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_2
   4315                  {
   4316                    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \       0x2A   0x....'....        BL       ?Subroutine122
   4317          
   4318                    /* Set the I2C DMA Abort callback :
   4319                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4320                    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   4321          
   4322                    /* Abort DMA RX */
   4323                    if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \                     ??CrossCallReturnLabel_354: (+1)
   \       0x2E   0xB198             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_2
   4324                    {
   4325                      /* Call Directly XferAbortCallback function in case of error */
   4326                      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x30   0x6BA8             LDR      R0,[R5, #+56]
   \       0x32   0xE00F             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_3
   4327                    }
   4328                  }
   4329                }
   4330              }
   4331              else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_1: (+1)
   \       0x34   0x7878             LDRB     R0,[R7, #+1]
   \       0x36   0x2829             CMP      R0,#+41
   \       0x38   0xD10E             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_2
   4332              {
   4333                if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x6842             LDR      R2,[R0, #+4]
   \       0x3E   0x0513             LSLS     R3,R2,#+20
   \       0x40   0xD50A             BPL.N    ??HAL_I2C_Slave_Seq_Receive_DMA_2
   4334                {
   4335                  CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \       0x42   0x....'....        BL       ?Subroutine116
   4336          
   4337                  /* Abort DMA Xfer if any */
   4338                  if (hi2c->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_343: (+1)
   \       0x46   0xB138             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_2
   4339                  {
   4340                    /* Set the I2C DMA Abort callback :
   4341                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4342                    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x48   0x6501             STR      R1,[R0, #+80]
   4343          
   4344                    /* Abort DMA TX */
   4345                    if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \       0x4A   0x6B68             LDR      R0,[R5, #+52]
   \       0x4C   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x50   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_2
   4346                    {
   4347                      /* Call Directly XferAbortCallback function in case of error */
   4348                      hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0x52   0x6B68             LDR      R0,[R5, #+52]
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_3: (+1)
   \       0x54   0x6D01             LDR      R1,[R0, #+80]
   \       0x56   0x4788             BLX      R1
   4349                    }
   4350                  }
   4351                }
   4352              }
   4353              else
   4354              {
   4355                /* Nothing to do */
   4356              }
   4357          
   4358              /* Check if the I2C is already enabled */
   4359              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_2: (+1)
   \       0x58   0x6828             LDR      R0,[R5, #+0]
   \       0x5A   0x6802             LDR      R2,[R0, #+0]
   \       0x5C   0x07D1             LSLS     R1,R2,#+31
   \       0x5E   0xD401             BMI.N    ??CrossCallReturnLabel_133
   4360              {
   4361                /* Enable I2C peripheral */
   4362                __HAL_I2C_ENABLE(hi2c);
   \       0x60   0x....'....        BL       ??Subroutine47_0
   4363              }
   4364          
   4365              /* Disable Pos */
   4366              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??CrossCallReturnLabel_133: (+1)
   \       0x64   0x....'....        BL       ?Subroutine55
   4367          
   4368              hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
   \                     ??CrossCallReturnLabel_158: (+1)
   \       0x68   0x202A             MOVS     R0,#+42
   \       0x6A   0x....'....        BL       ?Subroutine14
   4369              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   4370              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   4371          
   4372              /* Prepare transfer parameters */
   4373              hi2c->pBuffPtr    = pData;
   4374              hi2c->XferCount   = Size;
   4375              hi2c->XferSize    = hi2c->XferCount;
   4376              hi2c->XferOptions = XferOptions;
   4377          
   4378              /* Set the I2C DMA transfer complete callback */
   4379              hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x6E   0x6BA8             LDR      R0,[R5, #+56]
   \       0x70   0x63C1             STR      R1,[R0, #+60]
   4380          
   4381              /* Set the DMA error callback */
   4382              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \       0x72   0x6BA8             LDR      R0,[R5, #+56]
   \       0x74   0x....'....        LDR.W    R1,??DataTable31_1
   \       0x78   0x64C1             STR      R1,[R0, #+76]
   4383          
   4384              /* Set the unused DMA callbacks to NULL */
   4385              hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \       0x7A   0x2100             MOVS     R1,#+0
   \       0x7C   0x6BA8             LDR      R0,[R5, #+56]
   \       0x7E   0x6401             STR      R1,[R0, #+64]
   4386              hi2c->hdmarx->XferAbortCallback = NULL;
   \       0x80   0x6BA8             LDR      R0,[R5, #+56]
   \       0x82   0x6501             STR      R1,[R0, #+80]
   4387          
   4388              /* Enable the DMA stream */
   4389              dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   4390          
   4391              if (dmaxferstatus == HAL_OK)
   \       0x84   0x6828             LDR      R0,[R5, #+0]
   \       0x86   0x8D2B             LDRH     R3,[R5, #+40]
   \       0x88   0x6A6A             LDR      R2,[R5, #+36]
   \       0x8A   0xF100 0x0110      ADD      R1,R0,#+16
   \       0x8E   0x6BA8             LDR      R0,[R5, #+56]
   \       0x90   0x....'....        BL       HAL_DMA_Start_IT
   \       0x94   0xB958             CBNZ.N   R0,??HAL_I2C_Slave_Seq_Receive_DMA_4
   4392              {
   4393                /* Enable Address Acknowledge */
   4394                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x96   0x....'....        BL       ?Subroutine12
   4395          
   4396                /* Clear ADDR flag */
   4397                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   4398          
   4399                /* Process Unlocked */
   4400                __HAL_UNLOCK(hi2c);
   4401          
   4402                /* Enable DMA Request */
   4403                SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x9A   0xF443 0x6300      ORR      R3,R3,#0x800
   \       0x9E   0x604B             STR      R3,[R1, #+4]
   4404          
   4405                /* Note : The I2C interrupts must be enabled after unlocking current process
   4406                to avoid the risk of I2C interrupt handle execution before current
   4407                process unlock */
   4408                /* Enable EVT and ERR interrupt */
   4409                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \       0xA0   0x6828             LDR      R0,[R5, #+0]
   \       0xA2   0x6841             LDR      R1,[R0, #+4]
   \       0xA4   0xF441 0x7140      ORR      R1,R1,#0x300
   \       0xA8   0x6041             STR      R1,[R0, #+4]
   4410          
   4411                return HAL_OK;
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xE004             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_5
   4412              }
   4413              else
   4414              {
   4415                /* Update I2C state */
   4416                hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_4: (+1)
   \       0xAE   0x....'....        BL       ?Subroutine84
   4417                hi2c->Mode      = HAL_I2C_MODE_NONE;
   4418          
   4419                /* Update I2C error code */
   4420                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   4421          
   4422                /* Process Unlocked */
   4423                __HAL_UNLOCK(hi2c);
   4424          
   4425                return HAL_ERROR;
   \                     ??CrossCallReturnLabel_260: (+1)
   \       0xB2   0x2001             MOVS     R0,#+1
   \       0xB4   0xE000             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_5
   4426              }
   4427            }
   4428            else
   4429            {
   4430              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_0: (+1)
   \       0xB6   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_5: (+1)
   \       0xB8   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   4431            }
   4432          }
   4433          
   4434          /**
   4435            * @brief  Enable the Address listen mode with Interrupt.
   4436            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4437            *                the configuration information for the specified I2C.
   4438            * @retval HAL status
   4439            */

   \                                 In section .text, align 2, keep-with-next
   4440          HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
   4441          {
   4442            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     HAL_I2C_EnableListen_IT: (+1)
   \        0x0   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \        0x4   0x2920             CMP      R1,#+32
   \        0x6   0xD116             BNE.N    ??HAL_I2C_EnableListen_IT_0
   4443            {
   4444              hi2c->State = HAL_I2C_STATE_LISTEN;
   \        0x8   0x2228             MOVS     R2,#+40
   \        0xA   0xF880 0x203D      STRB     R2,[R0, #+61]
   4445          
   4446              /* Check if the I2C is already enabled */
   4447              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x680B             LDR      R3,[R1, #+0]
   \       0x12   0x07DA             LSLS     R2,R3,#+31
   \       0x14   0xD403             BMI.N    ??HAL_I2C_EnableListen_IT_1
   4448              {
   4449                /* Enable I2C peripheral */
   4450                __HAL_I2C_ENABLE(hi2c);
   \       0x16   0x680B             LDR      R3,[R1, #+0]
   \       0x18   0xF043 0x0301      ORR      R3,R3,#0x1
   \       0x1C   0x600B             STR      R3,[R1, #+0]
   4451              }
   4452          
   4453              /* Enable Address Acknowledge */
   4454              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_EnableListen_IT_1: (+1)
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0x680A             LDR      R2,[R1, #+0]
   \       0x22   0xF442 0x6280      ORR      R2,R2,#0x400
   \       0x26   0x600A             STR      R2,[R1, #+0]
   4455          
   4456              /* Enable EVT and ERR interrupt */
   4457              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x6841             LDR      R1,[R0, #+4]
   \       0x2C   0xF441 0x7140      ORR      R1,R1,#0x300
   \       0x30   0x6041             STR      R1,[R0, #+4]
   4458          
   4459              return HAL_OK;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x4770             BX       LR
   4460            }
   4461            else
   4462            {
   4463              return HAL_BUSY;
   \                     ??HAL_I2C_EnableListen_IT_0: (+1)
   \       0x36   0x2002             MOVS     R0,#+2
   \       0x38   0x4770             BX       LR               ;; return
   4464            }
   4465          }
   4466          
   4467          /**
   4468            * @brief  Disable the Address listen mode with Interrupt.
   4469            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4470            *                the configuration information for the specified I2C.
   4471            * @retval HAL status
   4472            */

   \                                 In section .text, align 2, keep-with-next
   4473          HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
   4474          {
   \                     HAL_I2C_DisableListen_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   4475            /* Declaration of tmp to prevent undefined behavior of volatile usage */
   4476            uint32_t tmp;
   4477          
   4478            /* Disable Address listen mode only if a transfer is not ongoing */
   4479            if (hi2c->State == HAL_I2C_STATE_LISTEN)
   \        0x2   0xF100 0x023D      ADD      R2,R0,#+61
   \        0x6   0x7811             LDRB     R1,[R2, #+0]
   \        0x8   0x2928             CMP      R1,#+40
   \        0xA   0xD115             BNE.N    ??HAL_I2C_DisableListen_IT_0
   4480            {
   4481              tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
   \        0xC   0x7813             LDRB     R3,[R2, #+0]
   4482              hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
   \        0xE   0x7851             LDRB     R1,[R2, #+1]
   \       0x10   0xF003 0x0303      AND      R3,R3,#0x3
   \       0x14   0x430B             ORRS     R3,R1,R3
   \       0x16   0x6303             STR      R3,[R0, #+48]
   4483              hi2c->State = HAL_I2C_STATE_READY;
   4484              hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x18   0x2400             MOVS     R4,#+0
   \       0x1A   0x2320             MOVS     R3,#+32
   \       0x1C   0x7013             STRB     R3,[R2, #+0]
   \       0x1E   0x7054             STRB     R4,[R2, #+1]
   4485          
   4486              /* Disable Address Acknowledge */
   4487              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x20   0x6801             LDR      R1,[R0, #+0]
   \       0x22   0x680A             LDR      R2,[R1, #+0]
   \       0x24   0xF422 0x6280      BIC      R2,R2,#0x400
   \       0x28   0x600A             STR      R2,[R1, #+0]
   4488          
   4489              /* Disable EVT and ERR interrupt */
   4490              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x6841             LDR      R1,[R0, #+4]
   \       0x2E   0xF421 0x7140      BIC      R1,R1,#0x300
   \       0x32   0x6041             STR      R1,[R0, #+4]
   4491          
   4492              return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD10             POP      {R4,PC}
   4493            }
   4494            else
   4495            {
   4496              return HAL_BUSY;
   \                     ??HAL_I2C_DisableListen_IT_0: (+1)
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0xBD10             POP      {R4,PC}          ;; return
   4497            }
   4498          }
   4499          
   4500          /**
   4501            * @brief  Abort a master I2C IT or DMA process communication with Interrupt.
   4502            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4503            *         the configuration information for the specified I2C.
   4504            * @param  DevAddress Target device address: The device 7 bits address value
   4505            *         in datasheet must be shifted to the left before calling the interface
   4506            * @retval HAL status
   4507            */

   \                                 In section .text, align 2, keep-with-next
   4508          HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
   4509          {
   \                     HAL_I2C_Master_Abort_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   4510            /* Prevent unused argument(s) compilation warning */
   4511            UNUSED(DevAddress);
   4512          
   4513            /* Abort Master transfer during Receive or Transmit process    */
   4514            if (hi2c->Mode == HAL_I2C_MODE_MASTER)
   \        0x2   0xF100 0x013C      ADD      R1,R0,#+60
   \        0x6   0x788A             LDRB     R2,[R1, #+2]
   \        0x8   0x2A10             CMP      R2,#+16
   \        0xA   0xD121             BNE.N    ??HAL_I2C_Master_Abort_IT_0
   4515            {
   4516              /* Process Locked */
   4517              __HAL_LOCK(hi2c);
   \        0xC   0x780B             LDRB     R3,[R1, #+0]
   \        0xE   0x2B01             CMP      R3,#+1
   \       0x10   0xD101             BNE.N    ??HAL_I2C_Master_Abort_IT_1
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xBD10             POP      {R4,PC}
   \                     ??HAL_I2C_Master_Abort_IT_1: (+1)
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0x700A             STRB     R2,[R1, #+0]
   4518          
   4519              hi2c->PreviousState = I2C_STATE_NONE;
   \       0x1A   0x2300             MOVS     R3,#+0
   \       0x1C   0x6303             STR      R3,[R0, #+48]
   4520              hi2c->State = HAL_I2C_STATE_ABORT;
   \       0x1E   0x2460             MOVS     R4,#+96
   \       0x20   0x704C             STRB     R4,[R1, #+1]
   4521          
   4522              /* Disable Acknowledge */
   4523              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x22   0x6802             LDR      R2,[R0, #+0]
   \       0x24   0x6813             LDR      R3,[R2, #+0]
   \       0x26   0xF423 0x6380      BIC      R3,R3,#0x400
   \       0x2A   0x6013             STR      R3,[R2, #+0]
   4524          
   4525              /* Generate Stop */
   4526              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0x2C   0x6802             LDR      R2,[R0, #+0]
   \       0x2E   0x6814             LDR      R4,[R2, #+0]
   \       0x30   0xF444 0x7400      ORR      R4,R4,#0x200
   \       0x34   0x6014             STR      R4,[R2, #+0]
   4527          
   4528              hi2c->XferCount = 0U;
   \       0x36   0x2200             MOVS     R2,#+0
   \       0x38   0x8542             STRH     R2,[R0, #+42]
   4529          
   4530              /* Disable EVT, BUF and ERR interrupt */
   4531              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x3A   0x6802             LDR      R2,[R0, #+0]
   \       0x3C   0x6853             LDR      R3,[R2, #+4]
   \       0x3E   0xF423 0x63E0      BIC      R3,R3,#0x700
   \       0x42   0x6053             STR      R3,[R2, #+4]
   4532          
   4533              /* Process Unlocked */
   4534              __HAL_UNLOCK(hi2c);
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0x700A             STRB     R2,[R1, #+0]
   4535          
   4536              /* Call the corresponding callback to inform upper layer of End of Transfer */
   4537              I2C_ITError(hi2c);
   \       0x48   0x....'....        BL       I2C_ITError
   4538          
   4539              return HAL_OK;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xBD10             POP      {R4,PC}
   4540            }
   4541            else
   4542            {
   4543              /* Wrong usage of abort function */
   4544              /* This function should be used only in case of abort monitored by master device */
   4545              return HAL_ERROR;
   \                     ??HAL_I2C_Master_Abort_IT_0: (+1)
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xBD10             POP      {R4,PC}          ;; return
   4546            }
   4547          }
   4548          
   4549          /**
   4550            * @}
   4551            */
   4552          
   4553          /** @defgroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
   4554           * @{
   4555           */
   4556          
   4557          /**
   4558            * @brief  This function handles I2C event interrupt request.
   4559            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4560            *                the configuration information for the specified I2C.
   4561            * @retval None
   4562            */

   \                                 In section .text, align 2, keep-with-next
   4563          void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
   4564          {
   \                     HAL_I2C_EV_IRQHandler: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   4565            uint32_t sr1itflags;
   4566            uint32_t sr2itflags               = 0U;
   4567            uint32_t itsources                = READ_REG(hi2c->Instance->CR2);
   4568            uint32_t CurrentXferOptions       = hi2c->XferOptions;
   4569            HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
   \        0x6   0xF104 0x053C      ADD      R5,R4,#+60
   \        0xA   0x6821             LDR      R1,[R4, #+0]
   4570            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   4571          
   4572            /* Master or Memory mode selected */
   4573            if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
   \        0xC   0x....'....        LDR.W    R6,??DataTable35  ;; 0xffff0000
   \       0x10   0x684A             LDR      R2,[R1, #+4]
   \       0x12   0x6AE0             LDR      R0,[R4, #+44]
   \       0x14   0xF895 0xC002      LDRB     R12,[R5, #+2]
   \       0x18   0x786F             LDRB     R7,[R5, #+1]
   \       0x1A   0x2300             MOVS     R3,#+0
   \       0x1C   0xF1BC 0x0F10      CMP      R12,#+16
   \       0x20   0xBF18             IT       NE
   \       0x22   0xF1BC 0x0F40      CMPNE    R12,#+64
   \       0x26   0xF040 0x81EF      BNE.W    ??HAL_I2C_EV_IRQHandler_0
   4574            {
   4575              sr2itflags   = READ_REG(hi2c->Instance->SR2);
   \       0x2A   0x698B             LDR      R3,[R1, #+24]
   4576              sr1itflags   = READ_REG(hi2c->Instance->SR1);
   \       0x2C   0x694F             LDR      R7,[R1, #+20]
   4577          
   4578              /* Exit IRQ event until Start Bit detected in case of Other frame requested */
   4579              if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) == RESET) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(CurrentXferOptions) == 1U))
   \       0x2E   0xEA5F 0x7CC7      LSLS     R12,R7,#+31
   \       0x32   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_1
   \       0x34   0xF5B0 0x0F2A      CMP      R0,#+11141120
   \       0x38   0xBF18             IT       NE
   \       0x3A   0xF1B0 0x4F2A      CMPNE    R0,#-1442840576
   \       0x3E   0xD046             BEQ.N    ??HAL_I2C_EV_IRQHandler_2
   4580              {
   4581                return;
   4582              }
   4583          
   4584              /* SB Set ----------------------------------------------------------------*/
   4585              if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_1: (+1)
   \       0x40   0x07F8             LSLS     R0,R7,#+31
   \       0x42   0xD545             BPL.N    ??HAL_I2C_EV_IRQHandler_3
   \       0x44   0x0590             LSLS     R0,R2,#+22
   \       0x46   0xD543             BPL.N    ??HAL_I2C_EV_IRQHandler_3
   4586              {
   4587                /* Convert OTHER_xxx XferOptions if any */
   4588                I2C_ConvertOtherXferOptions(hi2c);
   \       0x48   0x6AE0             LDR      R0,[R4, #+44]
   \       0x4A   0xF5B0 0x0F2A      CMP      R0,#+11141120
   \       0x4E   0xBF08             IT       EQ
   \       0x50   0x2201             MOVEQ    R2,#+1
   \       0x52   0xD004             BEQ.N    ??HAL_I2C_EV_IRQHandler_4
   \       0x54   0x6AE0             LDR      R0,[R4, #+44]
   \       0x56   0xF1B0 0x4F2A      CMP      R0,#-1442840576
   \       0x5A   0xD101             BNE.N    ??HAL_I2C_EV_IRQHandler_5
   \       0x5C   0x2208             MOVS     R2,#+8
   \                     ??HAL_I2C_EV_IRQHandler_4: (+1)
   \       0x5E   0x62E2             STR      R2,[R4, #+44]
   4589          
   4590                I2C_Master_SB(hi2c);
   \                     ??HAL_I2C_EV_IRQHandler_5: (+1)
   \       0x60   0x78A8             LDRB     R0,[R5, #+2]
   \       0x62   0x2840             CMP      R0,#+64
   \       0x64   0xD109             BNE.N    ??HAL_I2C_EV_IRQHandler_6
   \       0x66   0x6968             LDR      R0,[R5, #+20]
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0x68A8             LDR      R0,[R5, #+8]
   \       0x6C   0xBF1A             ITTE     NE
   \       0x6E   0xF040 0x0001      ORRNE    R0,R0,#0x1
   \       0x72   0xB2C0             UXTBNE   R0,R0
   \       0x74   0xF000 0x00FE      ANDEQ    R0,R0,#0xFE
   \       0x78   0xE028             B.N      ??HAL_I2C_EV_IRQHandler_7
   \                     ??HAL_I2C_EV_IRQHandler_6: (+1)
   \       0x7A   0x6920             LDR      R0,[R4, #+16]
   \       0x7C   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x80   0xD116             BNE.N    ??HAL_I2C_EV_IRQHandler_8
   \       0x82   0x7868             LDRB     R0,[R5, #+1]
   \       0x84   0x2821             CMP      R0,#+33
   \       0x86   0x68A8             LDR      R0,[R5, #+8]
   \       0x88   0xBF0E             ITEE     EQ
   \       0x8A   0xF000 0x00FE      ANDEQ    R0,R0,#0xFE
   \       0x8E   0xF040 0x0001      ORRNE    R0,R0,#0x1
   \       0x92   0xB2C0             UXTBNE   R0,R0
   \       0x94   0x6108             STR      R0,[R1, #+16]
   \       0x96   0x6B60             LDR      R0,[R4, #+52]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xBF1C             ITT      NE
   \       0x9C   0x6BC0             LDRNE    R0,[R0, #+60]
   \       0x9E   0x2800             CMPNE    R0,#+0
   \       0xA0   0xD12A             BNE.N    ??HAL_I2C_EV_IRQHandler_9
   \       0xA2   0x6BA0             LDR      R0,[R4, #+56]
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xBF1C             ITT      NE
   \       0xA8   0x6BC0             LDRNE    R0,[R0, #+60]
   \       0xAA   0x2800             CMPNE    R0,#+0
   \       0xAC   0xD00F             BEQ.N    ??HAL_I2C_EV_IRQHandler_2
   \       0xAE   0xE023             B.N      ??HAL_I2C_EV_IRQHandler_9
   \                     ??HAL_I2C_EV_IRQHandler_8: (+1)
   \       0xB0   0x6968             LDR      R0,[R5, #+20]
   \       0xB2   0xB920             CBNZ.N   R0,??HAL_I2C_EV_IRQHandler_10
   \       0xB4   0x....'....        BL       ?Subroutine123
   4591              }
   \                     ??CrossCallReturnLabel_356: (+1)
   \       0xB8   0xF040 0x00F0      ORR      R0,R0,#0xF0
   \       0xBC   0xE006             B.N      ??HAL_I2C_EV_IRQHandler_7
   \                     ??HAL_I2C_EV_IRQHandler_10: (+1)
   \       0xBE   0x6968             LDR      R0,[R5, #+20]
   \       0xC0   0x2801             CMP      R0,#+1
   \       0xC2   0xD104             BNE.N    ??HAL_I2C_EV_IRQHandler_2
   \       0xC4   0x....'....        BL       ?Subroutine123
   \                     ??CrossCallReturnLabel_357: (+1)
   \       0xC8   0xF040 0x00F1      ORR      R0,R0,#0xF1
   \                     ??HAL_I2C_EV_IRQHandler_7: (+1)
   \       0xCC   0x6108             STR      R0,[R1, #+16]
   \                     ??HAL_I2C_EV_IRQHandler_2: (+1)
   \       0xCE   0xE29F             B.N      ??CrossCallReturnLabel_368
   4592              /* ADD10 Set -------------------------------------------------------------*/
   4593              else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADD10) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_3: (+1)
   \       0xD0   0x0738             LSLS     R0,R7,#+28
   \       0xD2   0xD516             BPL.N    ??HAL_I2C_EV_IRQHandler_11
   \       0xD4   0x0590             LSLS     R0,R2,#+22
   \       0xD6   0xD514             BPL.N    ??HAL_I2C_EV_IRQHandler_11
   4594              {
   4595                I2C_Master_ADD10(hi2c);
   \       0xD8   0x68A8             LDR      R0,[R5, #+8]
   \       0xDA   0xB2C0             UXTB     R0,R0
   \       0xDC   0x6108             STR      R0,[R1, #+16]
   \       0xDE   0x6B61             LDR      R1,[R4, #+52]
   \       0xE0   0x2900             CMP      R1,#+0
   \       0xE2   0xBF04             ITT      EQ
   \       0xE4   0x6BA0             LDREQ    R0,[R4, #+56]
   \       0xE6   0x2800             CMPEQ    R0,#+0
   \       0xE8   0xD0F1             BEQ.N    ??HAL_I2C_EV_IRQHandler_2
   \       0xEA   0x6BC8             LDR      R0,[R1, #+60]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xBF02             ITTT     EQ
   \       0xF0   0x6BA1             LDREQ    R1,[R4, #+56]
   \       0xF2   0x6BC8             LDREQ    R0,[R1, #+60]
   \       0xF4   0x2800             CMPEQ    R0,#+0
   \       0xF6   0xD0EA             BEQ.N    ??HAL_I2C_EV_IRQHandler_2
   \                     ??HAL_I2C_EV_IRQHandler_9: (+1)
   \       0xF8   0x6820             LDR      R0,[R4, #+0]
   \       0xFA   0x6841             LDR      R1,[R0, #+4]
   \       0xFC   0xF441 0x6100      ORR      R1,R1,#0x800
   \      0x100   0xE10F             B.N      ??HAL_I2C_EV_IRQHandler_12
   4596              }
   4597              /* ADDR Set --------------------------------------------------------------*/
   4598              else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_11: (+1)
   \      0x102   0x07B8             LSLS     R0,R7,#+30
   \      0x104   0xD500             BPL.N    ??HAL_I2C_EV_IRQHandler_13
   \      0x106   0x0590             LSLS     R0,R2,#+22
   \                     ??HAL_I2C_EV_IRQHandler_13: (+1)
   \      0x108   0xF140 0x808F      BPL.W    ??HAL_I2C_EV_IRQHandler_14
   4599              {
   4600                I2C_Master_ADDR(hi2c);
   \      0x10C   0x78AB             LDRB     R3,[R5, #+2]
   \      0x10E   0x6AE2             LDR      R2,[R4, #+44]
   \      0x110   0x6B27             LDR      R7,[R4, #+48]
   \      0x112   0x7868             LDRB     R0,[R5, #+1]
   \      0x114   0x2822             CMP      R0,#+34
   \      0x116   0xF040 0x8080      BNE.W    ??HAL_I2C_EV_IRQHandler_15
   \      0x11A   0x6968             LDR      R0,[R5, #+20]
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xBF08             IT       EQ
   \      0x120   0x2B40             CMPEQ    R3,#+64
   \      0x122   0xD07A             BEQ.N    ??HAL_I2C_EV_IRQHandler_15
   \      0x124   0x6968             LDR      R0,[R5, #+20]
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xBF04             ITT      EQ
   \      0x12A   0x6920             LDREQ    R0,[R4, #+16]
   \      0x12C   0xF5B0 0x4F40      CMPEQ    R0,#+49152
   \      0x130   0xD108             BNE.N    ??HAL_I2C_EV_IRQHandler_16
   \      0x132   0x....'....        BL       ?Subroutine92
   4601              }
   \                     ??CrossCallReturnLabel_273: (+1)
   \      0x136   0xF440 0x7080      ORR      R0,R0,#0x100
   \      0x13A   0x6008             STR      R0,[R1, #+0]
   \      0x13C   0x6968             LDR      R0,[R5, #+20]
   \      0x13E   0x1C40             ADDS     R0,R0,#+1
   \      0x140   0x6168             STR      R0,[R5, #+20]
   \      0x142   0xE265             B.N      ??CrossCallReturnLabel_368
   \                     ??HAL_I2C_EV_IRQHandler_16: (+1)
   \      0x144   0x8D60             LDRH     R0,[R4, #+42]
   \      0x146   0xB928             CBNZ.N   R0,??HAL_I2C_EV_IRQHandler_17
   \      0x148   0x....'....        BL       ?Subroutine92
   \                     ??CrossCallReturnLabel_274: (+1)
   \      0x14C   0xF440 0x7000      ORR      R0,R0,#0x200
   \      0x150   0x6008             STR      R0,[R1, #+0]
   \      0x152   0xE05F             B.N      ??HAL_I2C_EV_IRQHandler_18
   \                     ??HAL_I2C_EV_IRQHandler_17: (+1)
   \      0x154   0x8D60             LDRH     R0,[R4, #+42]
   \      0x156   0x2801             CMP      R0,#+1
   \      0x158   0xD130             BNE.N    ??HAL_I2C_EV_IRQHandler_19
   \      0x15A   0x42B2             CMP      R2,R6
   \      0x15C   0xD10F             BNE.N    ??HAL_I2C_EV_IRQHandler_20
   \      0x15E   0x6808             LDR      R0,[R1, #+0]
   \      0x160   0xF420 0x6080      BIC      R0,R0,#0x400
   \      0x164   0x6008             STR      R0,[R1, #+0]
   \      0x166   0x6821             LDR      R1,[R4, #+0]
   \      0x168   0x6848             LDR      R0,[R1, #+4]
   \      0x16A   0x0502             LSLS     R2,R0,#+20
   \      0x16C   0xD502             BPL.N    ??HAL_I2C_EV_IRQHandler_21
   \      0x16E   0x....'....        BL       ?Subroutine125
   \                     ??CrossCallReturnLabel_360: (+1)
   \      0x172   0xE021             B.N      ??CrossCallReturnLabel_178
   \                     ??HAL_I2C_EV_IRQHandler_21: (+1)
   \      0x174   0x2200             MOVS     R2,#+0
   \      0x176   0x9200             STR      R2,[SP, #+0]
   \      0x178   0x694B             LDR      R3,[R1, #+20]
   \      0x17A   0x9300             STR      R3,[SP, #+0]
   \      0x17C   0xE00C             B.N      ??CrossCallReturnLabel_35
   \                     ??HAL_I2C_EV_IRQHandler_20: (+1)
   \      0x17E   0x2A08             CMP      R2,#+8
   \      0x180   0xBF18             IT       NE
   \      0x182   0x2A20             CMPNE    R2,#+32
   \      0x184   0xD003             BEQ.N    ??HAL_I2C_EV_IRQHandler_22
   \      0x186   0x2F12             CMP      R7,#+18
   \      0x188   0xD10C             BNE.N    ??HAL_I2C_EV_IRQHandler_23
   \      0x18A   0x2A01             CMP      R2,#+1
   \      0x18C   0xD00F             BEQ.N    ??HAL_I2C_EV_IRQHandler_24
   \                     ??HAL_I2C_EV_IRQHandler_22: (+1)
   \      0x18E   0x4608             MOV      R0,R1
   \      0x190   0x....'....        BL       ??Subroutine60_0
   \                     ??CrossCallReturnLabel_175: (+1)
   \      0x194   0x....'....        BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_35: (+1)
   \      0x198   0x6989             LDR      R1,[R1, #+24]
   \      0x19A   0x9100             STR      R1,[SP, #+0]
   \      0x19C   0x9800             LDR      R0,[SP, #+0]
   \      0x19E   0x....'....        BL       ?Subroutine68
   \                     ??CrossCallReturnLabel_208: (+1)
   \      0x1A2   0xE037             B.N      ??HAL_I2C_EV_IRQHandler_18
   \                     ??HAL_I2C_EV_IRQHandler_23: (+1)
   \      0x1A4   0x2A04             CMP      R2,#+4
   \      0x1A6   0xBF1C             ITT      NE
   \      0x1A8   0x2A02             CMPNE    R2,#+2
   \      0x1AA   0x2A10             CMPNE    R2,#+16
   \      0x1AC   0xD002             BEQ.N    ??HAL_I2C_EV_IRQHandler_25
   \                     ??HAL_I2C_EV_IRQHandler_24: (+1)
   \      0x1AE   0x....'....        BL       ?Subroutine125
   \                     ??CrossCallReturnLabel_361: (+1)
   \      0x1B2   0xE001             B.N      ??CrossCallReturnLabel_178
   \                     ??HAL_I2C_EV_IRQHandler_25: (+1)
   \      0x1B4   0x....'....        BL       ?Subroutine61
   \                     ??CrossCallReturnLabel_178: (+1)
   \      0x1B8   0x6001             STR      R1,[R0, #+0]
   \      0x1BA   0xE026             B.N      ??CrossCallReturnLabel_341
   \                     ??HAL_I2C_EV_IRQHandler_19: (+1)
   \      0x1BC   0x8D61             LDRH     R1,[R4, #+42]
   \      0x1BE   0x2902             CMP      R1,#+2
   \      0x1C0   0xD10F             BNE.N    ??HAL_I2C_EV_IRQHandler_26
   \      0x1C2   0x2A04             CMP      R2,#+4
   \      0x1C4   0xBF1C             ITT      NE
   \      0x1C6   0x2A02             CMPNE    R2,#+2
   \      0x1C8   0x2A10             CMPNE    R2,#+16
   \      0x1CA   0xD005             BEQ.N    ??HAL_I2C_EV_IRQHandler_27
   \      0x1CC   0x....'....        BL       ?Subroutine39
   \                     ??CrossCallReturnLabel_107: (+1)
   \      0x1D0   0x6801             LDR      R1,[R0, #+0]
   \      0x1D2   0xF441 0x6100      ORR      R1,R1,#0x800
   \      0x1D6   0xE002             B.N      ??CrossCallReturnLabel_179
   \                     ??HAL_I2C_EV_IRQHandler_27: (+1)
   \      0x1D8   0x6820             LDR      R0,[R4, #+0]
   \      0x1DA   0x....'....        BL       ??Subroutine61_0
   \                     ??CrossCallReturnLabel_179: (+1)
   \      0x1DE   0x6001             STR      R1,[R0, #+0]
   \      0x1E0   0xE004             B.N      ??HAL_I2C_EV_IRQHandler_28
   \                     ??HAL_I2C_EV_IRQHandler_26: (+1)
   \      0x1E2   0x6821             LDR      R1,[R4, #+0]
   \      0x1E4   0x680B             LDR      R3,[R1, #+0]
   \      0x1E6   0xF443 0x6380      ORR      R3,R3,#0x400
   \      0x1EA   0x600B             STR      R3,[R1, #+0]
   \                     ??HAL_I2C_EV_IRQHandler_28: (+1)
   \      0x1EC   0x6820             LDR      R0,[R4, #+0]
   \      0x1EE   0x6841             LDR      R1,[R0, #+4]
   \      0x1F0   0x050B             LSLS     R3,R1,#+20
   \      0x1F2   0xD50A             BPL.N    ??CrossCallReturnLabel_341
   \      0x1F4   0x42B2             CMP      R2,R6
   \      0x1F6   0xBF18             IT       NE
   \      0x1F8   0x2A01             CMPNE    R2,#+1
   \      0x1FA   0xD004             BEQ.N    ??HAL_I2C_EV_IRQHandler_29
   \      0x1FC   0x2A08             CMP      R2,#+8
   \      0x1FE   0xBF1C             ITT      NE
   \      0x200   0x2A10             CMPNE    R2,#+16
   \      0x202   0x2A20             CMPNE    R2,#+32
   \      0x204   0xD101             BNE.N    ??CrossCallReturnLabel_341
   \                     ??HAL_I2C_EV_IRQHandler_29: (+1)
   \      0x206   0x....'....        BL       ?Subroutine115
   \                     ??CrossCallReturnLabel_341: (+1)
   \      0x20A   0x....'....        BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_36: (+1)
   \      0x20E   0x6989             LDR      R1,[R1, #+24]
   \      0x210   0x9100             STR      R1,[SP, #+0]
   \      0x212   0x9800             LDR      R0,[SP, #+0]
   \                     ??HAL_I2C_EV_IRQHandler_18: (+1)
   \      0x214   0x2100             MOVS     R1,#+0
   \      0x216   0x6169             STR      R1,[R5, #+20]
   \      0x218   0xE1FA             B.N      ??CrossCallReturnLabel_368
   \                     ??HAL_I2C_EV_IRQHandler_15: (+1)
   \      0x21A   0x2200             MOVS     R2,#+0
   \      0x21C   0x9200             STR      R2,[SP, #+0]
   \      0x21E   0x694B             LDR      R3,[R1, #+20]
   \      0x220   0x9300             STR      R3,[SP, #+0]
   \      0x222   0x6989             LDR      R1,[R1, #+24]
   \      0x224   0x9100             STR      R1,[SP, #+0]
   \      0x226   0x9A00             LDR      R2,[SP, #+0]
   \                     ??HAL_I2C_EV_IRQHandler_30: (+1)
   \      0x228   0xE1F2             B.N      ??CrossCallReturnLabel_368
   4602              /* I2C in mode Transmitter -----------------------------------------------*/
   4603              else if (I2C_CHECK_FLAG(sr2itflags, I2C_FLAG_TRA) != RESET)
   \                     ??HAL_I2C_EV_IRQHandler_14: (+1)
   \      0x22A   0x075B             LSLS     R3,R3,#+29
   \      0x22C   0xF007 0x0004      AND      R0,R7,#0x4
   \      0x230   0xD55E             BPL.N    ??HAL_I2C_EV_IRQHandler_31
   4604              {
   4605                /* Do not check buffer and BTF flag if a Xfer DMA is on going */
   4606                if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
   \      0x232   0x684B             LDR      R3,[R1, #+4]
   \      0x234   0x051B             LSLS     R3,R3,#+20
   \      0x236   0xD4F7             BMI.N    ??HAL_I2C_EV_IRQHandler_30
   4607                {
   4608                  /* TXE set and BTF reset -----------------------------------------------*/
   4609                  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
   \      0x238   0x063F             LSLS     R7,R7,#+24
   \      0x23A   0xD530             BPL.N    ??HAL_I2C_EV_IRQHandler_32
   \      0x23C   0x0553             LSLS     R3,R2,#+21
   \      0x23E   0xD52E             BPL.N    ??HAL_I2C_EV_IRQHandler_32
   \      0x240   0x2800             CMP      R0,#+0
   \      0x242   0xD12C             BNE.N    ??HAL_I2C_EV_IRQHandler_32
   4610                  {
   4611                    I2C_MasterTransmit_TXE(hi2c);
   \      0x244   0x786A             LDRB     R2,[R5, #+1]
   \      0x246   0x78AB             LDRB     R3,[R5, #+2]
   \      0x248   0x6AE7             LDR      R7,[R4, #+44]
   \      0x24A   0x8D20             LDRH     R0,[R4, #+40]
   \      0x24C   0x2800             CMP      R0,#+0
   \      0x24E   0xBF08             IT       EQ
   \      0x250   0x2A21             CMPEQ    R2,#+33
   \      0x252   0xD113             BNE.N    ??HAL_I2C_EV_IRQHandler_33
   \      0x254   0x2F08             CMP      R7,#+8
   \      0x256   0xBF1C             ITT      NE
   \      0x258   0x2F20             CMPNE    R7,#+32
   \      0x25A   0x42B7             CMPNE    R7,R6
   \      0x25C   0xD004             BEQ.N    ??HAL_I2C_EV_IRQHandler_34
   \      0x25E   0x....'....        BL       ?Subroutine124
   4612                  }
   \                     ??CrossCallReturnLabel_358: (+1)
   \      0x262   0x2200             MOVS     R2,#+0
   \      0x264   0x70AA             STRB     R2,[R5, #+2]
   \      0x266   0xE02F             B.N      ??HAL_I2C_EV_IRQHandler_35
   \                     ??HAL_I2C_EV_IRQHandler_34: (+1)
   \      0x268   0x....'....        BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_43: (+1)
   \      0x26C   0xD132             BNE.N    ??HAL_I2C_EV_IRQHandler_36
   \                     ??HAL_I2C_EV_IRQHandler_37: (+1)
   \      0x26E   0x2100             MOVS     R1,#+0
   \      0x270   0x70A9             STRB     R1,[R5, #+2]
   \      0x272   0x4620             MOV      R0,R4
   \      0x274   0xE8BD 0x41F6      POP      {R1,R2,R4-R8,LR}
   \      0x278   0x....'....        B.W      HAL_I2C_MemTxCpltCallback
   \                     ??HAL_I2C_EV_IRQHandler_33: (+1)
   \      0x27C   0x2A21             CMP      R2,#+33
   \      0x27E   0xD003             BEQ.N    ??HAL_I2C_EV_IRQHandler_38
   \      0x280   0x2B40             CMP      R3,#+64
   \      0x282   0xBF08             IT       EQ
   \      0x284   0x2A22             CMPEQ    R2,#+34
   \      0x286   0xD105             BNE.N    ??HAL_I2C_EV_IRQHandler_39
   \                     ??HAL_I2C_EV_IRQHandler_38: (+1)
   \      0x288   0x8D60             LDRH     R0,[R4, #+42]
   \      0x28A   0xB920             CBNZ.N   R0,??HAL_I2C_EV_IRQHandler_40
   \      0x28C   0x6848             LDR      R0,[R1, #+4]
   \      0x28E   0xF420 0x6080      BIC      R0,R0,#0x400
   \      0x292   0x6048             STR      R0,[R1, #+4]
   \                     ??HAL_I2C_EV_IRQHandler_39: (+1)
   \      0x294   0xE1BC             B.N      ??CrossCallReturnLabel_368
   \                     ??HAL_I2C_EV_IRQHandler_40: (+1)
   \      0x296   0x78A8             LDRB     R0,[R5, #+2]
   \      0x298   0x2840             CMP      R0,#+64
   \      0x29A   0xD025             BEQ.N    ??HAL_I2C_EV_IRQHandler_41
   \      0x29C   0xE185             B.N      ??HAL_I2C_EV_IRQHandler_42
   4613                  /* BTF set -------------------------------------------------------------*/
   4614                  else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_32: (+1)
   \      0x29E   0x2800             CMP      R0,#+0
   \      0x2A0   0xD0F8             BEQ.N    ??HAL_I2C_EV_IRQHandler_39
   \      0x2A2   0x0590             LSLS     R0,R2,#+22
   \      0x2A4   0xD5F6             BPL.N    ??HAL_I2C_EV_IRQHandler_39
   4615                  {
   4616                    I2C_MasterTransmit_BTF(hi2c);
   \      0x2A6   0x6AE2             LDR      R2,[R4, #+44]
   \      0x2A8   0x7868             LDRB     R0,[R5, #+1]
   \      0x2AA   0x2821             CMP      R0,#+33
   \      0x2AC   0xD119             BNE.N    ??HAL_I2C_EV_IRQHandler_43
   \      0x2AE   0x8D60             LDRH     R0,[R4, #+42]
   \      0x2B0   0xB108             CBZ      R0,.+6
   \      0x2B2   0xF000 0xB97A      B.W      ??HAL_I2C_EV_IRQHandler_42
   \      0x2B6   0x2A08             CMP      R2,#+8
   \      0x2B8   0xBF1C             ITT      NE
   \      0x2BA   0x2A20             CMPNE    R2,#+32
   \      0x2BC   0x42B2             CMPNE    R2,R6
   \      0x2BE   0xD006             BEQ.N    ??HAL_I2C_EV_IRQHandler_44
   \      0x2C0   0x....'....        BL       ?Subroutine124
   4617                  }
   4618                  else
   4619                  {
   4620                    /* Do nothing */
   4621                  }
   4622                }
   4623              }
   \                     ??CrossCallReturnLabel_359: (+1)
   \      0x2C4   0x2000             MOVS     R0,#+0
   \      0x2C6   0x70A8             STRB     R0,[R5, #+2]
   \                     ??HAL_I2C_EV_IRQHandler_35: (+1)
   \      0x2C8   0x2120             MOVS     R1,#+32
   \      0x2CA   0x7069             STRB     R1,[R5, #+1]
   \      0x2CC   0xE004             B.N      ??HAL_I2C_EV_IRQHandler_45
   \                     ??HAL_I2C_EV_IRQHandler_44: (+1)
   \      0x2CE   0x....'....        BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_44: (+1)
   \      0x2D2   0xD0CC             BEQ.N    ??HAL_I2C_EV_IRQHandler_37
   \                     ??HAL_I2C_EV_IRQHandler_36: (+1)
   \      0x2D4   0x2100             MOVS     R1,#+0
   \      0x2D6   0x70A9             STRB     R1,[R5, #+2]
   \                     ??HAL_I2C_EV_IRQHandler_45: (+1)
   \      0x2D8   0x4620             MOV      R0,R4
   \      0x2DA   0xE8BD 0x41F6      POP      {R1,R2,R4-R8,LR}
   \      0x2DE   0x....'....        B.W      HAL_I2C_MasterTxCpltCallback
   \                     ??HAL_I2C_EV_IRQHandler_43: (+1)
   \      0x2E2   0x78A8             LDRB     R0,[R5, #+2]
   \      0x2E4   0x2840             CMP      R0,#+64
   \      0x2E6   0xD11D             BNE.N    ??HAL_I2C_EV_IRQHandler_46
   \                     ??HAL_I2C_EV_IRQHandler_41: (+1)
   \      0x2E8   0x4620             MOV      R0,R4
   \      0x2EA   0xE8BD 0x41F6      POP      {R1,R2,R4-R8,LR}
   \      0x2EE   0x....             B.N      I2C_MemoryTransmit_TXE_BTF
   4624              /* I2C in mode Receiver --------------------------------------------------*/
   4625              else
   4626              {
   4627                /* Do not check buffer and BTF flag if a Xfer DMA is on going */
   4628                if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
   \                     ??HAL_I2C_EV_IRQHandler_31: (+1)
   \      0x2F0   0x684B             LDR      R3,[R1, #+4]
   \      0x2F2   0x051E             LSLS     R6,R3,#+20
   \      0x2F4   0xD416             BMI.N    ??HAL_I2C_EV_IRQHandler_46
   4629                {
   4630                  /* RXNE set and BTF reset -----------------------------------------------*/
   4631                  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
   \      0x2F6   0x067B             LSLS     R3,R7,#+25
   \      0x2F8   0xD533             BPL.N    ??HAL_I2C_EV_IRQHandler_47
   \      0x2FA   0x0556             LSLS     R6,R2,#+21
   \      0x2FC   0xD531             BPL.N    ??HAL_I2C_EV_IRQHandler_47
   \      0x2FE   0x2800             CMP      R0,#+0
   \      0x300   0xD12F             BNE.N    ??HAL_I2C_EV_IRQHandler_47
   4632                  {
   4633                    I2C_MasterReceive_RXNE(hi2c);
   \      0x302   0x7868             LDRB     R0,[R5, #+1]
   \      0x304   0x2822             CMP      R0,#+34
   \      0x306   0xD10D             BNE.N    ??HAL_I2C_EV_IRQHandler_46
   \      0x308   0x8D60             LDRH     R0,[R4, #+42]
   \      0x30A   0x2804             CMP      R0,#+4
   \      0x30C   0xD30B             BCC.N    ??HAL_I2C_EV_IRQHandler_48
   \      0x30E   0x6908             LDR      R0,[R1, #+16]
   \      0x310   0x....'....        BL       ??Subroutine91_0
   4634                  }
   \                     ??CrossCallReturnLabel_369: (+1)
   \      0x314   0x8D60             LDRH     R0,[R4, #+42]
   \      0x316   0x2803             CMP      R0,#+3
   \      0x318   0xD104             BNE.N    ??HAL_I2C_EV_IRQHandler_46
   \      0x31A   0x6820             LDR      R0,[R4, #+0]
   \      0x31C   0x6841             LDR      R1,[R0, #+4]
   \      0x31E   0xF421 0x6180      BIC      R1,R1,#0x400
   \                     ??HAL_I2C_EV_IRQHandler_12: (+1)
   \      0x322   0x6041             STR      R1,[R0, #+4]
   \                     ??HAL_I2C_EV_IRQHandler_46: (+1)
   \      0x324   0xE174             B.N      ??CrossCallReturnLabel_368
   \                     ??HAL_I2C_EV_IRQHandler_48: (+1)
   \      0x326   0x6AE1             LDR      R1,[R4, #+44]
   \      0x328   0x2902             CMP      R1,#+2
   \      0x32A   0xD0FB             BEQ.N    ??HAL_I2C_EV_IRQHandler_46
   \      0x32C   0x2801             CMP      R0,#+1
   \      0x32E   0xBF18             IT       NE
   \      0x330   0x2800             CMPNE    R0,#+0
   \      0x332   0xD1F7             BNE.N    ??HAL_I2C_EV_IRQHandler_46
   \      0x334   0x....'....        BL       ?Subroutine39
   \                     ??CrossCallReturnLabel_108: (+1)
   \      0x338   0x6841             LDR      R1,[R0, #+4]
   \      0x33A   0xF421 0x61E0      BIC      R1,R1,#0x700
   \      0x33E   0x6041             STR      R1,[R0, #+4]
   \      0x340   0x....'....        BL       ?Subroutine37
   \                     ??CrossCallReturnLabel_103: (+1)
   \      0x344   0x2220             MOVS     R2,#+32
   \      0x346   0x....'....        BL       ??Subroutine127_0
   \                     ??CrossCallReturnLabel_366: (+1)
   \      0x34A   0x706A             STRB     R2,[R5, #+1]
   \      0x34C   0x78A8             LDRB     R0,[R5, #+2]
   \      0x34E   0x2840             CMP      R0,#+64
   \      0x350   0xD151             BNE.N    ??HAL_I2C_EV_IRQHandler_49
   \                     ??HAL_I2C_EV_IRQHandler_50: (+1)
   \      0x352   0x2100             MOVS     R1,#+0
   \      0x354   0x70A9             STRB     R1,[R5, #+2]
   \      0x356   0x6321             STR      R1,[R4, #+48]
   \      0x358   0x4620             MOV      R0,R4
   \      0x35A   0xE8BD 0x41F6      POP      {R1,R2,R4-R8,LR}
   \      0x35E   0x....'....        B.W      HAL_I2C_MemRxCpltCallback
   4635                  /* BTF set -------------------------------------------------------------*/
   4636                  else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_47: (+1)
   \      0x362   0x2800             CMP      R0,#+0
   \      0x364   0xD0DE             BEQ.N    ??HAL_I2C_EV_IRQHandler_46
   \      0x366   0x0590             LSLS     R0,R2,#+22
   \      0x368   0xD5DC             BPL.N    ??HAL_I2C_EV_IRQHandler_46
   4637                  {
   4638                    I2C_MasterReceive_BTF(hi2c);
   \      0x36A   0x6AE0             LDR      R0,[R4, #+44]
   \      0x36C   0x8D62             LDRH     R2,[R4, #+42]
   \      0x36E   0x2A04             CMP      R2,#+4
   \      0x370   0xD105             BNE.N    ??HAL_I2C_EV_IRQHandler_51
   \      0x372   0x6848             LDR      R0,[R1, #+4]
   \      0x374   0xF420 0x6080      BIC      R0,R0,#0x400
   \      0x378   0x6048             STR      R0,[R1, #+4]
   \      0x37A   0x6821             LDR      R1,[R4, #+0]
   \                     ??HAL_I2C_EV_IRQHandler_52: (+1)
   \      0x37C   0xE140             B.N      ??HAL_I2C_EV_IRQHandler_53
   \                     ??HAL_I2C_EV_IRQHandler_51: (+1)
   \      0x37E   0x8D62             LDRH     R2,[R4, #+42]
   \      0x380   0x2A03             CMP      R2,#+3
   \      0x382   0xD110             BNE.N    ??HAL_I2C_EV_IRQHandler_54
   \      0x384   0x684A             LDR      R2,[R1, #+4]
   \      0x386   0x2804             CMP      R0,#+4
   \      0x388   0xF422 0x6280      BIC      R2,R2,#0x400
   \      0x38C   0xBF18             IT       NE
   \      0x38E   0x2802             CMPNE    R0,#+2
   \      0x390   0x604A             STR      R2,[R1, #+4]
   \      0x392   0xD001             BEQ.N    ??CrossCallReturnLabel_110
   \      0x394   0x....'....        BL       ?Subroutine40
   4639                  }
   4640                  else
   4641                  {
   4642                    /* Do nothing */
   4643                  }
   4644                }
   4645              }
   4646            }
   \                     ??CrossCallReturnLabel_110: (+1)
   \      0x398   0x6820             LDR      R0,[R4, #+0]
   \      0x39A   0x6901             LDR      R1,[R0, #+16]
   \      0x39C   0x6A60             LDR      R0,[R4, #+36]
   \      0x39E   0x7001             STRB     R1,[R0, #+0]
   \      0x3A0   0x6A61             LDR      R1,[R4, #+36]
   \      0x3A2   0x1C4A             ADDS     R2,R1,#+1
   \      0x3A4   0xE131             B.N      ??HAL_I2C_EV_IRQHandler_55
   \                     ??HAL_I2C_EV_IRQHandler_54: (+1)
   \      0x3A6   0x8D62             LDRH     R2,[R4, #+42]
   \      0x3A8   0x2A02             CMP      R2,#+2
   \      0x3AA   0xD1E7             BNE.N    ??HAL_I2C_EV_IRQHandler_52
   \      0x3AC   0x2801             CMP      R0,#+1
   \      0x3AE   0xBF18             IT       NE
   \      0x3B0   0x2810             CMPNE    R0,#+16
   \      0x3B2   0xD00B             BEQ.N    ??HAL_I2C_EV_IRQHandler_56
   \      0x3B4   0x2804             CMP      R0,#+4
   \      0x3B6   0xBF18             IT       NE
   \      0x3B8   0x2802             CMPNE    R0,#+2
   \      0x3BA   0xD004             BEQ.N    ??HAL_I2C_EV_IRQHandler_57
   \      0x3BC   0x4608             MOV      R0,R1
   \      0x3BE   0x6801             LDR      R1,[R0, #+0]
   \      0x3C0   0xF441 0x7100      ORR      R1,R1,#0x200
   \      0x3C4   0xE004             B.N      ??CrossCallReturnLabel_362
   \                     ??HAL_I2C_EV_IRQHandler_57: (+1)
   \      0x3C6   0x....'....        BL       ?Subroutine61
   \                     ??CrossCallReturnLabel_180: (+1)
   \      0x3CA   0xE001             B.N      ??CrossCallReturnLabel_362
   \                     ??HAL_I2C_EV_IRQHandler_56: (+1)
   \      0x3CC   0x....'....        BL       ?Subroutine125
   \                     ??CrossCallReturnLabel_362: (+1)
   \      0x3D0   0x6001             STR      R1,[R0, #+0]
   \      0x3D2   0x....'....        BL       ?Subroutine37
   \                     ??CrossCallReturnLabel_104: (+1)
   \      0x3D6   0x....'....        BL       ??Subroutine127_0
   \                     ??CrossCallReturnLabel_367: (+1)
   \      0x3DA   0x6822             LDR      R2,[R4, #+0]
   \      0x3DC   0x6910             LDR      R0,[R2, #+16]
   \      0x3DE   0x....'....        BL       ??Subroutine91_0
   \                     ??CrossCallReturnLabel_370: (+1)
   \      0x3E2   0x6820             LDR      R0,[R4, #+0]
   \      0x3E4   0x6841             LDR      R1,[R0, #+4]
   \      0x3E6   0xF421 0x7140      BIC      R1,R1,#0x300
   \      0x3EA   0x6041             STR      R1,[R0, #+4]
   \      0x3EC   0x2020             MOVS     R0,#+32
   \      0x3EE   0x7068             STRB     R0,[R5, #+1]
   \      0x3F0   0x78A9             LDRB     R1,[R5, #+2]
   \      0x3F2   0x2940             CMP      R1,#+64
   \      0x3F4   0xD0AD             BEQ.N    ??HAL_I2C_EV_IRQHandler_50
   \                     ??HAL_I2C_EV_IRQHandler_49: (+1)
   \      0x3F6   0x2000             MOVS     R0,#+0
   \      0x3F8   0x70A8             STRB     R0,[R5, #+2]
   \      0x3FA   0x2112             MOVS     R1,#+18
   \      0x3FC   0x6321             STR      R1,[R4, #+48]
   \      0x3FE   0x4620             MOV      R0,R4
   \      0x400   0xE8BD 0x41F6      POP      {R1,R2,R4-R8,LR}
   \      0x404   0x....'....        B.W      HAL_I2C_MasterRxCpltCallback
   4647            /* Slave mode selected */
   4648            else
   4649            {
   4650              /* If an error is detected, read only SR1 register to prevent */
   4651              /* a clear of ADDR flags by reading SR2 after reading SR1 in Error treatment */
   4652              if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??HAL_I2C_EV_IRQHandler_0: (+1)
   \      0x408   0x6868             LDR      R0,[R5, #+4]
   \      0x40A   0xB900             CBNZ.N   R0,??HAL_I2C_EV_IRQHandler_58
   4653              {
   4654                sr1itflags   = READ_REG(hi2c->Instance->SR1);
   4655              }
   4656              else
   4657              {
   4658                sr2itflags   = READ_REG(hi2c->Instance->SR2);
   \      0x40C   0x698B             LDR      R3,[R1, #+24]
   4659                sr1itflags   = READ_REG(hi2c->Instance->SR1);
   \                     ??HAL_I2C_EV_IRQHandler_58: (+1)
   \      0x40E   0xF8D1 0xC014      LDR      R12,[R1, #+20]
   4660              }
   4661          
   4662              /* ADDR set --------------------------------------------------------------*/
   4663              if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \      0x412   0xEA5F 0x708C      LSLS     R0,R12,#+30
   \      0x416   0xD525             BPL.N    ??HAL_I2C_EV_IRQHandler_59
   \      0x418   0x0590             LSLS     R0,R2,#+22
   \      0x41A   0xD523             BPL.N    ??HAL_I2C_EV_IRQHandler_59
   4664              {
   4665                /* Now time to read SR2, this will clear ADDR flag automatically */
   4666                if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \      0x41C   0x6868             LDR      R0,[R5, #+4]
   \      0x41E   0xB100             CBZ.N    R0,??HAL_I2C_EV_IRQHandler_60
   4667                {
   4668                  sr2itflags   = READ_REG(hi2c->Instance->SR2);
   \      0x420   0x698B             LDR      R3,[R1, #+24]
   4669                }
   4670                I2C_Slave_ADDR(hi2c, sr2itflags);
   \                     ??HAL_I2C_EV_IRQHandler_60: (+1)
   \      0x422   0x786A             LDRB     R2,[R5, #+1]
   \      0x424   0x2000             MOVS     R0,#+0
   \      0x426   0xF002 0x0228      AND      R2,R2,#0x28
   \      0x42A   0x2A28             CMP      R2,#+40
   \      0x42C   0xD114             BNE.N    ??HAL_I2C_EV_IRQHandler_61
   \      0x42E   0x684A             LDR      R2,[R1, #+4]
   \      0x430   0xF422 0x6280      BIC      R2,R2,#0x400
   \      0x434   0x604A             STR      R2,[R1, #+4]
   \      0x436   0x0759             LSLS     R1,R3,#+29
   \      0x438   0xBF58             IT       PL
   \      0x43A   0x2001             MOVPL    R0,#+1
   \      0x43C   0x0619             LSLS     R1,R3,#+24
   \      0x43E   0xBF54             ITE      PL
   \      0x440   0x68E2             LDRPL    R2,[R4, #+12]
   \      0x442   0x69A2             LDRMI    R2,[R4, #+24]
   \      0x444   0x2100             MOVS     R1,#+0
   \      0x446   0x7029             STRB     R1,[R5, #+0]
   \      0x448   0xB002             ADD      SP,SP,#+8
   \      0x44A   0x4601             MOV      R1,R0
   \      0x44C   0x4620             MOV      R0,R4
   \      0x44E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \      0x452   0xB292             UXTH     R2,R2
   \      0x454   0x....'....        B.W      HAL_I2C_AddrCallback
   \                     ??HAL_I2C_EV_IRQHandler_61: (+1)
   \      0x458   0xF06F 0x0002      MVN      R0,#+2
   \      0x45C   0x6148             STR      R0,[R1, #+20]
   \      0x45E   0x2100             MOVS     R1,#+0
   \      0x460   0x7029             STRB     R1,[R5, #+0]
   \      0x462   0xE0D5             B.N      ??CrossCallReturnLabel_368
   4671              }
   4672              /* STOPF set --------------------------------------------------------------*/
   4673              else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_59: (+1)
   \      0x464   0xEA5F 0x60CC      LSLS     R0,R12,#+27
   \      0x468   0xD572             BPL.N    ??HAL_I2C_EV_IRQHandler_62
   \      0x46A   0x0593             LSLS     R3,R2,#+22
   \      0x46C   0xD570             BPL.N    ??HAL_I2C_EV_IRQHandler_62
   4674              {
   4675                I2C_Slave_STOPF(hi2c);
   \      0x46E   0x786F             LDRB     R7,[R5, #+1]
   \      0x470   0x6848             LDR      R0,[R1, #+4]
   \      0x472   0xF420 0x60E0      BIC      R0,R0,#0x700
   \      0x476   0x6048             STR      R0,[R1, #+4]
   \      0x478   0x2100             MOVS     R1,#+0
   \      0x47A   0x9100             STR      R1,[SP, #+0]
   \      0x47C   0x6820             LDR      R0,[R4, #+0]
   \      0x47E   0x6941             LDR      R1,[R0, #+20]
   \      0x480   0x9100             STR      R1,[SP, #+0]
   \      0x482   0x....'....        BL       ?Subroutine43
   4676              }
   \                     ??CrossCallReturnLabel_118: (+1)
   \      0x486   0x9800             LDR      R0,[SP, #+0]
   \      0x488   0x....'....        BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_111: (+1)
   \      0x48C   0x6821             LDR      R1,[R4, #+0]
   \      0x48E   0x6848             LDR      R0,[R1, #+4]
   \      0x490   0x0502             LSLS     R2,R0,#+20
   \      0x492   0xD528             BPL.N    ??HAL_I2C_EV_IRQHandler_63
   \      0x494   0x2F22             CMP      R7,#+34
   \      0x496   0xBF18             IT       NE
   \      0x498   0x2F2A             CMPNE    R7,#+42
   \      0x49A   0x....'....        ADR.W    R8,I2C_DMAAbort
   \      0x49E   0xD010             BEQ.N    ??HAL_I2C_EV_IRQHandler_64
   \      0x4A0   0x6B60             LDR      R0,[R4, #+52]
   \      0x4A2   0x....'....        BL       ?Subroutine48
   \                     ??CrossCallReturnLabel_134: (+1)
   \      0x4A6   0x6B60             LDR      R0,[R4, #+52]
   \      0x4A8   0x....'....        BL       HAL_DMA_GetState
   \      0x4AC   0x2801             CMP      R0,#+1
   \      0x4AE   0xD01A             BEQ.N    ??HAL_I2C_EV_IRQHandler_63
   \      0x4B0   0x6B60             LDR      R0,[R4, #+52]
   \      0x4B2   0xF8C0 0x8050      STR      R8,[R0, #+80]
   \      0x4B6   0x6B60             LDR      R0,[R4, #+52]
   \      0x4B8   0x....'....        BL       HAL_DMA_Abort_IT
   \      0x4BC   0xB198             CBZ.N    R0,??HAL_I2C_EV_IRQHandler_63
   \      0x4BE   0x6B60             LDR      R0,[R4, #+52]
   \      0x4C0   0xE00F             B.N      ??HAL_I2C_EV_IRQHandler_65
   \                     ??HAL_I2C_EV_IRQHandler_64: (+1)
   \      0x4C2   0x6BA0             LDR      R0,[R4, #+56]
   \      0x4C4   0x....'....        BL       ?Subroutine48
   \                     ??CrossCallReturnLabel_135: (+1)
   \      0x4C8   0x6BA0             LDR      R0,[R4, #+56]
   \      0x4CA   0x....'....        BL       HAL_DMA_GetState
   \      0x4CE   0x2801             CMP      R0,#+1
   \      0x4D0   0xD009             BEQ.N    ??HAL_I2C_EV_IRQHandler_63
   \      0x4D2   0x6BA0             LDR      R0,[R4, #+56]
   \      0x4D4   0xF8C0 0x8050      STR      R8,[R0, #+80]
   \      0x4D8   0x6BA0             LDR      R0,[R4, #+56]
   \      0x4DA   0x....'....        BL       HAL_DMA_Abort_IT
   \      0x4DE   0xB110             CBZ.N    R0,??HAL_I2C_EV_IRQHandler_63
   \      0x4E0   0x6BA0             LDR      R0,[R4, #+56]
   \                     ??HAL_I2C_EV_IRQHandler_65: (+1)
   \      0x4E2   0x6D01             LDR      R1,[R0, #+80]
   \      0x4E4   0x4788             BLX      R1
   \                     ??HAL_I2C_EV_IRQHandler_63: (+1)
   \      0x4E6   0x8D60             LDRH     R0,[R4, #+42]
   \      0x4E8   0xB188             CBZ.N    R0,??HAL_I2C_EV_IRQHandler_66
   \      0x4EA   0x6820             LDR      R0,[R4, #+0]
   \      0x4EC   0x6941             LDR      R1,[R0, #+20]
   \      0x4EE   0x074A             LSLS     R2,R1,#+29
   \      0x4F0   0xD501             BPL.N    ??CrossCallReturnLabel_371
   \      0x4F2   0x....'....        BL       ?Subroutine91
   \                     ??CrossCallReturnLabel_371: (+1)
   \      0x4F6   0x6820             LDR      R0,[R4, #+0]
   \      0x4F8   0x6941             LDR      R1,[R0, #+20]
   \      0x4FA   0x064A             LSLS     R2,R1,#+25
   \      0x4FC   0xD501             BPL.N    ??CrossCallReturnLabel_372
   \      0x4FE   0x....'....        BL       ?Subroutine91
   \                     ??CrossCallReturnLabel_372: (+1)
   \      0x502   0x8D60             LDRH     R0,[R4, #+42]
   \      0x504   0xB118             CBZ.N    R0,??HAL_I2C_EV_IRQHandler_66
   \      0x506   0x6868             LDR      R0,[R5, #+4]
   \      0x508   0xF040 0x0004      ORR      R0,R0,#0x4
   \      0x50C   0x6068             STR      R0,[R5, #+4]
   \                     ??HAL_I2C_EV_IRQHandler_66: (+1)
   \      0x50E   0x6868             LDR      R0,[R5, #+4]
   \      0x510   0xB118             CBZ.N    R0,??HAL_I2C_EV_IRQHandler_67
   \      0x512   0x4620             MOV      R0,R4
   \      0x514   0xE8BD 0x41F6      POP      {R1,R2,R4-R8,LR}
   \      0x518   0x....             B.N      I2C_ITError
   \                     ??HAL_I2C_EV_IRQHandler_67: (+1)
   \      0x51A   0x2F2A             CMP      R7,#+42
   \      0x51C   0xD105             BNE.N    ??HAL_I2C_EV_IRQHandler_68
   \      0x51E   0x6320             STR      R0,[R4, #+48]
   \      0x520   0x2128             MOVS     R1,#+40
   \      0x522   0x7069             STRB     R1,[R5, #+1]
   \      0x524   0x4620             MOV      R0,R4
   \      0x526   0x....'....        BL       HAL_I2C_SlaveRxCpltCallback
   \                     ??HAL_I2C_EV_IRQHandler_68: (+1)
   \      0x52A   0x7868             LDRB     R0,[R5, #+1]
   \      0x52C   0x2828             CMP      R0,#+40
   \      0x52E   0xD107             BNE.N    ??HAL_I2C_EV_IRQHandler_69
   \      0x530   0x62E6             STR      R6,[R4, #+44]
   \      0x532   0x....'....        BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_47: (+1)
   \      0x536   0x4620             MOV      R0,R4
   \      0x538   0xE8BD 0x41F6      POP      {R1,R2,R4-R8,LR}
   \      0x53C   0x....'....        B.W      HAL_I2C_ListenCpltCallback
   \                     ??HAL_I2C_EV_IRQHandler_69: (+1)
   \      0x540   0x6B20             LDR      R0,[R4, #+48]
   \      0x542   0x2822             CMP      R0,#+34
   \      0x544   0xBF18             IT       NE
   \      0x546   0x2F22             CMPNE    R7,#+34
   \      0x548   0xD162             BNE.N    ??CrossCallReturnLabel_368
   \      0x54A   0x....'....        BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_48: (+1)
   \      0x54E   0xE04D             B.N      ??HAL_I2C_EV_IRQHandler_70
   4677              /* I2C in mode Transmitter -----------------------------------------------*/
   4678              else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
   \                     ??HAL_I2C_EV_IRQHandler_62: (+1)
   \      0x550   0x2F21             CMP      R7,#+33
   \      0x552   0xBF18             IT       NE
   \      0x554   0x2F29             CMPNE    R7,#+41
   \      0x556   0xF00C 0x0004      AND      R0,R12,#0x4
   \      0x55A   0xD12D             BNE.N    ??HAL_I2C_EV_IRQHandler_71
   4679              {
   4680                /* TXE set and BTF reset -----------------------------------------------*/
   4681                if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
   \      0x55C   0xEA5F 0x630C      LSLS     R3,R12,#+24
   \      0x560   0xD51C             BPL.N    ??HAL_I2C_EV_IRQHandler_72
   \      0x562   0x0556             LSLS     R6,R2,#+21
   \      0x564   0xD51A             BPL.N    ??HAL_I2C_EV_IRQHandler_72
   \      0x566   0xB9C8             CBNZ.N   R0,??HAL_I2C_EV_IRQHandler_72
   4682                {
   4683                  I2C_SlaveTransmit_TXE(hi2c);
   \      0x568   0x786A             LDRB     R2,[R5, #+1]
   \      0x56A   0x8D60             LDRH     R0,[R4, #+42]
   \      0x56C   0x2800             CMP      R0,#+0
   \      0x56E   0xD04F             BEQ.N    ??CrossCallReturnLabel_368
   \      0x570   0x6A60             LDR      R0,[R4, #+36]
   \      0x572   0x7803             LDRB     R3,[R0, #+0]
   \      0x574   0x610B             STR      R3,[R1, #+16]
   \      0x576   0x6A60             LDR      R0,[R4, #+36]
   \      0x578   0x1C41             ADDS     R1,R0,#+1
   \      0x57A   0x6261             STR      R1,[R4, #+36]
   \      0x57C   0x....'....        BL       ?Subroutine90
   4684                }
   \                     ??CrossCallReturnLabel_271: (+1)
   \      0x580   0xBF08             IT       EQ
   \      0x582   0x2A29             CMPEQ    R2,#+41
   \      0x584   0xD144             BNE.N    ??CrossCallReturnLabel_368
   \      0x586   0x....'....        BL       ?Subroutine45
   \                     ??CrossCallReturnLabel_121: (+1)
   \      0x58A   0x2021             MOVS     R0,#+33
   \      0x58C   0x6320             STR      R0,[R4, #+48]
   \      0x58E   0x2128             MOVS     R1,#+40
   \      0x590   0x7069             STRB     R1,[R5, #+1]
   \      0x592   0x4620             MOV      R0,R4
   \      0x594   0xE8BD 0x41F6      POP      {R1,R2,R4-R8,LR}
   \      0x598   0x....'....        B.W      HAL_I2C_SlaveTxCpltCallback
   4685                /* BTF set -------------------------------------------------------------*/
   4686                else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_72: (+1)
   \      0x59C   0x2800             CMP      R0,#+0
   \      0x59E   0xD037             BEQ.N    ??CrossCallReturnLabel_368
   \      0x5A0   0x0592             LSLS     R2,R2,#+22
   \      0x5A2   0xD535             BPL.N    ??CrossCallReturnLabel_368
   4687                {
   4688                  I2C_SlaveTransmit_BTF(hi2c);
   \      0x5A4   0x8D60             LDRH     R0,[R4, #+42]
   \      0x5A6   0x2800             CMP      R0,#+0
   \      0x5A8   0xD032             BEQ.N    ??CrossCallReturnLabel_368
   \                     ??HAL_I2C_EV_IRQHandler_42: (+1)
   \      0x5AA   0x6A60             LDR      R0,[R4, #+36]
   \      0x5AC   0x7802             LDRB     R2,[R0, #+0]
   \      0x5AE   0x610A             STR      R2,[R1, #+16]
   \      0x5B0   0x6A60             LDR      R0,[R4, #+36]
   \      0x5B2   0x1C41             ADDS     R1,R0,#+1
   \      0x5B4   0x6261             STR      R1,[R4, #+36]
   \      0x5B6   0xE029             B.N      ??HAL_I2C_EV_IRQHandler_73
   4689                }
   4690                else
   4691                {
   4692                  /* Do nothing */
   4693                }
   4694              }
   4695              /* I2C in mode Receiver --------------------------------------------------*/
   4696              else
   4697              {
   4698                /* RXNE set and BTF reset ----------------------------------------------*/
   4699                if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
   \                     ??HAL_I2C_EV_IRQHandler_71: (+1)
   \      0x5B8   0xEA5F 0x634C      LSLS     R3,R12,#+25
   \      0x5BC   0xD51B             BPL.N    ??HAL_I2C_EV_IRQHandler_74
   \      0x5BE   0x0556             LSLS     R6,R2,#+21
   \      0x5C0   0xD519             BPL.N    ??HAL_I2C_EV_IRQHandler_74
   \      0x5C2   0xB9C0             CBNZ.N   R0,??HAL_I2C_EV_IRQHandler_74
   4700                {
   4701                  I2C_SlaveReceive_RXNE(hi2c);
   \      0x5C4   0x786A             LDRB     R2,[R5, #+1]
   \      0x5C6   0x8D60             LDRH     R0,[R4, #+42]
   \      0x5C8   0xB310             CBZ.N    R0,??CrossCallReturnLabel_368
   \      0x5CA   0x6908             LDR      R0,[R1, #+16]
   \      0x5CC   0x6A61             LDR      R1,[R4, #+36]
   \      0x5CE   0x7008             STRB     R0,[R1, #+0]
   \      0x5D0   0x6A60             LDR      R0,[R4, #+36]
   \      0x5D2   0x1C43             ADDS     R3,R0,#+1
   \      0x5D4   0x6263             STR      R3,[R4, #+36]
   \      0x5D6   0x....'....        BL       ?Subroutine90
   4702                }
   \                     ??CrossCallReturnLabel_272: (+1)
   \      0x5DA   0xBF08             IT       EQ
   \      0x5DC   0x2A2A             CMPEQ    R2,#+42
   \      0x5DE   0xD117             BNE.N    ??CrossCallReturnLabel_368
   \      0x5E0   0x....'....        BL       ?Subroutine45
   \                     ??CrossCallReturnLabel_122: (+1)
   \      0x5E4   0x2022             MOVS     R0,#+34
   \      0x5E6   0x6320             STR      R0,[R4, #+48]
   \      0x5E8   0x2128             MOVS     R1,#+40
   \      0x5EA   0x7069             STRB     R1,[R5, #+1]
   \                     ??HAL_I2C_EV_IRQHandler_70: (+1)
   \      0x5EC   0x4620             MOV      R0,R4
   \      0x5EE   0xE8BD 0x41F6      POP      {R1,R2,R4-R8,LR}
   \      0x5F2   0x....'....        B.W      HAL_I2C_SlaveRxCpltCallback
   4703                /* BTF set -------------------------------------------------------------*/
   4704                else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_74: (+1)
   \      0x5F6   0xB158             CBZ.N    R0,??CrossCallReturnLabel_368
   \      0x5F8   0x0592             LSLS     R2,R2,#+22
   \      0x5FA   0xD509             BPL.N    ??CrossCallReturnLabel_368
   4705                {
   4706                  I2C_SlaveReceive_BTF(hi2c);
   \      0x5FC   0x8D60             LDRH     R0,[R4, #+42]
   \      0x5FE   0xB138             CBZ.N    R0,??CrossCallReturnLabel_368
   \                     ??HAL_I2C_EV_IRQHandler_53: (+1)
   \      0x600   0x6908             LDR      R0,[R1, #+16]
   \      0x602   0x6A61             LDR      R1,[R4, #+36]
   \      0x604   0x7008             STRB     R0,[R1, #+0]
   \      0x606   0x6A60             LDR      R0,[R4, #+36]
   \      0x608   0x1C42             ADDS     R2,R0,#+1
   \                     ??HAL_I2C_EV_IRQHandler_55: (+1)
   \      0x60A   0x6262             STR      R2,[R4, #+36]
   4707                }
   4708                else
   4709                {
   4710                  /* Do nothing */
   4711                }
   4712              }
   4713            }
   \                     ??HAL_I2C_EV_IRQHandler_73: (+1)
   \      0x60C   0x....'....        BL       ??Subroutine127_0
   4714          }
   \                     ??CrossCallReturnLabel_368: (+1)
   \      0x610   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine125: (+1)
   \        0x0   0x4608             MOV      R0,R1
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF421 0x6180      BIC      R1,R1,#0x400
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine124: (+1)
   \        0x0   0x6848             LDR      R0,[R1, #+4]
   \        0x2   0xF420 0x60E0      BIC      R0,R0,#0x700
   \        0x6   0x6048             STR      R0,[R1, #+4]
   \        0x8   0x2111             MOVS     R1,#+17
   \        0xA   0x6321             STR      R1,[R4, #+48]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine123: (+1)
   \        0x0   0x68A8             LDR      R0,[R5, #+8]
   \        0x2   0x0400             LSLS     R0,R0,#+16
   \        0x4   0x0DC0             LSRS     R0,R0,#+23
   \        0x6   0xF000 0x0006      AND      R0,R0,#0x6
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine92: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x9200             STR      R2,[SP, #+0]
   \        0x4   0x694B             LDR      R3,[R1, #+20]
   \        0x6   0x9300             STR      R3,[SP, #+0]
   \        0x8   0x6989             LDR      R1,[R1, #+24]
   \        0xA   0x9100             STR      R1,[SP, #+0]
   \        0xC   0x9A00             LDR      R2,[SP, #+0]
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x6808             LDR      R0,[R1, #+0]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine91: (+1)
   \        0x0   0x6900             LDR      R0,[R0, #+16]
   \                     ??Subroutine91_0: (+1)
   \        0x2   0x6A61             LDR      R1,[R4, #+36]
   \        0x4   0x7008             STRB     R0,[R1, #+0]
   \        0x6   0x6A60             LDR      R0,[R4, #+36]
   \        0x8   0x1C42             ADDS     R2,R0,#+1
   \        0xA   0x6262             STR      R2,[R4, #+36]
   \        0xC                      REQUIRE ??Subroutine127_0
   \        0xC                      ;; // Fall through to label ??Subroutine127_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine127_0: (+1)
   \        0x0   0x8D60             LDRH     R0,[R4, #+42]
   \        0x2   0x1E41             SUBS     R1,R0,#+1
   \        0x4   0x8561             STRH     R1,[R4, #+42]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine90: (+1)
   \        0x0   0x8D60             LDRH     R0,[R4, #+42]
   \        0x2   0x1E41             SUBS     R1,R0,#+1
   \        0x4   0x8561             STRH     R1,[R4, #+42]
   \        0x6   0x8D60             LDRH     R0,[R4, #+42]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine48: (+1)
   \        0x0   0x6802             LDR      R2,[R0, #+0]
   \        0x2   0x6853             LDR      R3,[R2, #+4]
   \        0x4   0x8563             STRH     R3,[R4, #+42]
   \        0x6   0x8D60             LDRH     R0,[R4, #+42]
   \        0x8   0xB118             CBZ.N    R0,??Subroutine48_0
   \        0xA   0x6868             LDR      R0,[R5, #+4]
   \        0xC   0xF040 0x0004      ORR      R0,R0,#0x4
   \       0x10   0x6068             STR      R0,[R5, #+4]
   \                     ??Subroutine48_0: (+1)
   \       0x12   0x6848             LDR      R0,[R1, #+4]
   \       0x14   0xF420 0x6000      BIC      R0,R0,#0x800
   \       0x18   0x6048             STR      R0,[R1, #+4]
   \       0x1A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine45: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0xF421 0x6180      BIC      R1,R1,#0x400
   \        0x8   0x6041             STR      R1,[R0, #+4]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine39: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF421 0x6180      BIC      R1,R1,#0x400
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine37: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6901             LDR      R1,[R0, #+16]
   \        0x4   0x6A60             LDR      R0,[R4, #+36]
   \        0x6   0x7001             STRB     R1,[R0, #+0]
   \        0x8   0x6A61             LDR      R1,[R4, #+36]
   \        0xA   0x1C4A             ADDS     R2,R1,#+1
   \        0xC   0x6262             STR      R2,[R4, #+36]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine23: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x6320             STR      R0,[R4, #+48]
   \        0x4   0x2120             MOVS     R1,#+32
   \        0x6   0x7069             STRB     R1,[R5, #+1]
   \        0x8   0x70A8             STRB     R0,[R5, #+2]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21: (+1)
   \        0x0   0x6848             LDR      R0,[R1, #+4]
   \        0x2   0xF420 0x60E0      BIC      R0,R0,#0x700
   \        0x6   0x6048             STR      R0,[R1, #+4]
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF441 0x7100      ORR      R1,R1,#0x200
   \       0x10   0x6001             STR      R1,[R0, #+0]
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6320             STR      R0,[R4, #+48]
   \       0x16   0x2120             MOVS     R1,#+32
   \       0x18   0x7069             STRB     R1,[R5, #+1]
   \       0x1A   0x78A8             LDRB     R0,[R5, #+2]
   \       0x1C   0x2840             CMP      R0,#+64
   \       0x1E   0x4770             BX       LR
   4715          
   4716          /**
   4717            * @brief  This function handles I2C error interrupt request.
   4718            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4719            *                the configuration information for the specified I2C.
   4720            * @retval None
   4721            */

   \                                 In section .text, align 2, keep-with-next
   4722          void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
   4723          {
   \                     HAL_I2C_ER_IRQHandler: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   4724            HAL_I2C_ModeTypeDef tmp1;
   4725            uint32_t tmp2;
   4726            HAL_I2C_StateTypeDef tmp3;
   4727            uint32_t tmp4;
   4728            uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
   4729            uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
   4730            uint32_t error      = HAL_I2C_ERROR_NONE;
   4731            HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
   \        0x4   0xF105 0x003D      ADD      R0,R5,#+61
   \        0x8   0x6829             LDR      R1,[R5, #+0]
   \        0xA   0x694E             LDR      R6,[R1, #+20]
   \        0xC   0x684F             LDR      R7,[R1, #+4]
   \        0xE   0x7842             LDRB     R2,[R0, #+1]
   \       0x10   0x2400             MOVS     R4,#+0
   4732          
   4733            /* I2C Bus error interrupt occurred ----------------------------------------*/
   4734            if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
   \       0x12   0x05F3             LSLS     R3,R6,#+23
   \       0x14   0xD505             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   \       0x16   0x05FB             LSLS     R3,R7,#+23
   \       0x18   0xD503             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   4735            {
   4736              error |= HAL_I2C_ERROR_BERR;
   4737          
   4738              /* Clear BERR flag */
   4739              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
   \       0x1A   0xF46F 0x7380      MVN      R3,#+256
   \       0x1E   0x2401             MOVS     R4,#+1
   \       0x20   0x614B             STR      R3,[R1, #+20]
   4740            }
   4741          
   4742            /* I2C Arbitration Lost error interrupt occurred ---------------------------*/
   4743            if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_0: (+1)
   \       0x22   0x05B1             LSLS     R1,R6,#+22
   \       0x24   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   \       0x26   0x05FB             LSLS     R3,R7,#+23
   \       0x28   0xD505             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   4744            {
   4745              error |= HAL_I2C_ERROR_ARLO;
   4746          
   4747              /* Clear ARLO flag */
   4748              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
   \       0x2A   0x682B             LDR      R3,[R5, #+0]
   \       0x2C   0xF46F 0x7100      MVN      R1,#+512
   \       0x30   0xF044 0x0402      ORR      R4,R4,#0x2
   \       0x34   0x6159             STR      R1,[R3, #+20]
   4749            }
   4750          
   4751            /* I2C Acknowledge failure error interrupt occurred ------------------------*/
   4752            if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_1: (+1)
   \       0x36   0x0571             LSLS     R1,R6,#+21
   \       0x38   0xD55D             BPL.N    ??CrossCallReturnLabel_152
   \       0x3A   0x05FB             LSLS     R3,R7,#+23
   \       0x3C   0xD55B             BPL.N    ??CrossCallReturnLabel_152
   4753            {
   4754              tmp1 = CurrentMode;
   4755              tmp2 = hi2c->XferCount;
   \       0x3E   0x8D6B             LDRH     R3,[R5, #+42]
   4756              tmp3 = hi2c->State;
   \       0x40   0xF890 0xC000      LDRB     R12,[R0, #+0]
   4757              tmp4 = hi2c->PreviousState;
   \       0x44   0xF8D5 0xE030      LDR      LR,[R5, #+48]
   4758              if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
   4759                  ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
   4760                   ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
   \       0x48   0x2A20             CMP      R2,#+32
   \       0x4A   0xBF08             IT       EQ
   \       0x4C   0x2B00             CMPEQ    R3,#+0
   \       0x4E   0xF46F 0x6180      MVN      R1,#+1024
   \       0x52   0xD145             BNE.N    ??HAL_I2C_ER_IRQHandler_2
   \       0x54   0xF1BC 0x0F21      CMP      R12,#+33
   \       0x58   0xBF18             IT       NE
   \       0x5A   0xF1BC 0x0F29      CMPNE    R12,#+41
   \       0x5E   0xD005             BEQ.N    ??HAL_I2C_ER_IRQHandler_3
   \       0x60   0xF1BC 0x0F28      CMP      R12,#+40
   \       0x64   0xBF08             IT       EQ
   \       0x66   0xF1BE 0x0F21      CMPEQ    LR,#+33
   \       0x6A   0xD139             BNE.N    ??HAL_I2C_ER_IRQHandler_2
   4761              {
   4762                I2C_Slave_AF(hi2c);
   \                     ??HAL_I2C_ER_IRQHandler_3: (+1)
   \       0x6C   0x7802             LDRB     R2,[R0, #+0]
   \       0x6E   0x6AEB             LDR      R3,[R5, #+44]
   \       0x70   0x....'....        LDR.W    R12,??DataTable35  ;; 0xffff0000
   \       0x74   0x2B08             CMP      R3,#+8
   \       0x76   0xBF14             ITE      NE
   \       0x78   0x2B20             CMPNE    R3,#+32
   \       0x7A   0x2A28             CMPEQ    R2,#+40
   \       0x7C   0xD116             BNE.N    ??HAL_I2C_ER_IRQHandler_4
   \       0x7E   0xF8C5 0xC02C      STR      R12,[R5, #+44]
   \       0x82   0x682A             LDR      R2,[R5, #+0]
   \       0x84   0x6853             LDR      R3,[R2, #+4]
   \       0x86   0xF423 0x63E0      BIC      R3,R3,#0x700
   \       0x8A   0x6053             STR      R3,[R2, #+4]
   \       0x8C   0x682A             LDR      R2,[R5, #+0]
   \       0x8E   0x6151             STR      R1,[R2, #+20]
   \       0x90   0x2220             MOVS     R2,#+32
   \       0x92   0x6829             LDR      R1,[R5, #+0]
   \       0x94   0x680B             LDR      R3,[R1, #+0]
   \       0x96   0xF423 0x6380      BIC      R3,R3,#0x400
   \       0x9A   0x600B             STR      R3,[R1, #+0]
   \       0x9C   0x2100             MOVS     R1,#+0
   \       0x9E   0x6329             STR      R1,[R5, #+48]
   \       0xA0   0x7002             STRB     R2,[R0, #+0]
   \       0xA2   0x7041             STRB     R1,[R0, #+1]
   \       0xA4   0x4628             MOV      R0,R5
   \       0xA6   0x....'....        BL       HAL_I2C_ListenCpltCallback
   \       0xAA   0xE024             B.N      ??CrossCallReturnLabel_152
   \                     ??HAL_I2C_ER_IRQHandler_4: (+1)
   \       0xAC   0x2A21             CMP      R2,#+33
   \       0xAE   0xD114             BNE.N    ??HAL_I2C_ER_IRQHandler_5
   \       0xB0   0xF8C5 0xC02C      STR      R12,[R5, #+44]
   \       0xB4   0x632A             STR      R2,[R5, #+48]
   \       0xB6   0x2320             MOVS     R3,#+32
   \       0xB8   0x7003             STRB     R3,[R0, #+0]
   \       0xBA   0x2200             MOVS     R2,#+0
   \       0xBC   0x7042             STRB     R2,[R0, #+1]
   \       0xBE   0x6828             LDR      R0,[R5, #+0]
   \       0xC0   0x6842             LDR      R2,[R0, #+4]
   \       0xC2   0xF422 0x62E0      BIC      R2,R2,#0x700
   \       0xC6   0x6042             STR      R2,[R0, #+4]
   \       0xC8   0x6828             LDR      R0,[R5, #+0]
   \       0xCA   0x6141             STR      R1,[R0, #+20]
   \       0xCC   0x6828             LDR      R0,[R5, #+0]
   \       0xCE   0x....'....        BL       ??Subroutine60_0
   4763              }
   \                     ??CrossCallReturnLabel_176: (+1)
   \       0xD2   0x4628             MOV      R0,R5
   \       0xD4   0x....'....        BL       HAL_I2C_SlaveTxCpltCallback
   \       0xD8   0xE00D             B.N      ??CrossCallReturnLabel_152
   \                     ??HAL_I2C_ER_IRQHandler_5: (+1)
   \       0xDA   0x6828             LDR      R0,[R5, #+0]
   \       0xDC   0x6141             STR      R1,[R0, #+20]
   \       0xDE   0xE00A             B.N      ??CrossCallReturnLabel_152
   4764              else
   4765              {
   4766                /* Clear AF flag */
   4767                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_ER_IRQHandler_2: (+1)
   \       0xE0   0x682B             LDR      R3,[R5, #+0]
   4768          
   4769                error |= HAL_I2C_ERROR_AF;
   4770          
   4771                /* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */
   4772                if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
   \       0xE2   0x2A10             CMP      R2,#+16
   \       0xE4   0xBF18             IT       NE
   \       0xE6   0x2A40             CMPNE    R2,#+64
   \       0xE8   0x6159             STR      R1,[R3, #+20]
   \       0xEA   0xF044 0x0404      ORR      R4,R4,#0x4
   \       0xEE   0xD102             BNE.N    ??CrossCallReturnLabel_152
   4773                {
   4774                  /* Generate Stop */
   4775                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xF0   0x6828             LDR      R0,[R5, #+0]
   \       0xF2   0x....'....        BL       ??Subroutine53_0
   4776                }
   4777              }
   4778            }
   4779          
   4780            /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
   4781            if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
   \                     ??CrossCallReturnLabel_152: (+1)
   \       0xF6   0x0530             LSLS     R0,R6,#+20
   \       0xF8   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_6
   \       0xFA   0x05F9             LSLS     R1,R7,#+23
   \       0xFC   0xD505             BPL.N    ??HAL_I2C_ER_IRQHandler_6
   4782            {
   4783              error |= HAL_I2C_ERROR_OVR;
   4784              /* Clear OVR flag */
   4785              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
   \       0xFE   0x6829             LDR      R1,[R5, #+0]
   \      0x100   0xF46F 0x6000      MVN      R0,#+2048
   \      0x104   0xF044 0x0408      ORR      R4,R4,#0x8
   \      0x108   0x6148             STR      R0,[R1, #+20]
   4786            }
   4787          
   4788            /* Call the Error Callback in case of Error detected -----------------------*/
   4789            if (error != HAL_I2C_ERROR_NONE)
   \                     ??HAL_I2C_ER_IRQHandler_6: (+1)
   \      0x10A   0xB134             CBZ.N    R4,??HAL_I2C_ER_IRQHandler_7
   4790            {
   4791              hi2c->ErrorCode |= error;
   \      0x10C   0x6C28             LDR      R0,[R5, #+64]
   \      0x10E   0x4304             ORRS     R4,R4,R0
   \      0x110   0x642C             STR      R4,[R5, #+64]
   4792              I2C_ITError(hi2c);
   \      0x112   0x4628             MOV      R0,R5
   \      0x114   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \      0x118   0x....             B.N      I2C_ITError
   4793            }
   4794          }
   \                     ??HAL_I2C_ER_IRQHandler_7: (+1)
   \      0x11A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   4795          
   4796          /**
   4797            * @brief  Master Tx Transfer completed callback.
   4798            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4799            *                the configuration information for the specified I2C.
   4800            * @retval None
   4801            */

   \                                 In section .text, align 2
   4802          __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4803          {
   4804            /* Prevent unused argument(s) compilation warning */
   4805            UNUSED(hi2c);
   4806          
   4807            /* NOTE : This function should not be modified, when the callback is needed,
   4808                      the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   4809             */
   4810          }
   \                     HAL_I2C_MasterTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4811          
   4812          /**
   4813            * @brief  Master Rx Transfer completed callback.
   4814            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4815            *                the configuration information for the specified I2C.
   4816            * @retval None
   4817            */

   \                                 In section .text, align 2
   4818          __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4819          {
   4820            /* Prevent unused argument(s) compilation warning */
   4821            UNUSED(hi2c);
   4822          
   4823            /* NOTE : This function should not be modified, when the callback is needed,
   4824                      the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   4825             */
   4826          }
   \                     HAL_I2C_MasterRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4827          
   4828          /** @brief  Slave Tx Transfer completed callback.
   4829            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4830            *                the configuration information for the specified I2C.
   4831            * @retval None
   4832            */

   \                                 In section .text, align 2
   4833          __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4834          {
   4835            /* Prevent unused argument(s) compilation warning */
   4836            UNUSED(hi2c);
   4837          
   4838            /* NOTE : This function should not be modified, when the callback is needed,
   4839                      the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   4840             */
   4841          }
   \                     HAL_I2C_SlaveTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4842          
   4843          /**
   4844            * @brief  Slave Rx Transfer completed callback.
   4845            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4846            *                the configuration information for the specified I2C.
   4847            * @retval None
   4848            */

   \                                 In section .text, align 2
   4849          __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4850          {
   4851            /* Prevent unused argument(s) compilation warning */
   4852            UNUSED(hi2c);
   4853          
   4854            /* NOTE : This function should not be modified, when the callback is needed,
   4855                      the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   4856             */
   4857          }
   \                     HAL_I2C_SlaveRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4858          
   4859          /**
   4860            * @brief  Slave Address Match callback.
   4861            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4862            *                the configuration information for the specified I2C.
   4863            * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XferDirection_definition
   4864            * @param  AddrMatchCode Address Match Code
   4865            * @retval None
   4866            */

   \                                 In section .text, align 2
   4867          __weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
   4868          {
   4869            /* Prevent unused argument(s) compilation warning */
   4870            UNUSED(hi2c);
   4871            UNUSED(TransferDirection);
   4872            UNUSED(AddrMatchCode);
   4873          
   4874            /* NOTE : This function should not be modified, when the callback is needed,
   4875                      the HAL_I2C_AddrCallback() could be implemented in the user file
   4876             */
   4877          }
   \                     HAL_I2C_AddrCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4878          
   4879          /**
   4880            * @brief  Listen Complete callback.
   4881            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4882            *                the configuration information for the specified I2C.
   4883            * @retval None
   4884            */

   \                                 In section .text, align 2
   4885          __weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
   4886          {
   4887            /* Prevent unused argument(s) compilation warning */
   4888            UNUSED(hi2c);
   4889          
   4890            /* NOTE : This function should not be modified, when the callback is needed,
   4891                      the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   4892            */
   4893          }
   \                     HAL_I2C_ListenCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4894          
   4895          /**
   4896            * @brief  Memory Tx Transfer completed callback.
   4897            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4898            *                the configuration information for the specified I2C.
   4899            * @retval None
   4900            */

   \                                 In section .text, align 2
   4901          __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4902          {
   4903            /* Prevent unused argument(s) compilation warning */
   4904            UNUSED(hi2c);
   4905          
   4906            /* NOTE : This function should not be modified, when the callback is needed,
   4907                      the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   4908             */
   4909          }
   \                     HAL_I2C_MemTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4910          
   4911          /**
   4912            * @brief  Memory Rx Transfer completed callback.
   4913            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4914            *                the configuration information for the specified I2C.
   4915            * @retval None
   4916            */

   \                                 In section .text, align 2
   4917          __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4918          {
   4919            /* Prevent unused argument(s) compilation warning */
   4920            UNUSED(hi2c);
   4921          
   4922            /* NOTE : This function should not be modified, when the callback is needed,
   4923                      the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   4924             */
   4925          }
   \                     HAL_I2C_MemRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4926          
   4927          /**
   4928            * @brief  I2C error callback.
   4929            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4930            *                the configuration information for the specified I2C.
   4931            * @retval None
   4932            */

   \                                 In section .text, align 2
   4933          __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
   4934          {
   4935            /* Prevent unused argument(s) compilation warning */
   4936            UNUSED(hi2c);
   4937          
   4938            /* NOTE : This function should not be modified, when the callback is needed,
   4939                      the HAL_I2C_ErrorCallback could be implemented in the user file
   4940             */
   4941          }
   \                     HAL_I2C_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4942          
   4943          /**
   4944            * @brief  I2C abort callback.
   4945            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4946            *                the configuration information for the specified I2C.
   4947            * @retval None
   4948            */

   \                                 In section .text, align 2
   4949          __weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
   4950          {
   4951            /* Prevent unused argument(s) compilation warning */
   4952            UNUSED(hi2c);
   4953          
   4954            /* NOTE : This function should not be modified, when the callback is needed,
   4955                      the HAL_I2C_AbortCpltCallback could be implemented in the user file
   4956             */
   4957          }
   \                     HAL_I2C_AbortCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4958          
   4959          /**
   4960            * @}
   4961            */
   4962          
   4963          /** @defgroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
   4964           *  @brief   Peripheral State, Mode and Error functions
   4965            *
   4966          @verbatim
   4967           ===============================================================================
   4968                      ##### Peripheral State, Mode and Error functions #####
   4969           ===============================================================================
   4970              [..]
   4971              This subsection permit to get in run-time the status of the peripheral
   4972              and the data flow.
   4973          
   4974          @endverbatim
   4975            * @{
   4976            */
   4977          
   4978          /**
   4979            * @brief  Return the I2C handle state.
   4980            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4981            *                the configuration information for the specified I2C.
   4982            * @retval HAL state
   4983            */

   \                                 In section .text, align 2, keep-with-next
   4984          HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
   4985          {
   4986            /* Return I2C handle state */
   4987            return hi2c->State;
   \                     HAL_I2C_GetState: (+1)
   \        0x0   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \        0x4   0x4770             BX       LR               ;; return
   4988          }
   4989          
   4990          /**
   4991            * @brief  Returns the I2C Master, Slave, Memory or no mode.
   4992            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4993            *         the configuration information for I2C module
   4994            * @retval HAL mode
   4995            */

   \                                 In section .text, align 2, keep-with-next
   4996          HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
   4997          {
   4998            return hi2c->Mode;
   \                     HAL_I2C_GetMode: (+1)
   \        0x0   0xF890 0x003E      LDRB     R0,[R0, #+62]
   \        0x4   0x4770             BX       LR               ;; return
   4999          }
   5000          
   5001          /**
   5002            * @brief  Return the I2C error code.
   5003            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5004            *              the configuration information for the specified I2C.
   5005            * @retval I2C Error Code
   5006            */

   \                                 In section .text, align 2, keep-with-next
   5007          uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
   5008          {
   5009            return hi2c->ErrorCode;
   \                     HAL_I2C_GetError: (+1)
   \        0x0   0x6C00             LDR      R0,[R0, #+64]
   \        0x2   0x4770             BX       LR               ;; return
   5010          }
   5011          
   5012          /**
   5013            * @}
   5014            */
   5015          
   5016          /**
   5017            * @}
   5018            */
   5019          
   5020          /** @addtogroup I2C_Private_Functions
   5021            * @{
   5022            */
   5023          
   5024          /**
   5025            * @brief  Handle TXE flag for Master
   5026            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5027            *         the configuration information for I2C module
   5028            * @retval None
   5029            */
   5030          static void I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
   5031          {
   5032            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   5033            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   5034            HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
   5035            uint32_t CurrentXferOptions       = hi2c->XferOptions;
   5036          
   5037            if ((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
   5038            {
   5039              /* Call TxCpltCallback() directly if no stop mode is set */
   5040              if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
   5041              {
   5042                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   5043          
   5044                hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
   5045                hi2c->Mode = HAL_I2C_MODE_NONE;
   5046                hi2c->State = HAL_I2C_STATE_READY;
   5047          
   5048          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5049                hi2c->MasterTxCpltCallback(hi2c);
   5050          #else
   5051                HAL_I2C_MasterTxCpltCallback(hi2c);
   5052          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5053              }
   5054              else /* Generate Stop condition then Call TxCpltCallback() */
   5055              {
   5056                /* Disable EVT, BUF and ERR interrupt */
   5057                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   5058          
   5059                /* Generate Stop */
   5060                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   5061          
   5062                hi2c->PreviousState = I2C_STATE_NONE;
   5063                hi2c->State = HAL_I2C_STATE_READY;
   5064          
   5065                if (hi2c->Mode == HAL_I2C_MODE_MEM)
   5066                {
   5067                  hi2c->Mode = HAL_I2C_MODE_NONE;
   5068          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5069                  hi2c->MemTxCpltCallback(hi2c);
   5070          #else
   5071                  HAL_I2C_MemTxCpltCallback(hi2c);
   5072          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5073                }
   5074                else
   5075                {
   5076                  hi2c->Mode = HAL_I2C_MODE_NONE;
   5077          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5078                  hi2c->MasterTxCpltCallback(hi2c);
   5079          #else
   5080                  HAL_I2C_MasterTxCpltCallback(hi2c);
   5081          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5082                }
   5083              }
   5084            }
   5085            else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
   5086                     ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
   5087            {
   5088              if (hi2c->XferCount == 0U)
   5089              {
   5090                /* Disable BUF interrupt */
   5091                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   5092              }
   5093              else
   5094              {
   5095                if (hi2c->Mode == HAL_I2C_MODE_MEM)
   5096                {
   5097                  I2C_MemoryTransmit_TXE_BTF(hi2c);
   5098                }
   5099                else
   5100                {
   5101                  /* Write data to DR */
   5102                  hi2c->Instance->DR = *hi2c->pBuffPtr;
   5103          
   5104                  /* Increment Buffer pointer */
   5105                  hi2c->pBuffPtr++;
   5106          
   5107                  /* Update counter */
   5108                  hi2c->XferCount--;
   5109                }
   5110              }
   5111            }
   5112            else
   5113            {
   5114              /* Do nothing */
   5115            }
   5116          }
   5117          
   5118          /**
   5119            * @brief  Handle BTF flag for Master transmitter
   5120            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5121            *         the configuration information for I2C module
   5122            * @retval None
   5123            */
   5124          static void I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
   5125          {
   5126            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   5127            uint32_t CurrentXferOptions = hi2c->XferOptions;
   5128          
   5129            if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
   5130            {
   5131              if (hi2c->XferCount != 0U)
   5132              {
   5133                /* Write data to DR */
   5134                hi2c->Instance->DR = *hi2c->pBuffPtr;
   5135          
   5136                /* Increment Buffer pointer */
   5137                hi2c->pBuffPtr++;
   5138          
   5139                /* Update counter */
   5140                hi2c->XferCount--;
   5141              }
   5142              else
   5143              {
   5144                /* Call TxCpltCallback() directly if no stop mode is set */
   5145                if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
   5146                {
   5147                  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   5148          
   5149                  hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
   5150                  hi2c->Mode = HAL_I2C_MODE_NONE;
   5151                  hi2c->State = HAL_I2C_STATE_READY;
   5152          
   5153          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5154                  hi2c->MasterTxCpltCallback(hi2c);
   5155          #else
   5156                  HAL_I2C_MasterTxCpltCallback(hi2c);
   5157          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5158                }
   5159                else /* Generate Stop condition then Call TxCpltCallback() */
   5160                {
   5161                  /* Disable EVT, BUF and ERR interrupt */
   5162                  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   5163          
   5164                  /* Generate Stop */
   5165                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   5166          
   5167                  hi2c->PreviousState = I2C_STATE_NONE;
   5168                  hi2c->State = HAL_I2C_STATE_READY;
   5169          
   5170                  if (hi2c->Mode == HAL_I2C_MODE_MEM)
   5171                  {
   5172                    hi2c->Mode = HAL_I2C_MODE_NONE;
   5173          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5174                    hi2c->MemTxCpltCallback(hi2c);
   5175          #else
   5176                    HAL_I2C_MemTxCpltCallback(hi2c);
   5177          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5178                  }
   5179                  else
   5180                  {
   5181                    hi2c->Mode = HAL_I2C_MODE_NONE;
   5182          
   5183          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5184                    hi2c->MasterTxCpltCallback(hi2c);
   5185          #else
   5186                    HAL_I2C_MasterTxCpltCallback(hi2c);
   5187          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5188                  }
   5189                }
   5190              }
   5191            }
   5192            else if (hi2c->Mode == HAL_I2C_MODE_MEM)
   5193            {
   5194              I2C_MemoryTransmit_TXE_BTF(hi2c);
   5195            }
   5196            else
   5197            {
   5198              /* Do nothing */
   5199            }
   5200          }
   5201          
   5202          /**
   5203            * @brief  Handle TXE and BTF flag for Memory transmitter
   5204            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5205            *         the configuration information for I2C module
   5206            * @retval None
   5207            */

   \                                 In section .text, align 2, keep-with-next
   5208          static void I2C_MemoryTransmit_TXE_BTF(I2C_HandleTypeDef *hi2c)
   5209          {
   5210            if (hi2c->EventCount == 0U)
   \                     I2C_MemoryTransmit_TXE_BTF: (+1)
   \        0x0   0xF100 0x0248      ADD      R2,R0,#+72
   \        0x4   0x6891             LDR      R1,[R2, #+8]
   \        0x6   0xB989             CBNZ.N   R1,??I2C_MemoryTransmit_TXE_BTF_0
   5211            {
   5212              /* If Memory address size is 8Bit */
   5213              if (hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x6851             LDR      R1,[R2, #+4]
   \        0xC   0x2901             CMP      R1,#+1
   \        0xE   0xD105             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_1
   5214              {
   5215                /* Send Memory Address */
   5216                hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
   \       0x10   0x6813             LDR      R3,[R2, #+0]
   \       0x12   0xB2DB             UXTB     R3,R3
   \       0x14   0x6103             STR      R3,[R0, #+16]
   5217          
   5218                hi2c->EventCount += 2U;
   \       0x16   0x6890             LDR      R0,[R2, #+8]
   \       0x18   0x1C80             ADDS     R0,R0,#+2
   \       0x1A   0xE005             B.N      ??I2C_MemoryTransmit_TXE_BTF_2
   5219              }
   5220              /* If Memory address size is 16Bit */
   5221              else
   5222              {
   5223                /* Send MSB of Memory Address */
   5224                hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
   \                     ??I2C_MemoryTransmit_TXE_BTF_1: (+1)
   \       0x1C   0x6811             LDR      R1,[R2, #+0]
   \       0x1E   0x0409             LSLS     R1,R1,#+16
   \       0x20   0x0E09             LSRS     R1,R1,#+24
   \       0x22   0x6101             STR      R1,[R0, #+16]
   5225          
   5226                hi2c->EventCount++;
   \       0x24   0x6890             LDR      R0,[R2, #+8]
   \       0x26   0x1C40             ADDS     R0,R0,#+1
   \                     ??I2C_MemoryTransmit_TXE_BTF_2: (+1)
   \       0x28   0x6090             STR      R0,[R2, #+8]
   \       0x2A   0x4770             BX       LR
   5227              }
   5228            }
   5229            else if (hi2c->EventCount == 1U)
   \                     ??I2C_MemoryTransmit_TXE_BTF_0: (+1)
   \       0x2C   0x6891             LDR      R1,[R2, #+8]
   \       0x2E   0x2901             CMP      R1,#+1
   \       0x30   0xD107             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_3
   5230            {
   5231              /* Send LSB of Memory Address */
   5232              hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
   \       0x32   0x6813             LDR      R3,[R2, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0xB2DB             UXTB     R3,R3
   \       0x38   0x6103             STR      R3,[R0, #+16]
   5233          
   5234              hi2c->EventCount++;
   \       0x3A   0x6891             LDR      R1,[R2, #+8]
   \       0x3C   0x1C49             ADDS     R1,R1,#+1
   \       0x3E   0x6091             STR      R1,[R2, #+8]
   \       0x40   0x4770             BX       LR
   5235            }
   5236            else if (hi2c->EventCount == 2U)
   \                     ??I2C_MemoryTransmit_TXE_BTF_3: (+1)
   \       0x42   0x6891             LDR      R1,[R2, #+8]
   \       0x44   0x2902             CMP      R1,#+2
   \       0x46   0xD117             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_4
   5237            {
   5238              if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \       0x48   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \       0x4C   0x2922             CMP      R1,#+34
   \       0x4E   0xD105             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_5
   5239              {
   5240                /* Generate Restart */
   5241                hi2c->Instance->CR1 |= I2C_CR1_START;
   \       0x50   0x6802             LDR      R2,[R0, #+0]
   \       0x52   0x6811             LDR      R1,[R2, #+0]
   \       0x54   0xF441 0x7180      ORR      R1,R1,#0x100
   \       0x58   0x6011             STR      R1,[R2, #+0]
   \       0x5A   0x4770             BX       LR
   5242              }
   5243              else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
   \                     ??I2C_MemoryTransmit_TXE_BTF_5: (+1)
   \       0x5C   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \       0x60   0x2921             CMP      R1,#+33
   \       0x62   0xD109             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_4
   5244              {
   5245                /* Write data to DR */
   5246                hi2c->Instance->DR = *hi2c->pBuffPtr;
   \       0x64   0x6A41             LDR      R1,[R0, #+36]
   \       0x66   0x6803             LDR      R3,[R0, #+0]
   \       0x68   0x780A             LDRB     R2,[R1, #+0]
   \       0x6A   0x611A             STR      R2,[R3, #+16]
   5247          
   5248                /* Increment Buffer pointer */
   5249                hi2c->pBuffPtr++;
   \       0x6C   0x6A41             LDR      R1,[R0, #+36]
   \       0x6E   0x1C4A             ADDS     R2,R1,#+1
   \       0x70   0x6242             STR      R2,[R0, #+36]
   5250          
   5251                /* Update counter */
   5252                hi2c->XferCount--;
   \       0x72   0x8D41             LDRH     R1,[R0, #+42]
   \       0x74   0x1E4A             SUBS     R2,R1,#+1
   \       0x76   0x8542             STRH     R2,[R0, #+42]
   5253              }
   5254              else
   5255              {
   5256                /* Do nothing */
   5257              }
   5258            }
   5259            else
   5260            {
   5261              /* Do nothing */
   5262            }
   5263          }
   \                     ??I2C_MemoryTransmit_TXE_BTF_4: (+1)
   \       0x78   0x4770             BX       LR               ;; return
   5264          
   5265          /**
   5266            * @brief  Handle RXNE flag for Master
   5267            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5268            *         the configuration information for I2C module
   5269            * @retval None
   5270            */
   5271          static void I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
   5272          {
   5273            if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
   5274            {
   5275              uint32_t tmp;
   5276          
   5277              tmp = hi2c->XferCount;
   5278              if (tmp > 3U)
   5279              {
   5280                /* Read data from DR */
   5281                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   5282          
   5283                /* Increment Buffer pointer */
   5284                hi2c->pBuffPtr++;
   5285          
   5286                /* Update counter */
   5287                hi2c->XferCount--;
   5288          
   5289                if (hi2c->XferCount == (uint16_t)3)
   5290                {
   5291                  /* Disable BUF interrupt, this help to treat correctly the last 4 bytes
   5292                  on BTF subroutine */
   5293                  /* Disable BUF interrupt */
   5294                  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   5295                }
   5296              }
   5297              else if ((hi2c->XferOptions != I2C_FIRST_AND_NEXT_FRAME) && ((tmp == 1U) || (tmp == 0U)))
   5298              {
   5299                /* Disable Acknowledge */
   5300                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5301          
   5302                /* Disable EVT, BUF and ERR interrupt */
   5303                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   5304          
   5305                /* Read data from DR */
   5306                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   5307          
   5308                /* Increment Buffer pointer */
   5309                hi2c->pBuffPtr++;
   5310          
   5311                /* Update counter */
   5312                hi2c->XferCount--;
   5313          
   5314                hi2c->State = HAL_I2C_STATE_READY;
   5315          
   5316                if (hi2c->Mode == HAL_I2C_MODE_MEM)
   5317                {
   5318                  hi2c->Mode = HAL_I2C_MODE_NONE;
   5319                  hi2c->PreviousState = I2C_STATE_NONE;
   5320          
   5321          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5322                  hi2c->MemRxCpltCallback(hi2c);
   5323          #else
   5324                  HAL_I2C_MemRxCpltCallback(hi2c);
   5325          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5326                }
   5327                else
   5328                {
   5329                  hi2c->Mode = HAL_I2C_MODE_NONE;
   5330                  hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
   5331          
   5332          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5333                  hi2c->MasterRxCpltCallback(hi2c);
   5334          #else
   5335                  HAL_I2C_MasterRxCpltCallback(hi2c);
   5336          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5337                }
   5338              }
   5339              else
   5340              {
   5341                /* Do nothing */
   5342              }
   5343            }
   5344          }
   5345          
   5346          /**
   5347            * @brief  Handle BTF flag for Master receiver
   5348            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5349            *         the configuration information for I2C module
   5350            * @retval None
   5351            */
   5352          static void I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
   5353          {
   5354            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   5355            uint32_t CurrentXferOptions = hi2c->XferOptions;
   5356          
   5357            if (hi2c->XferCount == 4U)
   5358            {
   5359              /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
   5360                 on BTF subroutine if there is a reception delay between N-1 and N byte */
   5361              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   5362          
   5363              /* Read data from DR */
   5364              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   5365          
   5366              /* Increment Buffer pointer */
   5367              hi2c->pBuffPtr++;
   5368          
   5369              /* Update counter */
   5370              hi2c->XferCount--;
   5371            }
   5372            else if (hi2c->XferCount == 3U)
   5373            {
   5374              /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
   5375                 on BTF subroutine if there is a reception delay between N-1 and N byte */
   5376              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   5377          
   5378              if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME))
   5379              {
   5380                /* Disable Acknowledge */
   5381                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5382              }
   5383          
   5384              /* Read data from DR */
   5385              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   5386          
   5387              /* Increment Buffer pointer */
   5388              hi2c->pBuffPtr++;
   5389          
   5390              /* Update counter */
   5391              hi2c->XferCount--;
   5392            }
   5393            else if (hi2c->XferCount == 2U)
   5394            {
   5395              /* Prepare next transfer or stop current transfer */
   5396              if ((CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP))
   5397              {
   5398                /* Disable Acknowledge */
   5399                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5400              }
   5401              else if ((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_NEXT_FRAME))
   5402              {
   5403                /* Enable Acknowledge */
   5404                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5405              }
   5406              else if (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP)
   5407              {
   5408                /* Generate Stop */
   5409                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   5410              }
   5411              else
   5412              {
   5413                /* Do nothing */
   5414              }
   5415          
   5416              /* Read data from DR */
   5417              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   5418          
   5419              /* Increment Buffer pointer */
   5420              hi2c->pBuffPtr++;
   5421          
   5422              /* Update counter */
   5423              hi2c->XferCount--;
   5424          
   5425              /* Read data from DR */
   5426              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   5427          
   5428              /* Increment Buffer pointer */
   5429              hi2c->pBuffPtr++;
   5430          
   5431              /* Update counter */
   5432              hi2c->XferCount--;
   5433          
   5434              /* Disable EVT and ERR interrupt */
   5435              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   5436          
   5437              hi2c->State = HAL_I2C_STATE_READY;
   5438              if (hi2c->Mode == HAL_I2C_MODE_MEM)
   5439              {
   5440                hi2c->Mode = HAL_I2C_MODE_NONE;
   5441                hi2c->PreviousState = I2C_STATE_NONE;
   5442          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5443                hi2c->MemRxCpltCallback(hi2c);
   5444          #else
   5445                HAL_I2C_MemRxCpltCallback(hi2c);
   5446          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5447              }
   5448              else
   5449              {
   5450                hi2c->Mode = HAL_I2C_MODE_NONE;
   5451                hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
   5452          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5453                hi2c->MasterRxCpltCallback(hi2c);
   5454          #else
   5455                HAL_I2C_MasterRxCpltCallback(hi2c);
   5456          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5457              }
   5458            }
   5459            else
   5460            {
   5461              /* Read data from DR */
   5462              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   5463          
   5464              /* Increment Buffer pointer */
   5465              hi2c->pBuffPtr++;
   5466          
   5467              /* Update counter */
   5468              hi2c->XferCount--;
   5469            }
   5470          }
   5471          
   5472          /**
   5473            * @brief  Handle SB flag for Master
   5474            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5475            *         the configuration information for I2C module
   5476            * @retval None
   5477            */
   5478          static void I2C_Master_SB(I2C_HandleTypeDef *hi2c)
   5479          {
   5480            if (hi2c->Mode == HAL_I2C_MODE_MEM)
   5481            {
   5482              if (hi2c->EventCount == 0U)
   5483              {
   5484                /* Send slave address */
   5485                hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
   5486              }
   5487              else
   5488              {
   5489                hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
   5490              }
   5491            }
   5492            else
   5493            {
   5494              if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   5495              {
   5496                /* Send slave 7 Bits address */
   5497                if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
   5498                {
   5499                  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
   5500                }
   5501                else
   5502                {
   5503                  hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
   5504                }
   5505          
   5506                if (((hi2c->hdmatx != NULL) && (hi2c->hdmatx->XferCpltCallback != NULL))
   5507                    || ((hi2c->hdmarx != NULL) && (hi2c->hdmarx->XferCpltCallback != NULL)))
   5508                {
   5509                  /* Enable DMA Request */
   5510                  SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   5511                }
   5512              }
   5513              else
   5514              {
   5515                if (hi2c->EventCount == 0U)
   5516                {
   5517                  /* Send header of slave address */
   5518                  hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
   5519                }
   5520                else if (hi2c->EventCount == 1U)
   5521                {
   5522                  /* Send header of slave address */
   5523                  hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
   5524                }
   5525                else
   5526                {
   5527                  /* Do nothing */
   5528                }
   5529              }
   5530            }
   5531          }
   5532          
   5533          /**
   5534            * @brief  Handle ADD10 flag for Master
   5535            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5536            *         the configuration information for I2C module
   5537            * @retval None
   5538            */
   5539          static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
   5540          {
   5541            /* Send slave address */
   5542            hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
   5543          
   5544            if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
   5545            {
   5546              if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
   5547              {
   5548                /* Enable DMA Request */
   5549                SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   5550              }
   5551            }
   5552          }
   5553          
   5554          /**
   5555            * @brief  Handle ADDR flag for Master
   5556            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5557            *         the configuration information for I2C module
   5558            * @retval None
   5559            */
   5560          static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
   5561          {
   5562            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   5563            HAL_I2C_ModeTypeDef CurrentMode       = hi2c->Mode;
   5564            uint32_t CurrentXferOptions           = hi2c->XferOptions;
   5565            uint32_t Prev_State                   = hi2c->PreviousState;
   5566          
   5567            if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
   5568            {
   5569              if ((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
   5570              {
   5571                /* Clear ADDR flag */
   5572                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   5573              }
   5574              else if ((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
   5575              {
   5576                /* Clear ADDR flag */
   5577                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   5578          
   5579                /* Generate Restart */
   5580                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   5581          
   5582                hi2c->EventCount++;
   5583              }
   5584              else
   5585              {
   5586                if (hi2c->XferCount == 0U)
   5587                {
   5588                  /* Clear ADDR flag */
   5589                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   5590          
   5591                  /* Generate Stop */
   5592                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   5593                }
   5594                else if (hi2c->XferCount == 1U)
   5595                {
   5596                  if (CurrentXferOptions == I2C_NO_OPTION_FRAME)
   5597                  {
   5598                    /* Disable Acknowledge */
   5599                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5600          
   5601                    if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   5602                    {
   5603                      /* Disable Acknowledge */
   5604                      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5605          
   5606                      /* Clear ADDR flag */
   5607                      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   5608                    }
   5609                    else
   5610                    {
   5611                      /* Clear ADDR flag */
   5612                      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   5613          
   5614                      /* Generate Stop */
   5615                      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   5616                    }
   5617                  }
   5618                  /* Prepare next transfer or stop current transfer */
   5619                  else if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
   5620                           && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
   5621                  {
   5622                    if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
   5623                    {
   5624                      /* Disable Acknowledge */
   5625                      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5626                    }
   5627                    else
   5628                    {
   5629                      /* Enable Acknowledge */
   5630                      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5631                    }
   5632          
   5633                    /* Clear ADDR flag */
   5634                    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   5635                  }
   5636                  else
   5637                  {
   5638                    /* Disable Acknowledge */
   5639                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5640          
   5641                    /* Clear ADDR flag */
   5642                    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   5643          
   5644                    /* Generate Stop */
   5645                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   5646                  }
   5647                }
   5648                else if (hi2c->XferCount == 2U)
   5649                {
   5650                  if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
   5651                  {
   5652                    /* Disable Acknowledge */
   5653                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5654          
   5655                    /* Enable Pos */
   5656                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   5657                  }
   5658                  else
   5659                  {
   5660                    /* Enable Acknowledge */
   5661                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5662                  }
   5663          
   5664                  if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
   5665                  {
   5666                    /* Enable Last DMA bit */
   5667                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   5668                  }
   5669          
   5670                  /* Clear ADDR flag */
   5671                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   5672                }
   5673                else
   5674                {
   5675                  /* Enable Acknowledge */
   5676                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5677          
   5678                  if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
   5679                  {
   5680                    /* Enable Last DMA bit */
   5681                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   5682                  }
   5683          
   5684                  /* Clear ADDR flag */
   5685                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   5686                }
   5687          
   5688                /* Reset Event counter  */
   5689                hi2c->EventCount = 0U;
   5690              }
   5691            }
   5692            else
   5693            {
   5694              /* Clear ADDR flag */
   5695              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   5696            }
   5697          }
   5698          
   5699          /**
   5700            * @brief  Handle TXE flag for Slave
   5701            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5702            *         the configuration information for I2C module
   5703            * @retval None
   5704            */
   5705          static void I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
   5706          {
   5707            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   5708            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   5709          
   5710            if (hi2c->XferCount != 0U)
   5711            {
   5712              /* Write data to DR */
   5713              hi2c->Instance->DR = *hi2c->pBuffPtr;
   5714          
   5715              /* Increment Buffer pointer */
   5716              hi2c->pBuffPtr++;
   5717          
   5718              /* Update counter */
   5719              hi2c->XferCount--;
   5720          
   5721              if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
   5722              {
   5723                /* Last Byte is received, disable Interrupt */
   5724                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   5725          
   5726                /* Set state at HAL_I2C_STATE_LISTEN */
   5727                hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
   5728                hi2c->State = HAL_I2C_STATE_LISTEN;
   5729          
   5730                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5731          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5732                hi2c->SlaveTxCpltCallback(hi2c);
   5733          #else
   5734                HAL_I2C_SlaveTxCpltCallback(hi2c);
   5735          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5736              }
   5737            }
   5738          }
   5739          
   5740          /**
   5741            * @brief  Handle BTF flag for Slave transmitter
   5742            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5743            *         the configuration information for I2C module
   5744            * @retval None
   5745            */
   5746          static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
   5747          {
   5748            if (hi2c->XferCount != 0U)
   5749            {
   5750              /* Write data to DR */
   5751              hi2c->Instance->DR = *hi2c->pBuffPtr;
   5752          
   5753              /* Increment Buffer pointer */
   5754              hi2c->pBuffPtr++;
   5755          
   5756              /* Update counter */
   5757              hi2c->XferCount--;
   5758            }
   5759          }
   5760          
   5761          /**
   5762            * @brief  Handle RXNE flag for Slave
   5763            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5764            *         the configuration information for I2C module
   5765            * @retval None
   5766            */
   5767          static void I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
   5768          {
   5769            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   5770            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   5771          
   5772            if (hi2c->XferCount != 0U)
   5773            {
   5774              /* Read data from DR */
   5775              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   5776          
   5777              /* Increment Buffer pointer */
   5778              hi2c->pBuffPtr++;
   5779          
   5780              /* Update counter */
   5781              hi2c->XferCount--;
   5782          
   5783              if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
   5784              {
   5785                /* Last Byte is received, disable Interrupt */
   5786                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   5787          
   5788                /* Set state at HAL_I2C_STATE_LISTEN */
   5789                hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
   5790                hi2c->State = HAL_I2C_STATE_LISTEN;
   5791          
   5792                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5793          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5794                hi2c->SlaveRxCpltCallback(hi2c);
   5795          #else
   5796                HAL_I2C_SlaveRxCpltCallback(hi2c);
   5797          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5798              }
   5799            }
   5800          }
   5801          
   5802          /**
   5803            * @brief  Handle BTF flag for Slave receiver
   5804            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5805            *         the configuration information for I2C module
   5806            * @retval None
   5807            */
   5808          static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
   5809          {
   5810            if (hi2c->XferCount != 0U)
   5811            {
   5812              /* Read data from DR */
   5813              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   5814          
   5815              /* Increment Buffer pointer */
   5816              hi2c->pBuffPtr++;
   5817          
   5818              /* Update counter */
   5819              hi2c->XferCount--;
   5820            }
   5821          }
   5822          
   5823          /**
   5824            * @brief  Handle ADD flag for Slave
   5825            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5826            *         the configuration information for I2C module
   5827            * @param  IT2Flags Interrupt2 flags to handle.
   5828            * @retval None
   5829            */
   5830          static void I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c, uint32_t IT2Flags)
   5831          {
   5832            uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
   5833            uint16_t SlaveAddrCode;
   5834          
   5835            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   5836            {
   5837              /* Disable BUF interrupt, BUF enabling is manage through slave specific interface */
   5838              __HAL_I2C_DISABLE_IT(hi2c, (I2C_IT_BUF));
   5839          
   5840              /* Transfer Direction requested by Master */
   5841              if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_TRA) == RESET)
   5842              {
   5843                TransferDirection = I2C_DIRECTION_TRANSMIT;
   5844              }
   5845          
   5846              if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_DUALF) == RESET)
   5847              {
   5848                SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress1;
   5849              }
   5850              else
   5851              {
   5852                SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress2;
   5853              }
   5854          
   5855              /* Process Unlocked */
   5856              __HAL_UNLOCK(hi2c);
   5857          
   5858              /* Call Slave Addr callback */
   5859          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5860              hi2c->AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
   5861          #else
   5862              HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
   5863          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5864            }
   5865            else
   5866            {
   5867              /* Clear ADDR flag */
   5868              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   5869          
   5870              /* Process Unlocked */
   5871              __HAL_UNLOCK(hi2c);
   5872            }
   5873          }
   5874          
   5875          /**
   5876            * @brief  Handle STOPF flag for Slave
   5877            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5878            *         the configuration information for I2C module
   5879            * @retval None
   5880            */
   5881          static void I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
   5882          {
   5883            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   5884            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   5885          
   5886            /* Disable EVT, BUF and ERR interrupt */
   5887            __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   5888          
   5889            /* Clear STOPF flag */
   5890            __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   5891          
   5892            /* Disable Acknowledge */
   5893            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   5894          
   5895            /* If a DMA is ongoing, Update handle size context */
   5896            if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   5897            {
   5898              if ((CurrentState == HAL_I2C_STATE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
   5899              {
   5900                hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmarx));
   5901          
   5902                if (hi2c->XferCount != 0U)
   5903                {
   5904                  /* Set ErrorCode corresponding to a Non-Acknowledge */
   5905                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   5906                }
   5907          
   5908                /* Disable, stop the current DMA */
   5909                CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   5910          
   5911                /* Abort DMA Xfer if any */
   5912                if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
   5913                {
   5914                  /* Set the I2C DMA Abort callback :
   5915                  will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   5916                  hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   5917          
   5918                  /* Abort DMA RX */
   5919                  if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   5920                  {
   5921                    /* Call Directly XferAbortCallback function in case of error */
   5922                    hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   5923                  }
   5924                }
   5925              }
   5926              else
   5927              {
   5928                hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmatx));
   5929          
   5930                if (hi2c->XferCount != 0U)
   5931                {
   5932                  /* Set ErrorCode corresponding to a Non-Acknowledge */
   5933                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   5934                }
   5935          
   5936                /* Disable, stop the current DMA */
   5937                CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   5938          
   5939                /* Abort DMA Xfer if any */
   5940                if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
   5941                {
   5942                  /* Set the I2C DMA Abort callback :
   5943                  will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   5944                  hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   5945          
   5946                  /* Abort DMA TX */
   5947                  if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   5948                  {
   5949                    /* Call Directly XferAbortCallback function in case of error */
   5950                    hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   5951                  }
   5952                }
   5953              }
   5954            }
   5955          
   5956            /* All data are not transferred, so set error code accordingly */
   5957            if (hi2c->XferCount != 0U)
   5958            {
   5959              /* Store Last receive data if any */
   5960              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   5961              {
   5962                /* Read data from DR */
   5963                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   5964          
   5965                /* Increment Buffer pointer */
   5966                hi2c->pBuffPtr++;
   5967          
   5968                /* Update counter */
   5969                hi2c->XferCount--;
   5970              }
   5971          
   5972              /* Store Last receive data if any */
   5973              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   5974              {
   5975                /* Read data from DR */
   5976                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   5977          
   5978                /* Increment Buffer pointer */
   5979                hi2c->pBuffPtr++;
   5980          
   5981                /* Update counter */
   5982                hi2c->XferCount--;
   5983              }
   5984          
   5985              if (hi2c->XferCount != 0U)
   5986              {
   5987                /* Set ErrorCode corresponding to a Non-Acknowledge */
   5988                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   5989              }
   5990            }
   5991          
   5992            if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   5993            {
   5994              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5995              I2C_ITError(hi2c);
   5996            }
   5997            else
   5998            {
   5999              if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
   6000              {
   6001                /* Set state at HAL_I2C_STATE_LISTEN */
   6002                hi2c->PreviousState = I2C_STATE_NONE;
   6003                hi2c->State = HAL_I2C_STATE_LISTEN;
   6004          
   6005                /* Call the corresponding callback to inform upper layer of End of Transfer */
   6006          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6007                hi2c->SlaveRxCpltCallback(hi2c);
   6008          #else
   6009                HAL_I2C_SlaveRxCpltCallback(hi2c);
   6010          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6011              }
   6012          
   6013              if (hi2c->State == HAL_I2C_STATE_LISTEN)
   6014              {
   6015                hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   6016                hi2c->PreviousState = I2C_STATE_NONE;
   6017                hi2c->State = HAL_I2C_STATE_READY;
   6018                hi2c->Mode = HAL_I2C_MODE_NONE;
   6019          
   6020                /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   6021          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6022                hi2c->ListenCpltCallback(hi2c);
   6023          #else
   6024                HAL_I2C_ListenCpltCallback(hi2c);
   6025          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6026              }
   6027              else
   6028              {
   6029                if ((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
   6030                {
   6031                  hi2c->PreviousState = I2C_STATE_NONE;
   6032                  hi2c->State = HAL_I2C_STATE_READY;
   6033                  hi2c->Mode = HAL_I2C_MODE_NONE;
   6034          
   6035          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6036                  hi2c->SlaveRxCpltCallback(hi2c);
   6037          #else
   6038                  HAL_I2C_SlaveRxCpltCallback(hi2c);
   6039          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6040                }
   6041              }
   6042            }
   6043          }
   6044          
   6045          /**
   6046            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6047            *         the configuration information for I2C module
   6048            * @retval None
   6049            */
   6050          static void I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
   6051          {
   6052            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   6053            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   6054            uint32_t CurrentXferOptions       = hi2c->XferOptions;
   6055          
   6056            if (((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
   6057                (CurrentState == HAL_I2C_STATE_LISTEN))
   6058            {
   6059              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   6060          
   6061              /* Disable EVT, BUF and ERR interrupt */
   6062              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   6063          
   6064              /* Clear AF flag */
   6065              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   6066          
   6067              /* Disable Acknowledge */
   6068              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   6069          
   6070              hi2c->PreviousState = I2C_STATE_NONE;
   6071              hi2c->State         = HAL_I2C_STATE_READY;
   6072              hi2c->Mode          = HAL_I2C_MODE_NONE;
   6073          
   6074              /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   6075          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6076              hi2c->ListenCpltCallback(hi2c);
   6077          #else
   6078              HAL_I2C_ListenCpltCallback(hi2c);
   6079          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6080            }
   6081            else if (CurrentState == HAL_I2C_STATE_BUSY_TX)
   6082            {
   6083              hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
   6084              hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
   6085              hi2c->State         = HAL_I2C_STATE_READY;
   6086              hi2c->Mode          = HAL_I2C_MODE_NONE;
   6087          
   6088              /* Disable EVT, BUF and ERR interrupt */
   6089              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   6090          
   6091              /* Clear AF flag */
   6092              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   6093          
   6094              /* Disable Acknowledge */
   6095              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   6096          
   6097          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6098              hi2c->SlaveTxCpltCallback(hi2c);
   6099          #else
   6100              HAL_I2C_SlaveTxCpltCallback(hi2c);
   6101          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6102            }
   6103            else
   6104            {
   6105              /* Clear AF flag only */
   6106              /* State Listen, but XferOptions == FIRST or NEXT */
   6107              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   6108            }
   6109          }
   6110          
   6111          /**
   6112            * @brief  I2C interrupts error process
   6113            * @param  hi2c I2C handle.
   6114            * @retval None
   6115            */

   \                                 In section .text, align 2, keep-with-next
   6116          static void I2C_ITError(I2C_HandleTypeDef *hi2c)
   6117          {
   \                     I2C_ITError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   6118            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   6119            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0x4   0xF104 0x053D      ADD      R5,R4,#+61
   \        0x8   0x7828             LDRB     R0,[R5, #+0]
   6120            uint32_t CurrentError;
   6121          
   6122            if ((hi2c->Mode == HAL_I2C_MODE_MASTER) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
   \        0xA   0x7869             LDRB     R1,[R5, #+1]
   \        0xC   0x2910             CMP      R1,#+16
   \        0xE   0xBF08             IT       EQ
   \       0x10   0x2822             CMPEQ    R0,#+34
   \       0x12   0xD104             BNE.N    ??I2C_ITError_0
   6123            {
   6124              /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
   6125              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \       0x14   0x6821             LDR      R1,[R4, #+0]
   \       0x16   0x680A             LDR      R2,[R1, #+0]
   \       0x18   0xF422 0x6200      BIC      R2,R2,#0x800
   \       0x1C   0x600A             STR      R2,[R1, #+0]
   6126            }
   6127          
   6128            if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??I2C_ITError_0: (+1)
   \       0x1E   0xF000 0x0128      AND      R1,R0,#0x28
   \       0x22   0x2928             CMP      R1,#+40
   \       0x24   0xD103             BNE.N    ??I2C_ITError_1
   6129            {
   6130              /* keep HAL_I2C_STATE_LISTEN */
   6131              hi2c->PreviousState = I2C_STATE_NONE;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6320             STR      R0,[R4, #+48]
   6132              hi2c->State = HAL_I2C_STATE_LISTEN;
   \       0x2A   0x7029             STRB     R1,[R5, #+0]
   \       0x2C   0xE00A             B.N      ??I2C_ITError_2
   6133            }
   6134            else
   6135            {
   6136              /* If state is an abort treatment on going, don't change state */
   6137              /* This change will be do later */
   6138              if ((READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN) && (CurrentState != HAL_I2C_STATE_ABORT))
   \                     ??I2C_ITError_1: (+1)
   \       0x2E   0x6822             LDR      R2,[R4, #+0]
   \       0x30   0x6851             LDR      R1,[R2, #+4]
   \       0x32   0x050A             LSLS     R2,R1,#+20
   \       0x34   0xD403             BMI.N    ??I2C_ITError_3
   \       0x36   0x2860             CMP      R0,#+96
   \       0x38   0xBF1C             ITT      NE
   \       0x3A   0x2020             MOVNE    R0,#+32
   \       0x3C   0x7028             STRBNE   R0,[R5, #+0]
   6139              {
   6140                hi2c->State = HAL_I2C_STATE_READY;
   6141              }
   6142              hi2c->PreviousState = I2C_STATE_NONE;
   \                     ??I2C_ITError_3: (+1)
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x6321             STR      R1,[R4, #+48]
   6143              hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x42   0x7069             STRB     R1,[R5, #+1]
   6144            }
   6145          
   6146            /* Abort DMA transfer */
   6147            if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \                     ??I2C_ITError_2: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6841             LDR      R1,[R0, #+4]
   \       0x48   0x050A             LSLS     R2,R1,#+20
   \       0x4A   0xD523             BPL.N    ??I2C_ITError_4
   6148            {
   6149              hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
   \       0x4C   0x6841             LDR      R1,[R0, #+4]
   \       0x4E   0xF421 0x6100      BIC      R1,R1,#0x800
   \       0x52   0x6041             STR      R1,[R0, #+4]
   6150          
   6151              if (hi2c->hdmatx->State != HAL_DMA_STATE_READY)
   \       0x54   0x6B60             LDR      R0,[R4, #+52]
   \       0x56   0x....'....        ADR.W    R1,I2C_DMAAbort
   \       0x5A   0xF890 0x2035      LDRB     R2,[R0, #+53]
   \       0x5E   0x2A01             CMP      R2,#+1
   \       0x60   0xD009             BEQ.N    ??I2C_ITError_5
   6152              {
   6153                /* Set the DMA Abort callback :
   6154                will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   6155                hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x62   0x6501             STR      R1,[R0, #+80]
   6156          
   6157                if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \       0x64   0x6B60             LDR      R0,[R4, #+52]
   \       0x66   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD025             BEQ.N    ??I2C_ITError_6
   6158                {
   6159                  /* Disable I2C peripheral to prevent dummy data in buffer */
   6160                  __HAL_I2C_DISABLE(hi2c);
   \       0x6E   0x....'....        BL       ?Subroutine35
   6161          
   6162                  hi2c->State = HAL_I2C_STATE_READY;
   6163          
   6164                  /* Call Directly XferAbortCallback function in case of error */
   6165                  hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \                     ??CrossCallReturnLabel_95: (+1)
   \       0x72   0x6B60             LDR      R0,[R4, #+52]
   \       0x74   0xE00B             B.N      ??I2C_ITError_7
   6166                }
   6167              }
   6168              else
   6169              {
   6170                /* Set the DMA Abort callback :
   6171                will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   6172                hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \                     ??I2C_ITError_5: (+1)
   \       0x76   0x6BA0             LDR      R0,[R4, #+56]
   \       0x78   0x6501             STR      R1,[R0, #+80]
   6173          
   6174                if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \       0x7A   0x6BA0             LDR      R0,[R4, #+56]
   \       0x7C   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x80   0xB1D8             CBZ.N    R0,??I2C_ITError_6
   6175                {
   6176                  /* Store Last receive data if any */
   6177                  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x....'....        BL       ?Subroutine94
   6178                  {
   6179                    /* Read data from DR */
   6180                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   6181          
   6182                    /* Increment Buffer pointer */
   6183                    hi2c->pBuffPtr++;
   6184                  }
   6185          
   6186                  /* Disable I2C peripheral to prevent dummy data in buffer */
   6187                  __HAL_I2C_DISABLE(hi2c);
   \                     ??CrossCallReturnLabel_277: (+1)
   \       0x88   0x....'....        BL       ?Subroutine35
   6188          
   6189                  hi2c->State = HAL_I2C_STATE_READY;
   6190          
   6191                  /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
   6192                  hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \                     ??CrossCallReturnLabel_96: (+1)
   \       0x8C   0x6BA0             LDR      R0,[R4, #+56]
   \                     ??I2C_ITError_7: (+1)
   \       0x8E   0x6D01             LDR      R1,[R0, #+80]
   \       0x90   0x4788             BLX      R1
   \       0x92   0xE012             B.N      ??I2C_ITError_6
   6193                }
   6194              }
   6195            }
   6196            else if (hi2c->State == HAL_I2C_STATE_ABORT)
   \                     ??I2C_ITError_4: (+1)
   \       0x94   0x782A             LDRB     R2,[R5, #+0]
   \       0x96   0x2A60             CMP      R2,#+96
   \       0x98   0xD10A             BNE.N    ??I2C_ITError_8
   6197            {
   6198              hi2c->State = HAL_I2C_STATE_READY;
   \       0x9A   0x2120             MOVS     R1,#+32
   \       0x9C   0x7029             STRB     R1,[R5, #+0]
   6199              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x9E   0x2200             MOVS     R2,#+0
   \       0xA0   0x6422             STR      R2,[R4, #+64]
   6200          
   6201              /* Store Last receive data if any */
   6202              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \       0xA2   0x....'....        BL       ?Subroutine94
   6203              {
   6204                /* Read data from DR */
   6205                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   6206          
   6207                /* Increment Buffer pointer */
   6208                hi2c->pBuffPtr++;
   6209              }
   6210          
   6211              /* Disable I2C peripheral to prevent dummy data in buffer */
   6212              __HAL_I2C_DISABLE(hi2c);
   \                     ??CrossCallReturnLabel_278: (+1)
   \       0xA6   0x....'....        BL       ?Subroutine38
   6213          
   6214              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6215          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6216              hi2c->AbortCpltCallback(hi2c);
   6217          #else
   6218              HAL_I2C_AbortCpltCallback(hi2c);
   6219          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6220            }
   \                     ??CrossCallReturnLabel_106: (+1)
   \       0xAA   0x....'....        BL       HAL_I2C_AbortCpltCallback
   \       0xAE   0xE004             B.N      ??I2C_ITError_6
   6221            else
   6222            {
   6223              /* Store Last receive data if any */
   6224              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \                     ??I2C_ITError_8: (+1)
   \       0xB0   0x....'....        BL       ?Subroutine94
   6225              {
   6226                /* Read data from DR */
   6227                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   6228          
   6229                /* Increment Buffer pointer */
   6230                hi2c->pBuffPtr++;
   6231              }
   6232          
   6233              /* Call user error callback */
   6234          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6235              hi2c->ErrorCallback(hi2c);
   6236          #else
   6237              HAL_I2C_ErrorCallback(hi2c);
   \                     ??CrossCallReturnLabel_279: (+1)
   \       0xB4   0x4620             MOV      R0,R4
   \       0xB6   0x....'....        BL       HAL_I2C_ErrorCallback
   6238          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6239            }
   6240          
   6241            /* STOP Flag is not set after a NACK reception, BusError, ArbitrationLost, OverRun */
   6242            CurrentError = hi2c->ErrorCode;
   6243          
   6244            if (((CurrentError & HAL_I2C_ERROR_BERR) == HAL_I2C_ERROR_BERR) || \
   6245                ((CurrentError & HAL_I2C_ERROR_ARLO) == HAL_I2C_ERROR_ARLO) || \
   6246                ((CurrentError & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF)     || \
   6247                ((CurrentError & HAL_I2C_ERROR_OVR) == HAL_I2C_ERROR_OVR))
   \                     ??I2C_ITError_6: (+1)
   \       0xBA   0x6C20             LDR      R0,[R4, #+64]
   \       0xBC   0xF010 0x0F0F      TST      R0,#0xF
   \       0xC0   0xD004             BEQ.N    ??I2C_ITError_9
   6248            {
   6249              /* Disable EVT, BUF and ERR interrupt */
   6250              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x6841             LDR      R1,[R0, #+4]
   \       0xC6   0xF421 0x61E0      BIC      R1,R1,#0x700
   \       0xCA   0x6041             STR      R1,[R0, #+4]
   6251            }
   6252          
   6253            /* So may inform upper layer that listen phase is stopped */
   6254            /* during NACK error treatment */
   6255            CurrentState = hi2c->State;
   \                     ??I2C_ITError_9: (+1)
   \       0xCC   0x7828             LDRB     R0,[R5, #+0]
   6256            if (((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF) && (CurrentState == HAL_I2C_STATE_LISTEN))
   \       0xCE   0x6C21             LDR      R1,[R4, #+64]
   \       0xD0   0x074A             LSLS     R2,R1,#+29
   \       0xD2   0xD50D             BPL.N    ??I2C_ITError_10
   \       0xD4   0x2828             CMP      R0,#+40
   \       0xD6   0xD10B             BNE.N    ??I2C_ITError_10
   6257            {
   6258              hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
   \       0xD8   0x....             LDR.N    R0,??DataTable35  ;; 0xffff0000
   \       0xDA   0x62E0             STR      R0,[R4, #+44]
   6259              hi2c->PreviousState = I2C_STATE_NONE;
   \       0xDC   0x2100             MOVS     R1,#+0
   \       0xDE   0x6321             STR      R1,[R4, #+48]
   6260              hi2c->State         = HAL_I2C_STATE_READY;
   \       0xE0   0x2020             MOVS     R0,#+32
   \       0xE2   0x7028             STRB     R0,[R5, #+0]
   6261              hi2c->Mode          = HAL_I2C_MODE_NONE;
   \       0xE4   0x7069             STRB     R1,[R5, #+1]
   6262          
   6263              /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   6264          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6265              hi2c->ListenCpltCallback(hi2c);
   6266          #else
   6267              HAL_I2C_ListenCpltCallback(hi2c);
   \       0xE6   0x4620             MOV      R0,R4
   \       0xE8   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0xEC   0x....'....        B.W      HAL_I2C_ListenCpltCallback
   6268          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6269            }
   6270          }
   \                     ??I2C_ITError_10: (+1)
   \       0xF0   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine94: (+1)
   \        0x0   0x6941             LDR      R1,[R0, #+20]
   \        0x2   0x064A             LSLS     R2,R1,#+25
   \        0x4   0xD505             BPL.N    ??Subroutine94_0
   \        0x6   0x6900             LDR      R0,[R0, #+16]
   \        0x8   0x6A61             LDR      R1,[R4, #+36]
   \        0xA   0x7008             STRB     R0,[R1, #+0]
   \        0xC   0x6A60             LDR      R0,[R4, #+36]
   \        0xE   0x1C42             ADDS     R2,R0,#+1
   \       0x10   0x6262             STR      R2,[R4, #+36]
   \                     ??Subroutine94_0: (+1)
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine35: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x0849             LSRS     R1,R1,#+1
   \        0x6   0x0049             LSLS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0x7028             STRB     R0,[R5, #+0]
   \        0xE   0x4770             BX       LR
   6271          
   6272          /**
   6273            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6274            *         the configuration information for I2C module
   6275            * @param  DevAddress Target device address: The device 7 bits address value
   6276            *         in datasheet must be shifted to the left before calling the interface
   6277            * @param  Timeout Timeout duration
   6278            * @param  Tickstart Tick start value
   6279            * @retval HAL status
   6280            */
   6281          static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
   6282          {
   6283            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   6284            uint32_t CurrentXferOptions = hi2c->XferOptions;
   6285          
   6286            /* Generate Start condition if first transfer */
   6287            if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
   6288            {
   6289              /* Generate Start */
   6290              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   6291            }
   6292            else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX)
   6293            {
   6294              /* Generate ReStart */
   6295              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   6296            }
   6297            else
   6298            {
   6299              /* Do nothing */
   6300            }
   6301          
   6302            /* Wait until SB flag is set */
   6303            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   6304            {
   6305              if (hi2c->Instance->CR1 & I2C_CR1_START)
   6306              {
   6307                hi2c->ErrorCode = HAL_I2C_WRONG_START;
   6308              }
   6309              return HAL_TIMEOUT;
   6310            }
   6311          
   6312            if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   6313            {
   6314              /* Send slave address */
   6315              hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   6316            }
   6317            else
   6318            {
   6319              /* Send header of slave address */
   6320              hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
   6321          
   6322              /* Wait until ADD10 flag is set */
   6323              if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
   6324              {
   6325                return HAL_ERROR;
   6326              }
   6327          
   6328              /* Send slave address */
   6329              hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
   6330            }
   6331          
   6332            /* Wait until ADDR flag is set */
   6333            if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   6334            {
   6335              return HAL_ERROR;
   6336            }
   6337          
   6338            return HAL_OK;
   6339          }
   6340          
   6341          /**
   6342            * @brief  Master sends target device address for read request.
   6343            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6344            *         the configuration information for I2C module
   6345            * @param  DevAddress Target device address: The device 7 bits address value
   6346            *         in datasheet must be shifted to the left before calling the interface
   6347            * @param  Timeout Timeout duration
   6348            * @param  Tickstart Tick start value
   6349            * @retval HAL status
   6350            */
   6351          static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
   6352          {
   6353            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   6354            uint32_t CurrentXferOptions = hi2c->XferOptions;
   6355          
   6356            /* Enable Acknowledge */
   6357            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   6358          
   6359            /* Generate Start condition if first transfer */
   6360            if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME)  || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
   6361            {
   6362              /* Generate Start */
   6363              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   6364            }
   6365            else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX)
   6366            {
   6367              /* Generate ReStart */
   6368              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   6369            }
   6370            else
   6371            {
   6372              /* Do nothing */
   6373            }
   6374          
   6375            /* Wait until SB flag is set */
   6376            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   6377            {
   6378              if (hi2c->Instance->CR1 & I2C_CR1_START)
   6379              {
   6380                hi2c->ErrorCode = HAL_I2C_WRONG_START;
   6381              }
   6382              return HAL_TIMEOUT;
   6383            }
   6384          
   6385            if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   6386            {
   6387              /* Send slave address */
   6388              hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
   6389            }
   6390            else
   6391            {
   6392              /* Send header of slave address */
   6393              hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
   6394          
   6395              /* Wait until ADD10 flag is set */
   6396              if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
   6397              {
   6398                return HAL_ERROR;
   6399              }
   6400          
   6401              /* Send slave address */
   6402              hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
   6403          
   6404              /* Wait until ADDR flag is set */
   6405              if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   6406              {
   6407                return HAL_ERROR;
   6408              }
   6409          
   6410              /* Clear ADDR flag */
   6411              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   6412          
   6413              /* Generate Restart */
   6414              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   6415          
   6416              /* Wait until SB flag is set */
   6417              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   6418              {
   6419                if (hi2c->Instance->CR1 & I2C_CR1_START)
   6420                {
   6421                  hi2c->ErrorCode = HAL_I2C_WRONG_START;
   6422                }
   6423                return HAL_TIMEOUT;
   6424              }
   6425          
   6426              /* Send header of slave address */
   6427              hi2c->Instance->DR = I2C_10BIT_HEADER_READ(DevAddress);
   6428            }
   6429          
   6430            /* Wait until ADDR flag is set */
   6431            if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   6432            {
   6433              return HAL_ERROR;
   6434            }
   6435          
   6436            return HAL_OK;
   6437          }
   6438          
   6439          /**
   6440            * @brief  Master sends target device address followed by internal memory address for write request.
   6441            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6442            *         the configuration information for I2C module
   6443            * @param  DevAddress Target device address: The device 7 bits address value
   6444            *         in datasheet must be shifted to the left before calling the interface
   6445            * @param  MemAddress Internal memory address
   6446            * @param  MemAddSize Size of internal memory address
   6447            * @param  Timeout Timeout duration
   6448            * @param  Tickstart Tick start value
   6449            * @retval HAL status
   6450            */

   \                                 In section .text, align 2, keep-with-next
   6451          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
   6452          {
   \                     I2C_RequestMemoryWrite: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   6453            /* Generate Start */
   6454            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   \        0xC   0x9F09             LDR      R7,[SP, #+36]
   \        0xE   0x4689             MOV      R9,R1
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0xF441 0x7180      ORR      R1,R1,#0x100
   \       0x16   0x4615             MOV      R5,R2
   \       0x18   0x461E             MOV      R6,R3
   \       0x1A   0x6001             STR      R1,[R0, #+0]
   6455          
   6456            /* Wait until SB flag is set */
   6457            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \       0x1C   0x9700             STR      R7,[SP, #+0]
   \       0x1E   0x4643             MOV      R3,R8
   \       0x20   0x....'....        BL       ?Subroutine25
   \                     ??CrossCallReturnLabel_61: (+1)
   \       0x24   0xB140             CBZ.N    R0,??I2C_RequestMemoryWrite_0
   6458            {
   6459              if (hi2c->Instance->CR1 & I2C_CR1_START)
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6801             LDR      R1,[R0, #+0]
   \       0x2A   0x05CA             LSLS     R2,R1,#+23
   \       0x2C   0xBF44             ITT      MI
   \       0x2E   0xF44F 0x7000      MOVMI    R0,#+512
   \       0x32   0x6420             STRMI    R0,[R4, #+64]
   6460              {
   6461                hi2c->ErrorCode = HAL_I2C_WRONG_START;
   6462              }
   6463              return HAL_TIMEOUT;
   \       0x34   0x2003             MOVS     R0,#+3
   \       0x36   0xE025             B.N      ??I2C_RequestMemoryWrite_1
   6464            }
   6465          
   6466            /* Send slave address */
   6467            hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??I2C_RequestMemoryWrite_0: (+1)
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0xF009 0x01FE      AND      R1,R9,#0xFE
   \       0x3E   0x6101             STR      R1,[R0, #+16]
   6468          
   6469            /* Wait until ADDR flag is set */
   6470            if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \       0x40   0x463B             MOV      R3,R7
   \       0x42   0x4642             MOV      R2,R8
   \       0x44   0x....             LDR.N    R1,??DataTable36  ;; 0x10002
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x....'....        BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \       0x4C   0xB9A0             CBNZ.N   R0,??CrossCallReturnLabel_94
   6471            {
   6472              return HAL_ERROR;
   6473            }
   6474          
   6475            /* Clear ADDR flag */
   6476            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0x4E   0x9000             STR      R0,[SP, #+0]
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x....'....        BL       ?Subroutine101
   6477          
   6478            /* Wait until TXE flag is set */
   6479            if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_303: (+1)
   \       0x56   0x....'....        BL       ??Subroutine27_0
   \                     ??CrossCallReturnLabel_67: (+1)
   \       0x5A   0xB940             CBNZ.N   R0,??I2C_RequestMemoryWrite_2
   6480            {
   6481              if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   6482              {
   6483                /* Generate Stop */
   6484                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   6485              }
   6486              return HAL_ERROR;
   6487            }
   6488          
   6489            /* If Memory address size is 8Bit */
   6490            if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \       0x5C   0x2E01             CMP      R6,#+1
   \       0x5E   0xD00D             BEQ.N    ??I2C_RequestMemoryWrite_3
   6491            {
   6492              /* Send Memory Address */
   6493              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   6494            }
   6495            /* If Memory address size is 16Bit */
   6496            else
   6497            {
   6498              /* Send MSB of Memory Address */
   6499              hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
   \       0x60   0x6821             LDR      R1,[R4, #+0]
   \       0x62   0x0A28             LSRS     R0,R5,#+8
   \       0x64   0x6108             STR      R0,[R1, #+16]
   6500          
   6501              /* Wait until TXE flag is set */
   6502              if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x66   0x463A             MOV      R2,R7
   \       0x68   0x....'....        BL       ?Subroutine27
   \                     ??CrossCallReturnLabel_69: (+1)
   \       0x6C   0xB130             CBZ.N    R0,??I2C_RequestMemoryWrite_3
   6503              {
   6504                if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_RequestMemoryWrite_2: (+1)
   \       0x6E   0x6C20             LDR      R0,[R4, #+64]
   \       0x70   0x2804             CMP      R0,#+4
   \       0x72   0xD101             BNE.N    ??CrossCallReturnLabel_94
   6505                {
   6506                  /* Generate Stop */
   6507                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0x74   0x....'....        BL       ?Subroutine34
   6508                }
   6509                return HAL_ERROR;
   \                     ??CrossCallReturnLabel_94: (+1)
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0xE003             B.N      ??I2C_RequestMemoryWrite_1
   6510              }
   6511          
   6512              /* Send LSB of Memory Address */
   6513              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryWrite_3: (+1)
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0xB2ED             UXTB     R5,R5
   \       0x80   0x6105             STR      R5,[R0, #+16]
   6514            }
   6515          
   6516            return HAL_OK;
   \       0x82   0x2000             MOVS     R0,#+0
   \                     ??I2C_RequestMemoryWrite_1: (+1)
   \       0x84   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   6517          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine101: (+1)
   \        0x0   0x694A             LDR      R2,[R1, #+20]
   \        0x2   0x9200             STR      R2,[SP, #+0]
   \        0x4   0x463A             MOV      R2,R7
   \        0x6   0x6989             LDR      R1,[R1, #+24]
   \        0x8   0x9100             STR      R1,[SP, #+0]
   \        0xA   0x4641             MOV      R1,R8
   \        0xC   0x9800             LDR      R0,[SP, #+0]
   \        0xE   0x4770             BX       LR
   6518          
   6519          /**
   6520            * @brief  Master sends target device address followed by internal memory address for read request.
   6521            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6522            *         the configuration information for I2C module
   6523            * @param  DevAddress Target device address: The device 7 bits address value
   6524            *         in datasheet must be shifted to the left before calling the interface
   6525            * @param  MemAddress Internal memory address
   6526            * @param  MemAddSize Size of internal memory address
   6527            * @param  Timeout Timeout duration
   6528            * @param  Tickstart Tick start value
   6529            * @retval HAL status
   6530            */

   \                                 In section .text, align 2, keep-with-next
   6531          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
   6532          {
   \                     I2C_RequestMemoryRead: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4605             MOV      R5,R0
   6533            /* Enable Acknowledge */
   6534            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \        0xC   0x9F0B             LDR      R7,[SP, #+44]
   \        0xE   0x460C             MOV      R4,R1
   \       0x10   0x....'....        BL       ?Subroutine58
   \                     ??CrossCallReturnLabel_165: (+1)
   \       0x14   0x4616             MOV      R6,R2
   6535          
   6536            /* Generate Start */
   6537            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF441 0x7180      ORR      R1,R1,#0x100
   \       0x1E   0x4699             MOV      R9,R3
   \       0x20   0x6001             STR      R1,[R0, #+0]
   6538          
   6539            /* Wait until SB flag is set */
   6540            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \       0x22   0x....'....        BL       ?Subroutine79
   \                     ??CrossCallReturnLabel_244: (+1)
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xF44F 0x7A00      MOV      R10,#+512
   \       0x2C   0xD12C             BNE.N    ??I2C_RequestMemoryRead_0
   6541            {
   6542              if (hi2c->Instance->CR1 & I2C_CR1_START)
   6543              {
   6544                hi2c->ErrorCode = HAL_I2C_WRONG_START;
   6545              }
   6546              return HAL_TIMEOUT;
   6547            }
   6548          
   6549            /* Send slave address */
   6550            hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \       0x2E   0x6829             LDR      R1,[R5, #+0]
   6551          
   6552            /* Wait until ADDR flag is set */
   6553            if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \       0x30   0x....'....        LDR.W    R11,??DataTable36  ;; 0x10002
   \       0x34   0xF004 0x00FE      AND      R0,R4,#0xFE
   \       0x38   0x6108             STR      R0,[R1, #+16]
   \       0x3A   0x....'....        BL       ?Subroutine96
   \                     ??CrossCallReturnLabel_284: (+1)
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD132             BNE.N    ??I2C_RequestMemoryRead_1
   6554            {
   6555              return HAL_ERROR;
   6556            }
   6557          
   6558            /* Clear ADDR flag */
   6559            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0x42   0x9000             STR      R0,[SP, #+0]
   \       0x44   0x6829             LDR      R1,[R5, #+0]
   \       0x46   0x....'....        BL       ?Subroutine101
   6560          
   6561            /* Wait until TXE flag is set */
   6562            if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_304: (+1)
   \       0x4A   0x....'....        BL       ??Subroutine103_0
   \                     ??CrossCallReturnLabel_307: (+1)
   \       0x4E   0xB970             CBNZ.N   R0,??I2C_RequestMemoryRead_2
   6563            {
   6564              if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   6565              {
   6566                /* Generate Stop */
   6567                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   6568              }
   6569              return HAL_ERROR;
   6570            }
   6571          
   6572            /* If Memory address size is 8Bit */
   6573            if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \       0x50   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x54   0xD005             BEQ.N    ??I2C_RequestMemoryRead_3
   6574            {
   6575              /* Send Memory Address */
   6576              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   6577            }
   6578            /* If Memory address size is 16Bit */
   6579            else
   6580            {
   6581              /* Send MSB of Memory Address */
   6582              hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
   \       0x56   0x6829             LDR      R1,[R5, #+0]
   \       0x58   0x0A30             LSRS     R0,R6,#+8
   \       0x5A   0x6108             STR      R0,[R1, #+16]
   6583          
   6584              /* Wait until TXE flag is set */
   6585              if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x5C   0x....'....        BL       ?Subroutine103
   \                     ??CrossCallReturnLabel_309: (+1)
   \       0x60   0xB928             CBNZ.N   R0,??I2C_RequestMemoryRead_2
   6586              {
   6587                if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   6588                {
   6589                  /* Generate Stop */
   6590                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   6591                }
   6592                return HAL_ERROR;
   6593              }
   6594          
   6595              /* Send LSB of Memory Address */
   6596              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryRead_3: (+1)
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0xB2F6             UXTB     R6,R6
   \       0x66   0x6106             STR      R6,[R0, #+16]
   6597            }
   6598          
   6599            /* Wait until TXE flag is set */
   6600            if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x68   0x....'....        BL       ?Subroutine103
   \                     ??CrossCallReturnLabel_308: (+1)
   \       0x6C   0xB130             CBZ.N    R0,??I2C_RequestMemoryRead_4
   6601            {
   6602              if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_RequestMemoryRead_2: (+1)
   \       0x6E   0x6C28             LDR      R0,[R5, #+64]
   \       0x70   0x2804             CMP      R0,#+4
   \       0x72   0xD119             BNE.N    ??I2C_RequestMemoryRead_1
   6603              {
   6604                /* Generate Stop */
   6605                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0x74   0x6828             LDR      R0,[R5, #+0]
   \       0x76   0x....'....        BL       ??Subroutine53_0
   6606              }
   6607              return HAL_ERROR;
   \                     ??CrossCallReturnLabel_153: (+1)
   \       0x7A   0xE015             B.N      ??I2C_RequestMemoryRead_1
   6608            }
   6609          
   6610            /* Generate Restart */
   6611            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??I2C_RequestMemoryRead_4: (+1)
   \       0x7C   0x6828             LDR      R0,[R5, #+0]
   \       0x7E   0x....'....        BL       ??Subroutine52_0
   6612          
   6613            /* Wait until SB flag is set */
   6614            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_148: (+1)
   \       0x82   0x....'....        BL       ?Subroutine79
   \                     ??CrossCallReturnLabel_243: (+1)
   \       0x86   0xB138             CBZ.N    R0,??I2C_RequestMemoryRead_5
   6615            {
   6616              if (hi2c->Instance->CR1 & I2C_CR1_START)
   \                     ??I2C_RequestMemoryRead_0: (+1)
   \       0x88   0x6828             LDR      R0,[R5, #+0]
   \       0x8A   0x6801             LDR      R1,[R0, #+0]
   \       0x8C   0x05CA             LSLS     R2,R1,#+23
   \       0x8E   0xBF48             IT       MI
   \       0x90   0xF8C5 0xA040      STRMI    R10,[R5, #+64]
   6617              {
   6618                hi2c->ErrorCode = HAL_I2C_WRONG_START;
   6619              }
   6620              return HAL_TIMEOUT;
   \       0x94   0x2003             MOVS     R0,#+3
   \       0x96   0xE008             B.N      ??I2C_RequestMemoryRead_6
   6621            }
   6622          
   6623            /* Send slave address */
   6624            hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
   \                     ??I2C_RequestMemoryRead_5: (+1)
   \       0x98   0x6828             LDR      R0,[R5, #+0]
   \       0x9A   0xF044 0x0401      ORR      R4,R4,#0x1
   \       0x9E   0xB2E4             UXTB     R4,R4
   \       0xA0   0x6104             STR      R4,[R0, #+16]
   6625          
   6626            /* Wait until ADDR flag is set */
   6627            if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \       0xA2   0x....'....        BL       ?Subroutine96
   \                     ??CrossCallReturnLabel_283: (+1)
   \       0xA6   0xB100             CBZ.N    R0,??I2C_RequestMemoryRead_6
   \                     ??I2C_RequestMemoryRead_1: (+1)
   \       0xA8   0x2001             MOVS     R0,#+1
   6628            {
   6629              return HAL_ERROR;
   6630            }
   6631          
   6632            return HAL_OK;
   \                     ??I2C_RequestMemoryRead_6: (+1)
   \       0xAA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   6633          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine103: (+1)
   \        0x0   0x463A             MOV      R2,R7
   \        0x2   0x4641             MOV      R1,R8
   \                     ??Subroutine103_0: (+1)
   \        0x4   0x4628             MOV      R0,R5
   \        0x6   0x....             B.N      I2C_WaitOnTXEFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine96: (+1)
   \        0x0   0x463B             MOV      R3,R7
   \        0x2   0x4642             MOV      R2,R8
   \        0x4   0x4659             MOV      R1,R11
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x....             B.N      I2C_WaitOnMasterAddressFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine79: (+1)
   \        0x0   0x9700             STR      R7,[SP, #+0]
   \        0x2   0x4643             MOV      R3,R8
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0xF04F 0x1101      MOV      R1,#+65537
   \        0xA   0x4628             MOV      R0,R5
   \        0xC   0x....             B.N      I2C_WaitOnFlagUntilTimeout
   6634          
   6635          /**
   6636            * @brief  DMA I2C process complete callback.
   6637            * @param  hdma DMA handle
   6638            * @retval None
   6639            */

   \                                 In section .text, align 2, keep-with-next
   6640          static void I2C_DMAXferCplt(DMA_HandleTypeDef *hdma)
   6641          {
   \                     I2C_DMAXferCplt: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   6642            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6B84             LDR      R4,[R0, #+56]
   6643          
   6644            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   6645            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0x4   0xF104 0x013D      ADD      R1,R4,#+61
   \        0x8   0x780B             LDRB     R3,[R1, #+0]
   6646            HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
   \        0xA   0x784D             LDRB     R5,[R1, #+1]
   6647            uint32_t CurrentXferOptions       = hi2c->XferOptions;
   \        0xC   0x6AE2             LDR      R2,[R4, #+44]
   6648          
   6649            /* Disable EVT and ERR interrupt */
   6650            __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6846             LDR      R6,[R0, #+4]
   \       0x12   0xF426 0x7640      BIC      R6,R6,#0x300
   \       0x16   0x6046             STR      R6,[R0, #+4]
   6651          
   6652            /* Clear Complete callback */
   6653            if (hi2c->hdmatx != NULL)
   \       0x18   0x6B60             LDR      R0,[R4, #+52]
   \       0x1A   0xB108             CBZ.N    R0,??I2C_DMAXferCplt_0
   6654            {
   6655              hi2c->hdmatx->XferCpltCallback = NULL;
   \       0x1C   0x2600             MOVS     R6,#+0
   \       0x1E   0x63C6             STR      R6,[R0, #+60]
   6656            }
   6657            if (hi2c->hdmarx != NULL)
   \                     ??I2C_DMAXferCplt_0: (+1)
   \       0x20   0x6BA0             LDR      R0,[R4, #+56]
   \       0x22   0xB108             CBZ.N    R0,??I2C_DMAXferCplt_1
   6658            {
   6659              hi2c->hdmarx->XferCpltCallback = NULL;
   \       0x24   0x2600             MOVS     R6,#+0
   \       0x26   0x63C6             STR      R6,[R0, #+60]
   6660            }
   6661          
   6662            if ((((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_BUSY_TX) == (uint32_t)HAL_I2C_STATE_BUSY_TX) || ((((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_BUSY_RX) == (uint32_t)HAL_I2C_STATE_BUSY_RX) && (CurrentMode == HAL_I2C_MODE_SLAVE)))
   \                     ??I2C_DMAXferCplt_1: (+1)
   \       0x28   0xF003 0x0021      AND      R0,R3,#0x21
   \       0x2C   0x2821             CMP      R0,#+33
   \       0x2E   0xD005             BEQ.N    ??I2C_DMAXferCplt_2
   \       0x30   0xF003 0x0622      AND      R6,R3,#0x22
   \       0x34   0x2E22             CMP      R6,#+34
   \       0x36   0xBF08             IT       EQ
   \       0x38   0x2D20             CMPEQ    R5,#+32
   \       0x3A   0xD11C             BNE.N    ??I2C_DMAXferCplt_3
   6663            {
   6664              /* Disable DMA Request */
   6665              CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??I2C_DMAXferCplt_2: (+1)
   \       0x3C   0x....'....        BL       ?Subroutine46
   6666          
   6667              hi2c->XferCount = 0U;
   \                     ??CrossCallReturnLabel_123: (+1)
   \       0x40   0x2200             MOVS     R2,#+0
   6668          
   6669              if (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \       0x42   0x2B29             CMP      R3,#+41
   \       0x44   0x8562             STRH     R2,[R4, #+42]
   \       0x46   0xD107             BNE.N    ??I2C_DMAXferCplt_4
   6670              {
   6671                /* Set state at HAL_I2C_STATE_LISTEN */
   6672                hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
   \       0x48   0x2221             MOVS     R2,#+33
   \       0x4A   0x6322             STR      R2,[R4, #+48]
   6673                hi2c->State = HAL_I2C_STATE_LISTEN;
   \       0x4C   0x2028             MOVS     R0,#+40
   \       0x4E   0x7008             STRB     R0,[R1, #+0]
   6674          
   6675                /* Call the corresponding callback to inform upper layer of End of Transfer */
   6676          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6677                hi2c->SlaveTxCpltCallback(hi2c);
   6678          #else
   6679                HAL_I2C_SlaveTxCpltCallback(hi2c);
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0x....'....        BL       HAL_I2C_SlaveTxCpltCallback
   \       0x56   0xE008             B.N      ??I2C_DMAXferCplt_5
   6680          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6681              }
   6682              else if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \                     ??I2C_DMAXferCplt_4: (+1)
   \       0x58   0x2B2A             CMP      R3,#+42
   \       0x5A   0xD106             BNE.N    ??I2C_DMAXferCplt_5
   6683              {
   6684                /* Set state at HAL_I2C_STATE_LISTEN */
   6685                hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
   \       0x5C   0x2022             MOVS     R0,#+34
   \       0x5E   0x6320             STR      R0,[R4, #+48]
   6686                hi2c->State = HAL_I2C_STATE_LISTEN;
   \       0x60   0x2228             MOVS     R2,#+40
   \       0x62   0x700A             STRB     R2,[R1, #+0]
   6687          
   6688                /* Call the corresponding callback to inform upper layer of End of Transfer */
   6689          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6690                hi2c->SlaveRxCpltCallback(hi2c);
   6691          #else
   6692                HAL_I2C_SlaveRxCpltCallback(hi2c);
   \       0x64   0x4620             MOV      R0,R4
   \       0x66   0x....'....        BL       HAL_I2C_SlaveRxCpltCallback
   6693          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6694              }
   6695              else
   6696              {
   6697                /* Do nothing */
   6698              }
   6699          
   6700              /* Enable EVT and ERR interrupt to treat end of transfer in IRQ handler */
   6701              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \                     ??I2C_DMAXferCplt_5: (+1)
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6841             LDR      R1,[R0, #+4]
   \       0x6E   0xF441 0x7140      ORR      R1,R1,#0x300
   \       0x72   0x6041             STR      R1,[R0, #+4]
   \       0x74   0xBD70             POP      {R4-R6,PC}
   6702            }
   6703            /* Check current Mode, in case of treatment DMA handler have been preempted by a prior interrupt */
   6704            else if (hi2c->Mode != HAL_I2C_MODE_NONE)
   \                     ??I2C_DMAXferCplt_3: (+1)
   \       0x76   0x7848             LDRB     R0,[R1, #+1]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD03E             BEQ.N    ??I2C_DMAXferCplt_6
   6705            {
   6706              if (hi2c->XferCount == (uint16_t)1)
   \       0x7C   0x8D60             LDRH     R0,[R4, #+42]
   \       0x7E   0x2801             CMP      R0,#+1
   \       0x80   0xD104             BNE.N    ??I2C_DMAXferCplt_7
   6707              {
   6708                /* Disable Acknowledge */
   6709                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6803             LDR      R3,[R0, #+0]
   \       0x86   0xF423 0x6380      BIC      R3,R3,#0x400
   \       0x8A   0x6003             STR      R3,[R0, #+0]
   6710              }
   6711          
   6712              /* Disable EVT and ERR interrupt */
   6713              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \                     ??I2C_DMAXferCplt_7: (+1)
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6843             LDR      R3,[R0, #+4]
   \       0x90   0xF423 0x7340      BIC      R3,R3,#0x300
   \       0x94   0x6043             STR      R3,[R0, #+4]
   6714          
   6715              /* Prepare next transfer or stop current transfer */
   6716              if ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_OTHER_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME))
   \       0x96   0x....             LDR.N    R0,??DataTable36_1  ;; 0xffff0000
   \       0x98   0x4282             CMP      R2,R0
   \       0x9A   0xBF18             IT       NE
   \       0x9C   0x2A08             CMPNE    R2,#+8
   \       0x9E   0xD004             BEQ.N    ??I2C_DMAXferCplt_8
   \       0xA0   0xF1B2 0x4F2A      CMP      R2,#-1442840576
   \       0xA4   0xBF18             IT       NE
   \       0xA6   0x2A20             CMPNE    R2,#+32
   \       0xA8   0xD104             BNE.N    ??I2C_DMAXferCplt_9
   6717              {
   6718                /* Generate Stop */
   6719                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??I2C_DMAXferCplt_8: (+1)
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x6802             LDR      R2,[R0, #+0]
   \       0xAE   0xF442 0x7200      ORR      R2,R2,#0x200
   \       0xB2   0x6002             STR      R2,[R0, #+0]
   6720              }
   6721          
   6722              /* Disable Last DMA */
   6723              CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   6724          
   6725              /* Disable DMA Request */
   6726              CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   6727          
   6728              hi2c->XferCount = 0U;
   \                     ??I2C_DMAXferCplt_9: (+1)
   \       0xB4   0x2300             MOVS     R3,#+0
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x6842             LDR      R2,[R0, #+4]
   \       0xBA   0xF422 0x5280      BIC      R2,R2,#0x1000
   \       0xBE   0x6042             STR      R2,[R0, #+4]
   \       0xC0   0x....'....        BL       ?Subroutine46
   \                     ??CrossCallReturnLabel_124: (+1)
   \       0xC4   0x8563             STRH     R3,[R4, #+42]
   6729          
   6730              /* Check if Errors has been detected during transfer */
   6731              if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \       0xC6   0x6C20             LDR      R0,[R4, #+64]
   \       0xC8   0xB120             CBZ.N    R0,??I2C_DMAXferCplt_10
   6732              {
   6733          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6734                hi2c->ErrorCallback(hi2c);
   6735          #else
   6736                HAL_I2C_ErrorCallback(hi2c);
   \       0xCA   0x4620             MOV      R0,R4
   \       0xCC   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xD0   0x....'....        B.W      HAL_I2C_ErrorCallback
   6737          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6738              }
   6739              else
   6740              {
   6741                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_DMAXferCplt_10: (+1)
   \       0xD4   0x2020             MOVS     R0,#+32
   \       0xD6   0x7008             STRB     R0,[R1, #+0]
   6742          
   6743                if (hi2c->Mode == HAL_I2C_MODE_MEM)
   \       0xD8   0x784A             LDRB     R2,[R1, #+1]
   \       0xDA   0x704B             STRB     R3,[R1, #+1]
   \       0xDC   0x2A40             CMP      R2,#+64
   \       0xDE   0xD105             BNE.N    ??I2C_DMAXferCplt_11
   6744                {
   6745                  hi2c->Mode = HAL_I2C_MODE_NONE;
   6746                  hi2c->PreviousState = I2C_STATE_NONE;
   \       0xE0   0x6323             STR      R3,[R4, #+48]
   6747          
   6748          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6749                  hi2c->MemRxCpltCallback(hi2c);
   6750          #else
   6751                  HAL_I2C_MemRxCpltCallback(hi2c);
   \       0xE2   0x4620             MOV      R0,R4
   \       0xE4   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xE8   0x....'....        B.W      HAL_I2C_MemRxCpltCallback
   6752          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6753                }
   6754                else
   6755                {
   6756                  hi2c->Mode = HAL_I2C_MODE_NONE;
   6757                  hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
   \                     ??I2C_DMAXferCplt_11: (+1)
   \       0xEC   0x2112             MOVS     R1,#+18
   \       0xEE   0x6321             STR      R1,[R4, #+48]
   6758          
   6759          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6760                  hi2c->MasterRxCpltCallback(hi2c);
   6761          #else
   6762                  HAL_I2C_MasterRxCpltCallback(hi2c);
   \       0xF0   0x4620             MOV      R0,R4
   \       0xF2   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xF6   0x....'....        B.W      HAL_I2C_MasterRxCpltCallback
   6763          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6764                }
   6765              }
   6766            }
   6767            else
   6768            {
   6769              /* Do nothing */
   6770            }
   6771          }
   \                     ??I2C_DMAXferCplt_6: (+1)
   \       0xFA   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine46: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x6842             LDR      R2,[R0, #+4]
   \        0x4   0xF422 0x6200      BIC      R2,R2,#0x800
   \        0x8   0x6042             STR      R2,[R0, #+4]
   \        0xA   0x4770             BX       LR
   6772          
   6773          /**
   6774            * @brief  DMA I2C communication error callback.
   6775            * @param  hdma DMA handle
   6776            * @retval None
   6777            */

   \                                 In section .text, align 2, keep-with-next
   6778          static void I2C_DMAError(DMA_HandleTypeDef *hdma)
   6779          {
   \                     I2C_DMAError: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   6780            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6B84             LDR      R4,[R0, #+56]
   6781          
   6782            /* Clear Complete callback */
   6783            if (hi2c->hdmatx != NULL)
   \        0x4   0x6B61             LDR      R1,[R4, #+52]
   \        0x6   0xB109             CBZ.N    R1,??I2C_DMAError_0
   6784            {
   6785              hi2c->hdmatx->XferCpltCallback = NULL;
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x63CA             STR      R2,[R1, #+60]
   6786            }
   6787            if (hi2c->hdmarx != NULL)
   \                     ??I2C_DMAError_0: (+1)
   \        0xC   0x6BA1             LDR      R1,[R4, #+56]
   \        0xE   0xB109             CBZ.N    R1,??I2C_DMAError_1
   6788            {
   6789              hi2c->hdmarx->XferCpltCallback = NULL;
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x63CA             STR      R2,[R1, #+60]
   6790            }
   6791          
   6792            /* Ignore DMA FIFO error */
   6793            if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
   \                     ??I2C_DMAError_1: (+1)
   \       0x14   0x....'....        BL       HAL_DMA_GetError
   \       0x18   0x2802             CMP      R0,#+2
   \       0x1A   0xD00F             BEQ.N    ??I2C_DMAError_2
   6794            {
   6795              /* Disable Acknowledge */
   6796              hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \       0x1C   0x....'....        BL       ?Subroutine40
   6797          
   6798              hi2c->XferCount = 0U;
   \                     ??CrossCallReturnLabel_112: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x8560             STRH     R0,[R4, #+42]
   6799          
   6800              hi2c->State = HAL_I2C_STATE_READY;
   \       0x24   0x2120             MOVS     R1,#+32
   \       0x26   0xF104 0x003D      ADD      R0,R4,#+61
   6801              hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x7001             STRB     R1,[R0, #+0]
   \       0x2E   0x7042             STRB     R2,[R0, #+1]
   6802          
   6803              hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \       0x30   0x6C20             LDR      R0,[R4, #+64]
   \       0x32   0xF040 0x0010      ORR      R0,R0,#0x10
   \       0x36   0x6420             STR      R0,[R4, #+64]
   6804          
   6805          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6806              hi2c->ErrorCallback(hi2c);
   6807          #else
   6808              HAL_I2C_ErrorCallback(hi2c);
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x....             B.N      ?Subroutine3
   6809          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6810            }
   6811          }
   \                     ??I2C_DMAError_2: (+1)
   \       0x3C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xE8BD 0x4010      POP      {R4,LR}
   \        0x4   0x....'....        B.W      HAL_I2C_ErrorCallback
   6812          
   6813          /**
   6814            * @brief DMA I2C communication abort callback
   6815            *        (To be called at end of DMA Abort procedure).
   6816            * @param hdma DMA handle.
   6817            * @retval None
   6818            */

   \                                 In section .text, align 4, keep-with-next
   6819          static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
   6820          {
   \                     I2C_DMAAbort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   6821            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6B80             LDR      R0,[R0, #+56]
   6822          
   6823            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   6824            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0x4   0xF100 0x023D      ADD      R2,R0,#+61
   \        0x8   0x7813             LDRB     R3,[R2, #+0]
   6825          
   6826            /* Clear Complete callback */
   6827            if (hi2c->hdmatx != NULL)
   \        0xA   0x6B41             LDR      R1,[R0, #+52]
   \        0xC   0xB109             CBZ.N    R1,??I2C_DMAAbort_0
   6828            {
   6829              hi2c->hdmatx->XferCpltCallback = NULL;
   \        0xE   0x2400             MOVS     R4,#+0
   \       0x10   0x63CC             STR      R4,[R1, #+60]
   6830            }
   6831            if (hi2c->hdmarx != NULL)
   \                     ??I2C_DMAAbort_0: (+1)
   \       0x12   0x6B81             LDR      R1,[R0, #+56]
   \       0x14   0xB109             CBZ.N    R1,??I2C_DMAAbort_1
   6832            {
   6833              hi2c->hdmarx->XferCpltCallback = NULL;
   \       0x16   0x2400             MOVS     R4,#+0
   \       0x18   0x63CC             STR      R4,[R1, #+60]
   6834            }
   6835          
   6836            /* Disable Acknowledge */
   6837            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??I2C_DMAAbort_1: (+1)
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0x680C             LDR      R4,[R1, #+0]
   \       0x1E   0xF424 0x6480      BIC      R4,R4,#0x400
   \       0x22   0x600C             STR      R4,[R1, #+0]
   6838          
   6839            hi2c->XferCount = 0U;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x8541             STRH     R1,[R0, #+42]
   6840          
   6841            /* Reset XferAbortCallback */
   6842            if (hi2c->hdmatx != NULL)
   \       0x28   0x6B41             LDR      R1,[R0, #+52]
   \       0x2A   0xB109             CBZ.N    R1,??I2C_DMAAbort_2
   6843            {
   6844              hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x2C   0x2400             MOVS     R4,#+0
   \       0x2E   0x650C             STR      R4,[R1, #+80]
   6845            }
   6846            if (hi2c->hdmarx != NULL)
   \                     ??I2C_DMAAbort_2: (+1)
   \       0x30   0x6B81             LDR      R1,[R0, #+56]
   \       0x32   0xB109             CBZ.N    R1,??I2C_DMAAbort_3
   6847            {
   6848              hi2c->hdmarx->XferAbortCallback = NULL;
   \       0x34   0x2400             MOVS     R4,#+0
   \       0x36   0x650C             STR      R4,[R1, #+80]
   6849            }
   6850          
   6851            /* Disable I2C peripheral to prevent dummy data in buffer */
   6852            __HAL_I2C_DISABLE(hi2c);
   \                     ??I2C_DMAAbort_3: (+1)
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x680C             LDR      R4,[R1, #+0]
   \       0x3C   0x0864             LSRS     R4,R4,#+1
   \       0x3E   0x0064             LSLS     R4,R4,#+1
   \       0x40   0x600C             STR      R4,[R1, #+0]
   6853          
   6854            /* Check if come from abort from user */
   6855            if (hi2c->State == HAL_I2C_STATE_ABORT)
   \       0x42   0x7811             LDRB     R1,[R2, #+0]
   \       0x44   0x2960             CMP      R1,#+96
   \       0x46   0xD108             BNE.N    ??I2C_DMAAbort_4
   6856            {
   6857              hi2c->State         = HAL_I2C_STATE_READY;
   \       0x48   0x2320             MOVS     R3,#+32
   \       0x4A   0x7013             STRB     R3,[R2, #+0]
   6858              hi2c->Mode          = HAL_I2C_MODE_NONE;
   \       0x4C   0x2100             MOVS     R1,#+0
   \       0x4E   0x7051             STRB     R1,[R2, #+1]
   6859              hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
   \       0x50   0x6401             STR      R1,[R0, #+64]
   6860          
   6861              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6862          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6863              hi2c->AbortCpltCallback(hi2c);
   6864          #else
   6865              HAL_I2C_AbortCpltCallback(hi2c);
   \       0x52   0xE8BD 0x4010      POP      {R4,LR}
   \       0x56   0x....'....        B.W      HAL_I2C_AbortCpltCallback
   6866          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6867            }
   6868            else
   6869            {
   6870              if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??I2C_DMAAbort_4: (+1)
   \       0x5A   0xF003 0x0328      AND      R3,R3,#0x28
   \       0x5E   0x2B28             CMP      R3,#+40
   \       0x60   0xD10A             BNE.N    ??I2C_DMAAbort_5
   6871              {
   6872                /* Renable I2C peripheral */
   6873                __HAL_I2C_ENABLE(hi2c);
   \       0x62   0x6801             LDR      R1,[R0, #+0]
   \       0x64   0x680B             LDR      R3,[R1, #+0]
   \       0x66   0xF043 0x0301      ORR      R3,R3,#0x1
   \       0x6A   0x600B             STR      R3,[R1, #+0]
   6874          
   6875                /* Enable Acknowledge */
   6876                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   6877          
   6878                /* keep HAL_I2C_STATE_LISTEN */
   6879                hi2c->PreviousState = I2C_STATE_NONE;
   6880                hi2c->State = HAL_I2C_STATE_LISTEN;
   \       0x6C   0x2328             MOVS     R3,#+40
   \       0x6E   0x....'....        BL       ?Subroutine56
   6881              }
   \                     ??CrossCallReturnLabel_160: (+1)
   \       0x72   0x6301             STR      R1,[R0, #+48]
   \       0x74   0x7013             STRB     R3,[R2, #+0]
   \       0x76   0xE003             B.N      ??I2C_DMAAbort_6
   6882              else
   6883              {
   6884                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_DMAAbort_5: (+1)
   \       0x78   0x2120             MOVS     R1,#+32
   \       0x7A   0x7011             STRB     R1,[R2, #+0]
   6885                hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x7C   0x2400             MOVS     R4,#+0
   \       0x7E   0x7054             STRB     R4,[R2, #+1]
   6886              }
   6887          
   6888              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6889          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6890              hi2c->ErrorCallback(hi2c);
   6891          #else
   6892              HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_DMAAbort_6: (+1)
   \       0x80                      REQUIRE ?Subroutine3
   \       0x80                      ;; // Fall through to label ?Subroutine3
   6893          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6894            }
   6895          }
   6896          
   6897          /**
   6898            * @brief  This function handles I2C Communication Timeout.
   6899            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6900            *         the configuration information for I2C module
   6901            * @param  Flag specifies the I2C flag to check.
   6902            * @param  Status The new Flag status (SET or RESET).
   6903            * @param  Timeout Timeout duration
   6904            * @param  Tickstart Tick start value
   6905            * @retval HAL status
   6906            */

   \                                 In section .text, align 2, keep-with-next
   6907          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
   6908          {
   \                     I2C_WaitOnFlagUntilTimeout: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x9F06             LDR      R7,[SP, #+24]
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x461C             MOV      R4,R3
   6909            /* Wait until flag is set */
   6910            while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
   \                     ??I2C_WaitOnFlagUntilTimeout_0: (+1)
   \        0xE   0x0231             LSLS     R1,R6,#+8
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0x0E09             LSRS     R1,R1,#+24
   \       0x14   0x2901             CMP      R1,#+1
   \       0x16   0xBF0C             ITE      EQ
   \       0x18   0x6940             LDREQ    R0,[R0, #+20]
   \       0x1A   0x6980             LDRNE    R0,[R0, #+24]
   \       0x1C   0x4030             ANDS     R0,R0,R6
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0xB2B1             UXTH     R1,R6
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xBF0C             ITE      EQ
   \       0x26   0x2001             MOVEQ    R0,#+1
   \       0x28   0x2000             MOVNE    R0,#+0
   \       0x2A   0x4540             CMP      R0,R8
   \       0x2C   0xD10D             BNE.N    ??I2C_WaitOnFlagUntilTimeout_1
   6911            {
   6912              /* Check for the Timeout */
   6913              if (Timeout != HAL_MAX_DELAY)
   \       0x2E   0xF114 0x0F01      CMN      R4,#+1
   \       0x32   0xD0EC             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_0
   6914              {
   6915                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x34   0x....'....        BL       HAL_GetTick
   \       0x38   0x1BC0             SUBS     R0,R0,R7
   \       0x3A   0x4284             CMP      R4,R0
   \       0x3C   0xD301             BCC.N    ??I2C_WaitOnFlagUntilTimeout_2
   \       0x3E   0x2C00             CMP      R4,#+0
   \       0x40   0xD1E5             BNE.N    ??I2C_WaitOnFlagUntilTimeout_0
   6916                {
   6917                  hi2c->PreviousState     = I2C_STATE_NONE;
   \                     ??I2C_WaitOnFlagUntilTimeout_2: (+1)
   \       0x42   0x....'....        BL       ?Subroutine5
   6918                  hi2c->State             = HAL_I2C_STATE_READY;
   6919                  hi2c->Mode              = HAL_I2C_MODE_NONE;
   6920                  hi2c->ErrorCode         |= HAL_I2C_ERROR_TIMEOUT;
   6921          
   6922                  /* Process Unlocked */
   6923                  __HAL_UNLOCK(hi2c);
   6924          
   6925                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_3
   6926                }
   6927              }
   6928            }
   6929            return HAL_OK;
   \                     ??I2C_WaitOnFlagUntilTimeout_1: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_3: (+1)
   \       0x4C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   6930          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x6328             STR      R0,[R5, #+48]
   \        0x4   0x2120             MOVS     R1,#+32
   \        0x6   0xF105 0x003C      ADD      R0,R5,#+60
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x7041             STRB     R1,[R0, #+1]
   \        0xE   0x7082             STRB     R2,[R0, #+2]
   \       0x10   0x6841             LDR      R1,[R0, #+4]
   \       0x12   0xF041 0x0120      ORR      R1,R1,#0x20
   \       0x16   0x6041             STR      R1,[R0, #+4]
   \       0x18   0x7002             STRB     R2,[R0, #+0]
   \       0x1A   0x4770             BX       LR
   6931          
   6932          /**
   6933            * @brief  This function handles I2C Communication Timeout for Master addressing phase.
   6934            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6935            *         the configuration information for I2C module
   6936            * @param  Flag specifies the I2C flag to check.
   6937            * @param  Timeout Timeout duration
   6938            * @param  Tickstart Tick start value
   6939            * @retval HAL status
   6940            */

   \                                 In section .text, align 2, keep-with-next
   6941          static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart)
   6942          {
   \                     I2C_WaitOnMasterAddressFlagUntilTimeout: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x461F             MOV      R7,R3
   6943            while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_0: (+1)
   \        0xA   0x0231             LSLS     R1,R6,#+8
   \        0xC   0x0E09             LSRS     R1,R1,#+24
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD11A             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_1
   \       0x14   0x6941             LDR      R1,[R0, #+20]
   \       0x16   0x4031             ANDS     R1,R1,R6
   \       0x18   0xB289             UXTH     R1,R1
   \       0x1A   0xB2B2             UXTH     R2,R6
   \       0x1C   0x4291             CMP      R1,R2
   \       0x1E   0xD01A             BEQ.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_2
   6944            {
   6945              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_3: (+1)
   \       0x20   0x6940             LDR      R0,[R0, #+20]
   \       0x22   0x0541             LSLS     R1,R0,#+21
   \       0x24   0xD519             BPL.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_4
   6946              {
   6947                /* Generate Stop */
   6948                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x....'....        BL       ?Subroutine50
   6949          
   6950                /* Clear AF Flag */
   6951                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??CrossCallReturnLabel_140: (+1)
   \       0x2C   0x682A             LDR      R2,[R5, #+0]
   \       0x2E   0x6150             STR      R0,[R2, #+20]
   6952          
   6953                hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x30   0x2100             MOVS     R1,#+0
   6954                hi2c->State               = HAL_I2C_STATE_READY;
   \       0x32   0xF105 0x003C      ADD      R0,R5,#+60
   \       0x36   0x6329             STR      R1,[R5, #+48]
   \       0x38   0x2220             MOVS     R2,#+32
   \       0x3A   0x7042             STRB     R2,[R0, #+1]
   6955                hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x3C   0x7081             STRB     R1,[R0, #+2]
   6956                hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
   \       0x3E   0x6842             LDR      R2,[R0, #+4]
   \       0x40   0xF042 0x0204      ORR      R2,R2,#0x4
   \       0x44   0x6042             STR      R2,[R0, #+4]
   6957          
   6958                /* Process Unlocked */
   6959                __HAL_UNLOCK(hi2c);
   \       0x46   0x7001             STRB     R1,[R0, #+0]
   6960          
   6961                return HAL_ERROR;
   \       0x48   0xE013             B.N      ??CrossCallReturnLabel_10
   6962              }
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_1: (+1)
   \       0x4A   0x6981             LDR      R1,[R0, #+24]
   \       0x4C   0x4031             ANDS     R1,R1,R6
   \       0x4E   0xB289             UXTH     R1,R1
   \       0x50   0xB2B2             UXTH     R2,R6
   \       0x52   0x4291             CMP      R1,R2
   \       0x54   0xD1E4             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   6963          
   6964              /* Check for the Timeout */
   6965              if (Timeout != HAL_MAX_DELAY)
   6966              {
   6967                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   6968                {
   6969                  hi2c->PreviousState       = I2C_STATE_NONE;
   6970                  hi2c->State               = HAL_I2C_STATE_READY;
   6971                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   6972                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   6973          
   6974                  /* Process Unlocked */
   6975                  __HAL_UNLOCK(hi2c);
   6976          
   6977                  return HAL_ERROR;
   6978                }
   6979              }
   6980            }
   6981            return HAL_OK;
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_2: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_4: (+1)
   \       0x5A   0xF114 0x0F01      CMN      R4,#+1
   \       0x5E   0xD0D4             BEQ.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_0
   \       0x60   0x....'....        BL       HAL_GetTick
   \       0x64   0x1BC0             SUBS     R0,R0,R7
   \       0x66   0x4284             CMP      R4,R0
   \       0x68   0xD301             BCC.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_5
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD1CD             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_0
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_5: (+1)
   \       0x6E   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   6982          }
   6983          
   6984          /**
   6985            * @brief  This function handles I2C Communication Timeout for specific usage of TXE flag.
   6986            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6987            *                the configuration information for the specified I2C.
   6988            * @param  Timeout Timeout duration
   6989            * @param  Tickstart Tick start value
   6990            * @retval HAL status
   6991            */

   \                                 In section .text, align 2, keep-with-next
   6992          static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   6993          {
   \                     I2C_WaitOnTXEFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   6994            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6941             LDR      R1,[R0, #+20]
   \        0xC   0x0608             LSLS     R0,R1,#+24
   \        0xE   0xD412             BMI.N    ??I2C_WaitOnTXEFlagUntilTimeout_1
   6995            {
   6996              /* Check if a NACK is detected */
   6997              if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x....'....        BL       I2C_IsAcknowledgeFailed
   \       0x16   0xB108             CBZ.N    R0,??I2C_WaitOnTXEFlagUntilTimeout_2
   6998              {
   6999                return HAL_ERROR;
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_3: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xBD70             POP      {R4-R6,PC}       ;; return
   7000              }
   7001          
   7002              /* Check for the Timeout */
   7003              if (Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_2: (+1)
   \       0x1C   0xF114 0x0F01      CMN      R4,#+1
   \       0x20   0xD0F2             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_0
   7004              {
   7005                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x22   0x....'....        BL       HAL_GetTick
   \       0x26   0x1B80             SUBS     R0,R0,R6
   \       0x28   0x4284             CMP      R4,R0
   \       0x2A   0xD301             BCC.N    ??I2C_WaitOnTXEFlagUntilTimeout_4
   \       0x2C   0x2C00             CMP      R4,#+0
   \       0x2E   0xD1EB             BNE.N    ??I2C_WaitOnTXEFlagUntilTimeout_0
   7006                {
   7007                  hi2c->PreviousState       = I2C_STATE_NONE;
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_4: (+1)
   \       0x30   0x....'....        BL       ?Subroutine5
   7008                  hi2c->State               = HAL_I2C_STATE_READY;
   7009                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   7010                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   7011          
   7012                  /* Process Unlocked */
   7013                  __HAL_UNLOCK(hi2c);
   7014          
   7015                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x34   0xE7F0             B.N      ??I2C_WaitOnTXEFlagUntilTimeout_3
   7016                }
   7017              }
   7018            }
   7019            return HAL_OK;
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_1: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD70             POP      {R4-R6,PC}
   7020          }
   7021          
   7022          /**
   7023            * @brief  This function handles I2C Communication Timeout for specific usage of BTF flag.
   7024            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7025            *                the configuration information for the specified I2C.
   7026            * @param  Timeout Timeout duration
   7027            * @param  Tickstart Tick start value
   7028            * @retval HAL status
   7029            */

   \                                 In section .text, align 2, keep-with-next
   7030          static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   7031          {
   \                     I2C_WaitOnBTFFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   7032            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6941             LDR      R1,[R0, #+20]
   \        0xC   0x0748             LSLS     R0,R1,#+29
   \        0xE   0xD412             BMI.N    ??I2C_WaitOnBTFFlagUntilTimeout_1
   7033            {
   7034              /* Check if a NACK is detected */
   7035              if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x....'....        BL       I2C_IsAcknowledgeFailed
   \       0x16   0xB108             CBZ.N    R0,??I2C_WaitOnBTFFlagUntilTimeout_2
   7036              {
   7037                return HAL_ERROR;
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_3: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xBD70             POP      {R4-R6,PC}       ;; return
   7038              }
   7039          
   7040              /* Check for the Timeout */
   7041              if (Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_2: (+1)
   \       0x1C   0xF114 0x0F01      CMN      R4,#+1
   \       0x20   0xD0F2             BEQ.N    ??I2C_WaitOnBTFFlagUntilTimeout_0
   7042              {
   7043                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x22   0x....'....        BL       HAL_GetTick
   \       0x26   0x1B80             SUBS     R0,R0,R6
   \       0x28   0x4284             CMP      R4,R0
   \       0x2A   0xD301             BCC.N    ??I2C_WaitOnBTFFlagUntilTimeout_4
   \       0x2C   0x2C00             CMP      R4,#+0
   \       0x2E   0xD1EB             BNE.N    ??I2C_WaitOnBTFFlagUntilTimeout_0
   7044                {
   7045                  hi2c->PreviousState       = I2C_STATE_NONE;
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_4: (+1)
   \       0x30   0x....'....        BL       ?Subroutine5
   7046                  hi2c->State               = HAL_I2C_STATE_READY;
   7047                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   7048                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   7049          
   7050                  /* Process Unlocked */
   7051                  __HAL_UNLOCK(hi2c);
   7052          
   7053                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x34   0xE7F0             B.N      ??I2C_WaitOnBTFFlagUntilTimeout_3
   7054                }
   7055              }
   7056            }
   7057            return HAL_OK;
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_1: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD70             POP      {R4-R6,PC}
   7058          }
   7059          
   7060          /**
   7061            * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
   7062            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7063            *                the configuration information for the specified I2C.
   7064            * @param  Timeout Timeout duration
   7065            * @param  Tickstart Tick start value
   7066            * @retval HAL status
   7067            */
   7068          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   7069          {
   7070            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   7071            {
   7072              /* Check if a NACK is detected */
   7073              if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   7074              {
   7075                return HAL_ERROR;
   7076              }
   7077          
   7078              /* Check for the Timeout */
   7079              if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   7080              {
   7081                hi2c->PreviousState       = I2C_STATE_NONE;
   7082                hi2c->State               = HAL_I2C_STATE_READY;
   7083                hi2c->Mode                = HAL_I2C_MODE_NONE;
   7084                hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   7085          
   7086                /* Process Unlocked */
   7087                __HAL_UNLOCK(hi2c);
   7088          
   7089                return HAL_ERROR;
   7090              }
   7091            }
   7092            return HAL_OK;
   7093          }
   7094          
   7095          /**
   7096            * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
   7097            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7098            *                the configuration information for the specified I2C.
   7099            * @param  Timeout Timeout duration
   7100            * @param  Tickstart Tick start value
   7101            * @retval HAL status
   7102            */

   \                                 In section .text, align 2, keep-with-next
   7103          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   7104          {
   \                     I2C_WaitOnRXNEFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   7105          
   7106            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6941             LDR      R1,[R0, #+20]
   \        0xC   0x064A             LSLS     R2,R1,#+25
   \        0xE   0xD417             BMI.N    ??I2C_WaitOnRXNEFlagUntilTimeout_1
   7107            {
   7108              /* Check if a STOPF is detected */
   7109              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \       0x10   0x6941             LDR      R1,[R0, #+20]
   \       0x12   0x06CA             LSLS     R2,R1,#+27
   \       0x14   0xD40B             BMI.N    ??I2C_WaitOnRXNEFlagUntilTimeout_2
   7110              {
   7111                /* Clear STOP Flag */
   7112                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   7113          
   7114                hi2c->PreviousState       = I2C_STATE_NONE;
   7115                hi2c->State               = HAL_I2C_STATE_READY;
   7116                hi2c->Mode                = HAL_I2C_MODE_NONE;
   7117                hi2c->ErrorCode           |= HAL_I2C_ERROR_NONE;
   7118          
   7119                /* Process Unlocked */
   7120                __HAL_UNLOCK(hi2c);
   7121          
   7122                return HAL_ERROR;
   7123              }
   7124          
   7125              /* Check for the Timeout */
   7126              if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x16   0x....'....        BL       HAL_GetTick
   \       0x1A   0x1B80             SUBS     R0,R0,R6
   \       0x1C   0x4284             CMP      R4,R0
   \       0x1E   0xD301             BCC.N    ??I2C_WaitOnRXNEFlagUntilTimeout_3
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD1F1             BNE.N    ??I2C_WaitOnRXNEFlagUntilTimeout_0
   7127              {
   7128                hi2c->PreviousState       = I2C_STATE_NONE;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_3: (+1)
   \       0x24   0x....'....        BL       ?Subroutine16
   7129                hi2c->State               = HAL_I2C_STATE_READY;
   7130                hi2c->Mode                = HAL_I2C_MODE_NONE;
   7131                hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   7132          
   7133                /* Process Unlocked */
   7134                __HAL_UNLOCK(hi2c);
   7135          
   7136                return HAL_ERROR;
   7137              }
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x28   0xF041 0x0120      ORR      R1,R1,#0x20
   \       0x2C   0xE004             B.N      ??CrossCallReturnLabel_33
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_2: (+1)
   \       0x2E   0xF06F 0x0110      MVN      R1,#+16
   \       0x32   0x6141             STR      R1,[R0, #+20]
   \       0x34   0x....'....        BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x38   0x6041             STR      R1,[R0, #+4]
   \       0x3A   0x7002             STRB     R2,[R0, #+0]
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return
   7138            }
   7139            return HAL_OK;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_1: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD70             POP      {R4-R6,PC}
   7140          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x6328             STR      R0,[R5, #+48]
   \        0x4   0x2120             MOVS     R1,#+32
   \        0x6   0xF105 0x003C      ADD      R0,R5,#+60
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x7041             STRB     R1,[R0, #+1]
   \        0xE   0x7082             STRB     R2,[R0, #+2]
   \       0x10   0x6841             LDR      R1,[R0, #+4]
   \       0x12   0x4770             BX       LR
   7141          
   7142          /**
   7143            * @brief  This function handles Acknowledge failed detection during an I2C Communication.
   7144            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7145            *                the configuration information for the specified I2C.
   7146            * @retval HAL status
   7147            */

   \                                 In section .text, align 2, keep-with-next
   7148          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
   7149          {
   7150            if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \                     I2C_IsAcknowledgeFailed: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x694A             LDR      R2,[R1, #+20]
   \        0x4   0x0553             LSLS     R3,R2,#+21
   \        0x6   0xD50F             BPL.N    ??I2C_IsAcknowledgeFailed_0
   7151            {
   7152              /* Clear NACKF Flag */
   7153              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \        0x8   0xF46F 0x6280      MVN      R2,#+1024
   \        0xC   0x614A             STR      R2,[R1, #+20]
   7154          
   7155              hi2c->PreviousState       = I2C_STATE_NONE;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x6301             STR      R1,[R0, #+48]
   7156              hi2c->State               = HAL_I2C_STATE_READY;
   \       0x12   0x303C             ADDS     R0,R0,#+60
   \       0x14   0x2220             MOVS     R2,#+32
   \       0x16   0x7042             STRB     R2,[R0, #+1]
   7157              hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x18   0x7081             STRB     R1,[R0, #+2]
   7158              hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
   \       0x1A   0x6842             LDR      R2,[R0, #+4]
   \       0x1C   0xF042 0x0204      ORR      R2,R2,#0x4
   \       0x20   0x6042             STR      R2,[R0, #+4]
   7159          
   7160              /* Process Unlocked */
   7161              __HAL_UNLOCK(hi2c);
   \       0x22   0x7001             STRB     R1,[R0, #+0]
   7162          
   7163              return HAL_ERROR;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x4770             BX       LR
   7164            }
   7165            return HAL_OK;
   \                     ??I2C_IsAcknowledgeFailed_0: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x4770             BX       LR               ;; return
   7166          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x0001'86A1        DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x001E'8480        DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x003D'0900        DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x000F'4240        DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0xFFFF'3000        DC32     0xffff3000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0xFFFF'7C00        DC32     0xffff7c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x0010'0002        DC32     0x100002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x0001'0008        DC32     0x10008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x0001'0002        DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x0001'0004        DC32     0x10004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     I2C_DMAXferCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \        0x0   0x....'....        DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \        0x0   0x0010'0002        DC32     0x100002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \        0x0   0x....'....        DC32     I2C_DMAXferCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \        0x0   0x....'....        DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \        0x0   0x....'....        DC32     I2C_DMAAbort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \        0x0   0x0001'0002        DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_1:
   \        0x0   0xFFFF'0000        DC32     0xffff0000
   7167          
   7168          /**
   7169            * @brief  Convert I2Cx OTHER_xxx XferOptions to functionnal XferOptions.
   7170            * @param  hi2c I2C handle.
   7171            * @retval None
   7172            */
   7173          static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
   7174          {
   7175            /* if user set XferOptions to I2C_OTHER_FRAME            */
   7176            /* it request implicitly to generate a restart condition */
   7177            /* set XferOptions to I2C_FIRST_FRAME                    */
   7178            if (hi2c->XferOptions == I2C_OTHER_FRAME)
   7179            {
   7180              hi2c->XferOptions = I2C_FIRST_FRAME;
   7181            }
   7182            /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */
   7183            /* it request implicitly to generate a restart condition    */
   7184            /* then generate a stop condition at the end of transfer    */
   7185            /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
   7186            else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
   7187            {
   7188              hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
   7189            }
   7190            else
   7191            {
   7192              /* Nothing to do */
   7193            }
   7194          }
   7195          
   7196          /**
   7197            * @}
   7198            */
   7199          
   7200          #endif /* HAL_I2C_MODULE_ENABLED */
   7201          /**
   7202            * @}
   7203            */
   7204          
   7205          /**
   7206            * @}
   7207            */
   7208          
   7209          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_I2C_AbortCpltCallback
       0   HAL_I2C_AddrCallback
      16   HAL_I2C_DeInit
        16   -> HAL_I2C_MspDeInit
       8   HAL_I2C_DisableListen_IT
      24   HAL_I2C_ER_IRQHandler
        24   -> HAL_I2C_ListenCpltCallback
        24   -> HAL_I2C_SlaveTxCpltCallback
         0   -> I2C_ITError
      32   HAL_I2C_EV_IRQHandler
        32   -- Indirect call
        32   -> HAL_DMA_Abort_IT
        32   -> HAL_DMA_GetState
         0   -> HAL_I2C_AddrCallback
         0   -> HAL_I2C_ListenCpltCallback
         0   -> HAL_I2C_MasterRxCpltCallback
         0   -> HAL_I2C_MasterTxCpltCallback
         0   -> HAL_I2C_MemRxCpltCallback
         0   -> HAL_I2C_MemTxCpltCallback
         0   -> HAL_I2C_SlaveRxCpltCallback
        32   -> HAL_I2C_SlaveRxCpltCallback
         0   -> HAL_I2C_SlaveTxCpltCallback
         0   -> I2C_ITError
         0   -> I2C_MemoryTransmit_TXE_BTF
       0   HAL_I2C_EnableListen_IT
       0   HAL_I2C_ErrorCallback
       0   HAL_I2C_GetError
       0   HAL_I2C_GetMode
       0   HAL_I2C_GetState
      24   HAL_I2C_Init
        24   -> HAL_I2C_MspInit
        24   -> HAL_RCC_GetPCLK1Freq
      40   HAL_I2C_IsDeviceReady
        40   -> HAL_GetTick
        40   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_ListenCpltCallback
       0   HAL_I2C_MasterRxCpltCallback
       0   HAL_I2C_MasterTxCpltCallback
       8   HAL_I2C_Master_Abort_IT
         8   -> I2C_ITError
      40   HAL_I2C_Master_Receive
        40   -> HAL_GetTick
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        40   -> I2C_WaitOnRXNEFlagUntilTimeout
      32   HAL_I2C_Master_Receive_DMA
        32   -> HAL_DMA_Start_IT
      28   HAL_I2C_Master_Receive_IT
      32   HAL_I2C_Master_Seq_Receive_DMA
        32   -> HAL_DMA_Start_IT
      28   HAL_I2C_Master_Seq_Receive_IT
      32   HAL_I2C_Master_Seq_Transmit_DMA
        32   -> HAL_DMA_Start_IT
      28   HAL_I2C_Master_Seq_Transmit_IT
      32   HAL_I2C_Master_Transmit
        32   -> HAL_GetTick
        32   -> I2C_WaitOnBTFFlagUntilTimeout
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      32   HAL_I2C_Master_Transmit_DMA
        32   -> HAL_DMA_Start_IT
      28   HAL_I2C_Master_Transmit_IT
       0   HAL_I2C_MemRxCpltCallback
       0   HAL_I2C_MemTxCpltCallback
      40   HAL_I2C_Mem_Read
        40   -> HAL_GetTick
        40   -> I2C_RequestMemoryRead
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnRXNEFlagUntilTimeout
      40   HAL_I2C_Mem_Read_DMA
        40   -> HAL_DMA_Start_IT
        40   -> HAL_GetTick
        40   -> I2C_RequestMemoryRead
      28   HAL_I2C_Mem_Read_IT
      40   HAL_I2C_Mem_Write
        40   -> HAL_GetTick
        40   -> I2C_RequestMemoryWrite
        40   -> I2C_WaitOnBTFFlagUntilTimeout
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnTXEFlagUntilTimeout
      40   HAL_I2C_Mem_Write_DMA
        40   -> HAL_DMA_Start_IT
        40   -> HAL_GetTick
        40   -> I2C_RequestMemoryWrite
      28   HAL_I2C_Mem_Write_IT
       0   HAL_I2C_MspDeInit
       0   HAL_I2C_MspInit
       0   HAL_I2C_SlaveRxCpltCallback
       0   HAL_I2C_SlaveTxCpltCallback
      32   HAL_I2C_Slave_Receive
        32   -> HAL_GetTick
        32   -> I2C_IsAcknowledgeFailed
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnRXNEFlagUntilTimeout
      16   HAL_I2C_Slave_Receive_DMA
        16   -> HAL_DMA_Start_IT
      16   HAL_I2C_Slave_Receive_IT
      32   HAL_I2C_Slave_Seq_Receive_DMA
        32   -- Indirect call
        32   -> HAL_DMA_Abort_IT
        32   -> HAL_DMA_Start_IT
      24   HAL_I2C_Slave_Seq_Receive_IT
      32   HAL_I2C_Slave_Seq_Transmit_DMA
        32   -- Indirect call
        32   -> HAL_DMA_Abort_IT
        32   -> HAL_DMA_Start_IT
      24   HAL_I2C_Slave_Seq_Transmit_IT
      32   HAL_I2C_Slave_Transmit
        32   -> HAL_GetTick
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      16   HAL_I2C_Slave_Transmit_DMA
        16   -> HAL_DMA_Start_IT
      16   HAL_I2C_Slave_Transmit_IT
       8   I2C_DMAAbort
         0   -> HAL_I2C_AbortCpltCallback
         0   -> HAL_I2C_ErrorCallback
       8   I2C_DMAError
         8   -> HAL_DMA_GetError
         0   -> HAL_I2C_ErrorCallback
      16   I2C_DMAXferCplt
         0   -> HAL_I2C_ErrorCallback
         0   -> HAL_I2C_MasterRxCpltCallback
         0   -> HAL_I2C_MemRxCpltCallback
        16   -> HAL_I2C_SlaveRxCpltCallback
        16   -> HAL_I2C_SlaveTxCpltCallback
      16   I2C_ITError
        16   -- Indirect call
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_I2C_AbortCpltCallback
        16   -> HAL_I2C_ErrorCallback
         0   -> HAL_I2C_ListenCpltCallback
       0   I2C_IsAcknowledgeFailed
       0   I2C_MemoryTransmit_TXE_BTF
      40   I2C_RequestMemoryRead
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        40   -> I2C_WaitOnTXEFlagUntilTimeout
      32   I2C_RequestMemoryWrite
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      16   I2C_WaitOnBTFFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      24   I2C_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick
      24   I2C_WaitOnMasterAddressFlagUntilTimeout
        24   -> HAL_GetTick
      16   I2C_WaitOnRXNEFlagUntilTimeout
        16   -> HAL_GetTick
      16   I2C_WaitOnTXEFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable17
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable29
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable34
       4  ??DataTable35
       4  ??DataTable36
       4  ??DataTable36_1
      24  ??Subroutine126_0
       8  ??Subroutine127_0
      48  ?Subroutine0
      44  ?Subroutine1
      28  ?Subroutine10
      18  ?Subroutine100
      16  ?Subroutine101
      16  ?Subroutine102
       8  ?Subroutine103
      34  ?Subroutine104
      16  ?Subroutine105
      18  ?Subroutine106
      10  ?Subroutine107
      16  ?Subroutine108
      14  ?Subroutine109
      28  ?Subroutine11
      12  ?Subroutine110
      12  ?Subroutine111
      22  ?Subroutine112
       8  ?Subroutine113
      12  ?Subroutine114
      10  ?Subroutine115
      12  ?Subroutine116
      14  ?Subroutine117
      20  ?Subroutine118
      14  ?Subroutine119
      34  ?Subroutine12
      14  ?Subroutine120
      14  ?Subroutine121
      18  ?Subroutine122
      12  ?Subroutine123
      14  ?Subroutine124
      10  ?Subroutine125
      30  ?Subroutine13
      26  ?Subroutine14
      30  ?Subroutine15
      20  ?Subroutine16
      12  ?Subroutine17
      34  ?Subroutine18
      16  ?Subroutine19
      16  ?Subroutine2
      14  ?Subroutine20
      32  ?Subroutine21
      16  ?Subroutine22
      12  ?Subroutine23
      22  ?Subroutine24
      12  ?Subroutine25
      16  ?Subroutine26
       6  ?Subroutine27
      12  ?Subroutine28
      12  ?Subroutine29
       8  ?Subroutine3
      28  ?Subroutine30
      32  ?Subroutine31
      16  ?Subroutine32
      16  ?Subroutine33
      12  ?Subroutine34
      16  ?Subroutine35
      12  ?Subroutine36
      16  ?Subroutine37
      14  ?Subroutine38
      14  ?Subroutine39
      16  ?Subroutine4
      12  ?Subroutine40
      16  ?Subroutine41
      18  ?Subroutine42
      12  ?Subroutine43
      12  ?Subroutine44
      12  ?Subroutine45
      12  ?Subroutine46
      12  ?Subroutine47
      28  ?Subroutine48
      10  ?Subroutine49
      28  ?Subroutine5
      14  ?Subroutine50
      42  ?Subroutine51
      12  ?Subroutine52
      12  ?Subroutine53
      16  ?Subroutine54
      12  ?Subroutine55
      14  ?Subroutine56
      16  ?Subroutine57
      10  ?Subroutine58
      14  ?Subroutine59
      20  ?Subroutine6
      12  ?Subroutine60
      10  ?Subroutine61
      32  ?Subroutine62
      12  ?Subroutine63
       8  ?Subroutine64
      10  ?Subroutine65
      24  ?Subroutine66
      16  ?Subroutine67
      12  ?Subroutine68
      18  ?Subroutine69
      44  ?Subroutine7
      16  ?Subroutine70
      20  ?Subroutine71
      22  ?Subroutine72
      12  ?Subroutine73
      12  ?Subroutine74
      12  ?Subroutine75
       8  ?Subroutine76
      14  ?Subroutine77
      10  ?Subroutine78
      14  ?Subroutine79
      18  ?Subroutine8
      12  ?Subroutine80
      24  ?Subroutine81
      12  ?Subroutine82
      14  ?Subroutine83
      20  ?Subroutine84
      34  ?Subroutine85
      32  ?Subroutine86
      34  ?Subroutine87
      20  ?Subroutine88
      28  ?Subroutine89
      30  ?Subroutine9
      12  ?Subroutine90
      12  ?Subroutine91
      20  ?Subroutine92
      32  ?Subroutine93
      20  ?Subroutine94
      12  ?Subroutine95
      10  ?Subroutine96
      26  ?Subroutine97
      12  ?Subroutine98
      16  ?Subroutine99
       2  HAL_I2C_AbortCpltCallback
       2  HAL_I2C_AddrCallback
      40  HAL_I2C_DeInit
      60  HAL_I2C_DisableListen_IT
     284  HAL_I2C_ER_IRQHandler
   1'556  HAL_I2C_EV_IRQHandler
      58  HAL_I2C_EnableListen_IT
       2  HAL_I2C_ErrorCallback
       4  HAL_I2C_GetError
       6  HAL_I2C_GetMode
       6  HAL_I2C_GetState
     300  HAL_I2C_Init
     276  HAL_I2C_IsDeviceReady
       2  HAL_I2C_ListenCpltCallback
       2  HAL_I2C_MasterRxCpltCallback
       2  HAL_I2C_MasterTxCpltCallback
      84  HAL_I2C_Master_Abort_IT
     436  HAL_I2C_Master_Receive
     140  HAL_I2C_Master_Receive_DMA
      96  HAL_I2C_Master_Receive_IT
     348  HAL_I2C_Master_Seq_Receive_DMA
     266  HAL_I2C_Master_Seq_Receive_IT
     212  HAL_I2C_Master_Seq_Transmit_DMA
     158  HAL_I2C_Master_Seq_Transmit_IT
     310  HAL_I2C_Master_Transmit
     124  HAL_I2C_Master_Transmit_DMA
      98  HAL_I2C_Master_Transmit_IT
       2  HAL_I2C_MemRxCpltCallback
       2  HAL_I2C_MemTxCpltCallback
     288  HAL_I2C_Mem_Read
     262  HAL_I2C_Mem_Read_DMA
     106  HAL_I2C_Mem_Read_IT
     198  HAL_I2C_Mem_Write
     248  HAL_I2C_Mem_Write_DMA
      98  HAL_I2C_Mem_Write_IT
       2  HAL_I2C_MspDeInit
       2  HAL_I2C_MspInit
       2  HAL_I2C_SlaveRxCpltCallback
       2  HAL_I2C_SlaveTxCpltCallback
     226  HAL_I2C_Slave_Receive
      60  HAL_I2C_Slave_Receive_DMA
      40  HAL_I2C_Slave_Receive_IT
     188  HAL_I2C_Slave_Seq_Receive_DMA
      36  HAL_I2C_Slave_Seq_Receive_IT
     188  HAL_I2C_Slave_Seq_Transmit_DMA
      36  HAL_I2C_Slave_Seq_Transmit_IT
     240  HAL_I2C_Slave_Transmit
      56  HAL_I2C_Slave_Transmit_DMA
      40  HAL_I2C_Slave_Transmit_IT
     128  I2C_DMAAbort
      62  I2C_DMAError
     252  I2C_DMAXferCplt
     242  I2C_ITError
      44  I2C_IsAcknowledgeFailed
     122  I2C_MemoryTransmit_TXE_BTF
     174  I2C_RequestMemoryRead
     136  I2C_RequestMemoryWrite
      58  I2C_WaitOnBTFFlagUntilTimeout
      80  I2C_WaitOnFlagUntilTimeout
     118  I2C_WaitOnMasterAddressFlagUntilTimeout
      68  I2C_WaitOnRXNEFlagUntilTimeout
      58  I2C_WaitOnTXEFlagUntilTimeout

 
 11'112 bytes in section .text
 
 11'088 bytes of CODE memory (+ 24 bytes shared)

Errors: none
Warnings: none
